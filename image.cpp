#include "image.h"
#include <cmath>
int f[white_num_MAX * CAMERA_H];//考察连通域联通性
//每个白条子属性
typedef struct {
    uint8_t   left;//左边界
    uint8_t   right;//右边界
    int   connect_num;//连通标记
}range;

//每行的所有白条子
typedef struct {
    uint8_t   num;//每行白条数量
    range   area[white_num_MAX];//该行各白条区域
}all_range;

//属于赛道的每个白条子属性
typedef struct {
    uint8_t   left;//左边界
    uint8_t   right;//右边界
    uint8_t   width;//宽度
}road_range;

//每行属于赛道的每个白条子
typedef struct {
    uint8_t   white_num;
    road_range   connected[white_num_MAX];
}road;



int image_debug = 0;
int curState = 32;
all_range white_range[CAMERA_H];//所有白条子
road my_road[CAMERA_H];//赛道
uint8_t IMG[CAMERA_H][CAMERA_W];//二值化后图像数组
uint8_t leftEdge[CAMERA_H], rightEdge[CAMERA_H];
uint8_t left_line[CAMERA_H], right_line[CAMERA_H];//赛道的左右边界
uint8_t mid_line[CAMERA_H];
int16_t midLine[CAMERA_H];//弯道斜率平移补线中线
int all_connect_num = 0;//所有白条子数
uint8_t top_road;//赛道最高处所在行数
stateMgr_t stateMgr = { others,others };
TiltEnterTriCross_t TiltFeatureMgr = { MISS,MISS,MISS,MISS,MISS,MISS };
uint8_t *fullBuffer;

int  ctrl_cirDir = 1;//1为起始左转，-1为右转
uint8_t edgeLineEnum = 0, supplyEdgeLineEnum = 0;
float leftVaric = 0, rightVaric = 0;
int32_t jumpPosVar = MISS;
uint8_t leftJumpPos = MISS, rightJumpPos = MISS;
int16_t stateEnum = 0, supplyStateEnum = 0;
uint8_t cuspLine = MISS;
uint8_t image_remedyFlag = 0;
uint8_t image_adcJudge = 0;
int image_rampCanUp = 1;

uint8_t left_side[CAMERA_H] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,7,7,7,7,7,12,12,12,12,16,16,16,16,20,20,20,20,23,23,23,27,27,27,27,29,29,32,32,32,34,34,37,37,37,39,39,41,42,42,44,44,46,47,47,49,50,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,75,76,77 };
uint8_t right_side[CAMERA_H] = { 187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,185,185,185,185,185,185,180,180,180,180,180,175,175,175,175,171,171,171,171,167,167,167,167,164,164,164,160,160,160,160,158,158,155,155,155,153,153,150,150,150,148,148,146,145,145,143,143,141,140,140,138,137,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,112,111,110 };
uint8_t image_transformX[120 * 188] = { 157,157,156,155,155,155,154,153,153,152,151,150,150,149,149,149,148,147,146,146,145,144,144,143,142,141,141,140,139,139,138,137,136,136,135,134,134,133,132,131,131,130,130,130,129,128,127,127,126,125,125,124,123,122,122,121,120,120,119,118,117,117,116,115,115,114,113,112,112,111,109,109,108,107,106,106,105,104,104,103,102,101,101,100,99,99,98,97,96,96,95,94,94,93,92,91,91,90,89,89,88,87,86,86,85,84,84,83,82,81,81,80,79,79,78,77,76,76,75,74,74,73,72,71,71,70,69,69,68,67,66,66,65,64,64,63,62,61,61,60,59,59,58,57,56,56,55,54,54,53,52,51,51,50,49,49,48,47,46,46,45,45,45,44,43,42,42,41,40,40,39,38,37,37,36,36,36,35,34,33,33,32,31,31,31,30,29,29,
157,157,156,155,155,155,154,153,153,152,151,150,150,149,149,149,148,147,146,146,145,144,144,143,142,141,141,140,139,139,138,137,136,136,135,134,134,133,132,131,131,130,130,130,129,128,127,127,126,125,125,124,123,122,122,121,120,120,119,118,117,117,116,115,115,114,113,112,112,111,109,109,108,107,106,106,105,104,104,103,102,101,101,100,99,99,98,97,96,96,95,94,94,93,92,91,91,90,89,89,88,87,86,86,85,84,84,83,82,81,81,80,79,79,78,77,76,76,75,74,74,73,72,71,71,70,69,69,68,67,66,66,65,64,64,63,62,61,61,60,59,59,58,57,56,56,55,54,54,53,52,51,51,50,49,49,48,47,46,46,45,45,45,44,43,42,42,41,40,40,39,38,37,37,36,36,36,35,34,33,33,32,31,31,31,30,29,29,
157,157,156,155,155,155,154,153,153,152,151,150,150,149,149,149,148,147,146,146,145,144,144,143,142,141,141,140,139,139,138,137,136,136,135,134,134,133,132,131,131,130,130,130,129,128,127,127,126,125,125,124,123,122,122,121,120,120,119,118,117,117,116,115,115,114,113,112,112,111,109,109,108,107,106,106,105,104,104,103,102,101,101,100,99,99,98,97,96,96,95,94,94,93,92,91,91,90,89,89,88,87,86,86,85,84,84,83,82,81,81,80,79,79,78,77,76,76,75,74,74,73,72,71,71,70,69,69,68,67,66,66,65,64,64,63,62,61,61,60,59,59,58,57,56,56,55,54,54,53,52,51,51,50,49,49,48,47,46,46,45,45,45,44,43,42,42,41,40,40,39,38,37,37,36,36,36,35,34,33,33,32,31,31,31,30,29,29,
157,157,156,155,155,155,154,153,153,152,151,150,150,149,149,149,148,147,146,146,145,144,144,143,142,141,141,140,139,139,138,137,136,136,135,134,134,133,132,131,131,130,130,130,129,128,127,127,126,125,125,124,123,122,122,121,120,120,119,118,117,117,116,115,115,114,113,112,112,111,109,109,108,107,106,106,105,104,104,103,102,101,101,100,99,99,98,97,96,96,95,94,94,93,92,91,91,90,89,89,88,87,86,86,85,84,84,83,82,81,81,80,79,79,78,77,76,76,75,74,74,73,72,71,71,70,69,69,68,67,66,66,65,64,64,63,62,61,61,60,59,59,58,57,56,56,55,54,54,53,52,51,51,50,49,49,48,47,46,46,45,45,45,44,43,42,42,41,40,40,39,38,37,37,36,36,36,35,34,33,33,32,31,31,31,30,29,29,
157,157,156,155,155,155,154,153,153,152,151,150,150,149,149,149,148,147,146,146,145,144,144,143,142,141,141,140,139,139,138,137,136,136,135,134,134,133,132,131,131,130,130,130,129,128,127,127,126,125,125,124,123,122,122,121,120,120,119,118,117,117,116,115,115,114,113,112,112,111,109,109,108,107,106,106,105,104,104,103,102,101,101,100,99,99,98,97,96,96,95,94,94,93,92,91,91,90,89,89,88,87,86,86,85,84,84,83,82,81,81,80,79,79,78,77,76,76,75,74,74,73,72,71,71,70,69,69,68,67,66,66,65,64,64,63,62,61,61,60,59,59,58,57,56,56,55,54,54,53,52,51,51,50,49,49,48,47,46,46,45,45,45,44,43,42,42,41,40,40,39,38,37,37,36,36,36,35,34,33,33,32,31,31,31,30,29,29,
157,157,156,155,155,155,154,153,153,152,151,150,150,149,149,149,148,147,146,146,145,144,144,143,142,141,141,140,139,139,138,137,136,136,135,134,134,133,132,131,131,130,130,130,129,128,127,127,126,125,125,124,123,122,122,121,120,120,119,118,117,117,116,115,115,114,113,112,112,111,109,109,108,107,106,106,105,104,104,103,102,101,101,100,99,99,98,97,96,96,95,94,94,93,92,91,91,90,89,89,88,87,86,86,85,84,84,83,82,81,81,80,79,79,78,77,76,76,75,74,74,73,72,71,71,70,69,69,68,67,66,66,65,64,64,63,62,61,61,60,59,59,58,57,56,56,55,54,54,53,52,51,51,50,49,49,48,47,46,46,45,45,45,44,43,42,42,41,40,40,39,38,37,37,36,36,36,35,34,33,33,32,31,31,31,30,29,29,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
162,161,161,160,160,159,159,158,157,156,156,156,155,154,153,153,152,151,150,149,149,149,148,147,147,146,145,144,143,143,142,141,140,140,139,138,137,136,136,135,134,133,133,132,131,131,130,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,117,116,116,115,114,113,113,112,111,109,108,108,107,106,105,105,104,103,102,101,101,100,99,98,98,97,96,95,94,94,93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,81,80,80,79,78,77,77,76,75,74,73,73,72,71,70,70,69,68,67,66,66,65,64,63,63,62,61,60,59,59,58,57,56,56,55,54,53,52,52,51,50,49,49,48,47,46,45,45,44,44,43,43,42,41,40,39,39,38,37,36,36,35,35,34,33,33,32,31,30,30,30,29,28,27,27,27,26,25,25,24,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
166,165,165,165,164,163,163,162,161,161,160,160,159,158,157,156,156,156,155,154,153,152,152,151,150,150,149,148,148,147,146,145,144,143,143,142,141,140,139,138,137,137,136,135,134,133,132,132,132,131,130,129,128,128,127,126,125,124,123,122,122,121,120,119,118,117,117,116,115,114,113,112,112,111,110,108,107,106,106,105,104,103,102,101,100,100,99,98,97,96,95,95,94,93,92,91,90,90,89,88,87,86,85,85,84,83,82,81,80,79,79,78,77,76,75,74,74,73,72,71,70,69,69,68,67,66,65,64,64,63,62,61,60,59,58,58,57,56,55,54,53,53,52,51,50,49,48,48,47,46,45,44,43,43,43,42,41,40,39,38,38,37,36,35,35,34,34,33,32,31,30,30,30,29,28,27,27,26,25,25,24,24,23,22,22,22,21,20,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
170,169,169,168,168,167,167,166,166,165,164,163,163,162,161,160,160,160,159,158,157,156,156,155,154,153,152,152,151,150,150,149,148,147,146,145,144,144,143,142,141,140,139,138,137,136,135,135,134,133,133,132,131,130,129,128,127,126,126,125,124,123,122,121,120,119,118,117,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,97,96,95,94,93,92,91,90,89,88,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,69,68,67,66,65,64,63,62,61,60,60,59,58,57,56,55,54,53,52,51,50,50,49,48,47,46,45,44,43,43,42,42,41,40,39,38,37,36,35,34,34,34,33,32,31,30,30,29,28,27,26,26,26,25,24,24,23,22,22,21,20,20,20,19,18,18,17,17,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
173,173,172,172,171,171,170,169,169,168,168,167,166,166,165,164,164,163,162,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,136,135,134,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,108,107,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,49,48,47,46,45,44,43,42,42,41,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,24,23,23,22,21,21,20,20,19,18,18,17,17,16,16,15,15,14,14,
0,0,175,175,174,174,173,173,172,172,171,170,170,169,168,168,167,166,166,165,164,164,163,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,144,143,142,141,140,139,138,137,136,135,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,42,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,21,21,20,19,19,18,18,17,16,16,15,14,14,13,13,13,12,12,0,0,
0,0,175,175,174,174,173,173,172,172,171,170,170,169,168,168,167,166,166,165,164,164,163,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,144,143,142,141,140,139,138,137,136,135,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,42,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,21,21,20,19,19,18,18,17,16,16,15,14,14,13,13,13,12,12,0,0,
0,0,175,175,174,174,173,173,172,172,171,170,170,169,168,168,167,166,166,165,164,164,163,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,144,143,142,141,140,139,138,137,136,135,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,42,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,21,21,20,19,19,18,18,17,16,16,15,14,14,13,13,13,12,12,0,0,
0,0,175,175,174,174,173,173,172,172,171,170,170,169,168,168,167,166,166,165,164,164,163,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,144,143,142,141,140,139,138,137,136,135,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,42,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,21,21,20,19,19,18,18,17,16,16,15,14,14,13,13,13,12,12,0,0,
0,0,175,175,174,174,173,173,172,172,171,170,170,169,168,168,167,166,166,165,164,164,163,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,144,143,142,141,140,139,138,137,136,135,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,42,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,21,21,20,19,19,18,18,17,16,16,15,14,14,13,13,13,12,12,0,0,
0,0,175,175,174,174,173,173,172,172,171,170,170,169,168,168,167,166,166,165,164,164,163,162,161,161,160,159,158,157,157,156,155,154,153,152,151,151,150,149,148,147,146,144,143,142,141,140,139,138,137,136,135,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,42,40,39,38,37,36,35,34,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,21,21,20,19,19,18,18,17,16,16,15,14,14,13,13,13,12,12,0,0,
0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,170,170,169,168,168,167,167,166,164,164,163,162,161,161,160,159,158,157,157,155,154,153,152,151,151,150,149,148,147,145,144,143,142,141,140,139,138,137,136,136,134,133,132,131,130,129,128,127,126,125,124,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,97,96,95,94,93,92,91,90,89,88,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,62,61,60,59,58,57,56,55,54,53,52,50,49,48,47,46,45,44,43,42,42,41,39,38,37,36,35,34,33,33,32,31,29,29,28,27,26,25,25,24,23,23,22,21,20,19,19,18,18,17,16,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,170,170,169,168,168,167,167,166,164,164,163,162,161,161,160,159,158,157,157,155,154,153,152,151,151,150,149,148,147,145,144,143,142,141,140,139,138,137,136,136,134,133,132,131,130,129,128,127,126,125,124,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,97,96,95,94,93,92,91,90,89,88,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,62,61,60,59,58,57,56,55,54,53,52,50,49,48,47,46,45,44,43,42,42,41,39,38,37,36,35,34,33,33,32,31,29,29,28,27,26,25,25,24,23,23,22,21,20,19,19,18,18,17,16,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,170,170,169,168,168,167,167,166,164,164,163,162,161,161,160,159,158,157,157,155,154,153,152,151,151,150,149,148,147,145,144,143,142,141,140,139,138,137,136,136,134,133,132,131,130,129,128,127,126,125,124,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,97,96,95,94,93,92,91,90,89,88,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,62,61,60,59,58,57,56,55,54,53,52,50,49,48,47,46,45,44,43,42,42,41,39,38,37,36,35,34,33,33,32,31,29,29,28,27,26,25,25,24,23,23,22,21,20,19,19,18,18,17,16,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,170,170,169,168,168,167,167,166,164,164,163,162,161,161,160,159,158,157,157,155,154,153,152,151,151,150,149,148,147,145,144,143,142,141,140,139,138,137,136,136,134,133,132,131,130,129,128,127,126,125,124,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,97,96,95,94,93,92,91,90,89,88,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,62,61,60,59,58,57,56,55,54,53,52,50,49,48,47,46,45,44,43,42,42,41,39,38,37,36,35,34,33,33,32,31,29,29,28,27,26,25,25,24,23,23,22,21,20,19,19,18,18,17,16,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,170,170,169,168,168,167,167,166,164,164,163,162,161,161,160,159,158,157,157,155,154,153,152,151,151,150,149,148,147,145,144,143,142,141,140,139,138,137,136,136,134,133,132,131,130,129,128,127,126,125,124,122,121,120,119,118,117,116,115,114,113,112,110,109,107,106,105,104,103,102,101,100,99,97,96,95,94,93,92,91,90,89,88,86,85,84,83,82,81,80,79,78,77,76,74,73,72,71,70,69,68,67,66,65,64,62,61,60,59,58,57,56,55,54,53,52,50,49,48,47,46,45,44,43,42,42,41,39,38,37,36,35,34,33,33,32,31,29,29,28,27,26,25,25,24,23,23,22,21,20,19,19,18,18,17,16,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,173,172,172,170,170,169,169,168,167,167,165,165,164,163,162,162,160,159,158,158,157,156,154,153,152,152,151,150,149,147,146,145,144,143,142,140,139,138,137,136,136,135,133,132,131,130,129,128,126,125,124,123,122,121,120,118,117,116,115,114,113,111,110,109,107,106,105,103,102,101,100,99,98,97,95,94,93,92,91,90,88,87,86,85,84,83,82,80,79,78,77,76,75,73,72,71,70,69,68,66,65,64,63,62,61,60,58,57,56,55,54,53,51,50,49,48,47,46,45,43,42,41,41,40,39,37,36,35,34,33,33,32,30,29,28,28,27,26,25,24,23,23,22,21,20,19,19,18,17,17,16,15,15,14,14,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,173,172,172,170,170,169,169,168,167,167,165,165,164,163,162,162,160,159,158,158,157,156,154,153,152,152,151,150,149,147,146,145,144,143,142,140,139,138,137,136,136,135,133,132,131,130,129,128,126,125,124,123,122,121,120,118,117,116,115,114,113,111,110,109,107,106,105,103,102,101,100,99,98,97,95,94,93,92,91,90,88,87,86,85,84,83,82,80,79,78,77,76,75,73,72,71,70,69,68,66,65,64,63,62,61,60,58,57,56,55,54,53,51,50,49,48,47,46,45,43,42,41,41,40,39,37,36,35,34,33,33,32,30,29,28,28,27,26,25,24,23,23,22,21,20,19,19,18,17,17,16,15,15,14,14,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,173,172,172,170,170,169,169,168,167,167,165,165,164,163,162,162,160,159,158,158,157,156,154,153,152,152,151,150,149,147,146,145,144,143,142,140,139,138,137,136,136,135,133,132,131,130,129,128,126,125,124,123,122,121,120,118,117,116,115,114,113,111,110,109,107,106,105,103,102,101,100,99,98,97,95,94,93,92,91,90,88,87,86,85,84,83,82,80,79,78,77,76,75,73,72,71,70,69,68,66,65,64,63,62,61,60,58,57,56,55,54,53,51,50,49,48,47,46,45,43,42,41,41,40,39,37,36,35,34,33,33,32,30,29,28,28,27,26,25,24,23,23,22,21,20,19,19,18,17,17,16,15,15,14,14,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,173,172,172,170,170,169,169,168,167,167,165,165,164,163,162,162,160,159,158,158,157,156,154,153,152,152,151,150,149,147,146,145,144,143,142,140,139,138,137,136,136,135,133,132,131,130,129,128,126,125,124,123,122,121,120,118,117,116,115,114,113,111,110,109,107,106,105,103,102,101,100,99,98,97,95,94,93,92,91,90,88,87,86,85,84,83,82,80,79,78,77,76,75,73,72,71,70,69,68,66,65,64,63,62,61,60,58,57,56,55,54,53,51,50,49,48,47,46,45,43,42,41,41,40,39,37,36,35,34,33,33,32,30,29,28,28,27,26,25,24,23,23,22,21,20,19,19,18,17,17,16,15,15,14,14,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,173,173,172,171,171,170,169,169,167,167,166,165,164,163,162,162,161,159,158,158,157,155,154,153,152,152,150,149,148,147,146,144,143,142,141,139,138,137,137,136,134,133,132,131,129,128,127,126,125,123,122,121,120,118,117,116,115,114,112,111,110,109,107,105,104,103,102,100,99,98,97,96,94,93,92,91,89,88,87,86,85,83,82,81,80,78,77,76,75,74,72,71,70,69,68,66,65,64,63,61,60,59,58,57,55,54,53,52,50,49,48,47,46,44,43,42,41,40,39,38,37,36,34,33,33,32,31,29,28,28,27,25,25,24,23,22,21,20,20,19,18,17,17,16,16,15,14,14,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,173,173,172,171,171,170,169,169,167,167,166,165,164,163,162,162,161,159,158,158,157,155,154,153,152,152,150,149,148,147,146,144,143,142,141,139,138,137,137,136,134,133,132,131,129,128,127,126,125,123,122,121,120,118,117,116,115,114,112,111,110,109,107,105,104,103,102,100,99,98,97,96,94,93,92,91,89,88,87,86,85,83,82,81,80,78,77,76,75,74,72,71,70,69,68,66,65,64,63,61,60,59,58,57,55,54,53,52,50,49,48,47,46,44,43,42,41,40,39,38,37,36,34,33,33,32,31,29,28,28,27,25,25,24,23,22,21,20,20,19,18,17,17,16,16,15,14,14,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,173,173,172,171,171,170,169,169,167,167,166,165,164,163,162,162,161,159,158,158,157,155,154,153,152,152,150,149,148,147,146,144,143,142,141,139,138,137,137,136,134,133,132,131,129,128,127,126,125,123,122,121,120,118,117,116,115,114,112,111,110,109,107,105,104,103,102,100,99,98,97,96,94,93,92,91,89,88,87,86,85,83,82,81,80,78,77,76,75,74,72,71,70,69,68,66,65,64,63,61,60,59,58,57,55,54,53,52,50,49,48,47,46,44,43,42,41,40,39,38,37,36,34,33,33,32,31,29,28,28,27,25,25,24,23,22,21,20,20,19,18,17,17,16,16,15,14,14,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,173,173,172,171,171,170,169,169,167,167,166,165,164,163,162,162,161,159,158,158,157,155,154,153,152,152,150,149,148,147,146,144,143,142,141,139,138,137,137,136,134,133,132,131,129,128,127,126,125,123,122,121,120,118,117,116,115,114,112,111,110,109,107,105,104,103,102,100,99,98,97,96,94,93,92,91,89,88,87,86,85,83,82,81,80,78,77,76,75,74,72,71,70,69,68,66,65,64,63,61,60,59,58,57,55,54,53,52,50,49,48,47,46,44,43,42,41,40,39,38,37,36,34,33,33,32,31,29,28,28,27,25,25,24,23,22,21,20,20,19,18,17,17,16,16,15,14,14,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,172,172,171,170,169,169,168,167,166,165,164,163,162,162,160,159,158,158,156,155,154,153,152,151,150,148,147,146,144,143,142,141,139,138,138,136,135,134,133,131,130,129,127,126,125,124,122,121,120,118,117,116,115,113,112,111,110,107,106,105,103,102,101,100,98,97,96,94,93,92,91,89,88,87,85,84,83,82,80,79,78,76,75,74,73,71,70,69,68,66,65,64,62,61,60,59,57,56,55,53,52,51,50,48,47,46,44,43,42,41,40,39,38,36,35,34,33,32,31,30,28,28,27,26,24,24,23,22,21,20,20,18,18,17,17,16,15,14,13,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,172,172,171,170,169,169,168,167,166,165,164,163,162,162,160,159,158,158,156,155,154,153,152,151,150,148,147,146,144,143,142,141,139,138,138,136,135,134,133,131,130,129,127,126,125,124,122,121,120,118,117,116,115,113,112,111,110,107,106,105,103,102,101,100,98,97,96,94,93,92,91,89,88,87,85,84,83,82,80,79,78,76,75,74,73,71,70,69,68,66,65,64,62,61,60,59,57,56,55,53,52,51,50,48,47,46,44,43,42,41,40,39,38,36,35,34,33,32,31,30,28,28,27,26,24,24,23,22,21,20,20,18,18,17,17,16,15,14,13,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,172,172,171,170,169,169,168,167,166,165,164,163,162,162,160,159,158,158,156,155,154,153,152,151,150,148,147,146,144,143,142,141,139,138,138,136,135,134,133,131,130,129,127,126,125,124,122,121,120,118,117,116,115,113,112,111,110,107,106,105,103,102,101,100,98,97,96,94,93,92,91,89,88,87,85,84,83,82,80,79,78,76,75,74,73,71,70,69,68,66,65,64,62,61,60,59,57,56,55,53,52,51,50,48,47,46,44,43,42,41,40,39,38,36,35,34,33,32,31,30,28,28,27,26,24,24,23,22,21,20,20,18,18,17,17,16,15,14,13,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,174,174,173,172,172,171,170,169,169,168,167,166,165,164,163,162,162,160,159,158,158,156,155,154,153,152,151,150,148,147,146,144,143,142,141,139,138,138,136,135,134,133,131,130,129,127,126,125,124,122,121,120,118,117,116,115,113,112,111,110,107,106,105,103,102,101,100,98,97,96,94,93,92,91,89,88,87,85,84,83,82,80,79,78,76,75,74,73,71,70,69,68,66,65,64,62,61,60,59,57,56,55,53,52,51,50,48,47,46,44,43,42,41,40,39,38,36,35,34,33,32,31,30,28,28,27,26,24,24,23,22,21,20,20,18,18,17,17,16,15,14,13,13,13,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,169,169,168,167,166,165,164,163,162,161,160,159,158,157,155,154,153,152,151,150,148,147,146,144,143,142,140,139,138,137,136,135,133,132,130,129,128,126,125,124,122,121,120,118,117,116,114,113,112,110,109,107,105,104,103,101,100,99,97,96,95,93,92,90,89,88,86,85,84,82,81,80,78,77,76,74,73,72,70,69,68,66,65,64,62,61,60,58,57,56,54,53,51,50,49,47,46,45,43,42,41,40,39,38,36,35,34,32,32,31,29,28,27,26,25,24,23,22,22,20,20,18,18,17,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,169,169,168,167,166,165,164,163,162,161,160,159,158,157,155,154,153,152,151,150,148,147,146,144,143,142,140,139,138,137,136,135,133,132,130,129,128,126,125,124,122,121,120,118,117,116,114,113,112,110,109,107,105,104,103,101,100,99,97,96,95,93,92,90,89,88,86,85,84,82,81,80,78,77,76,74,73,72,70,69,68,66,65,64,62,61,60,58,57,56,54,53,51,50,49,47,46,45,43,42,41,40,39,38,36,35,34,32,32,31,29,28,27,26,25,24,23,22,22,20,20,18,18,17,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,175,175,174,174,173,172,171,171,169,169,168,167,166,165,164,163,162,161,160,159,158,157,155,154,153,152,151,150,148,147,146,144,143,142,140,139,138,137,136,135,133,132,130,129,128,126,125,124,122,121,120,118,117,116,114,113,112,110,109,107,105,104,103,101,100,99,97,96,95,93,92,90,89,88,86,85,84,82,81,80,78,77,76,74,73,72,70,69,68,66,65,64,62,61,60,58,57,56,54,53,51,50,49,47,46,45,43,42,41,40,39,38,36,35,34,32,32,31,29,28,27,26,25,24,23,22,22,20,20,18,18,17,16,15,15,14,13,13,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,174,173,172,171,170,170,168,168,167,166,165,163,163,162,160,159,158,157,156,154,153,152,151,150,148,147,145,144,142,141,140,139,138,136,135,134,132,131,129,128,127,125,124,122,121,120,118,117,115,114,113,111,110,108,106,104,103,102,100,99,97,96,95,93,92,90,89,88,86,85,83,82,81,79,78,76,75,73,72,71,69,68,66,65,64,62,61,59,58,57,55,54,52,51,50,48,47,45,44,43,41,40,39,38,36,35,34,32,32,30,29,28,27,26,24,24,23,22,21,20,19,18,17,16,15,15,14,13,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,174,173,172,171,170,170,168,168,167,166,165,163,163,162,160,159,158,157,156,154,153,152,151,150,148,147,145,144,142,141,140,139,138,136,135,134,132,131,129,128,127,125,124,122,121,120,118,117,115,114,113,111,110,108,106,104,103,102,100,99,97,96,95,93,92,90,89,88,86,85,83,82,81,79,78,76,75,73,72,71,69,68,66,65,64,62,61,59,58,57,55,54,52,51,50,48,47,45,44,43,41,40,39,38,36,35,34,32,32,30,29,28,27,26,24,24,23,22,21,20,19,18,17,16,15,15,14,13,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,174,173,172,171,170,170,168,168,167,166,165,163,163,162,160,159,158,157,156,154,153,152,151,150,148,147,145,144,142,141,140,139,138,136,135,134,132,131,129,128,127,125,124,122,121,120,118,117,115,114,113,111,110,108,106,104,103,102,100,99,97,96,95,93,92,90,89,88,86,85,83,82,81,79,78,76,75,73,72,71,69,68,66,65,64,62,61,59,58,57,55,54,52,51,50,48,47,45,44,43,41,40,39,38,36,35,34,32,32,30,29,28,27,26,24,24,23,22,21,20,19,18,17,16,15,15,14,13,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,174,173,172,171,170,170,168,168,167,166,165,163,163,162,160,159,158,157,156,154,153,152,151,150,148,147,145,144,142,141,140,139,138,136,135,134,132,131,129,128,127,125,124,122,121,120,118,117,115,114,113,111,110,108,106,104,103,102,100,99,97,96,95,93,92,90,89,88,86,85,83,82,81,79,78,76,75,73,72,71,69,68,66,65,64,62,61,59,58,57,55,54,52,51,50,48,47,45,44,43,41,40,39,38,36,35,34,32,32,30,29,28,27,26,24,24,23,22,21,20,19,18,17,16,15,15,14,13,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,174,173,172,171,170,169,168,167,166,165,164,163,162,160,159,158,157,156,154,154,152,151,149,148,146,145,143,142,140,139,138,137,135,134,132,131,130,128,127,125,124,122,121,119,118,116,115,113,112,110,109,106,105,104,102,101,99,98,96,95,93,92,90,89,87,86,84,83,81,80,79,77,76,74,73,71,70,68,67,65,64,62,61,59,58,56,55,54,52,51,49,48,46,45,43,42,40,39,38,37,35,34,32,31,30,29,28,27,26,24,24,22,21,20,19,18,18,16,16,15,14,13,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,174,173,172,171,170,169,168,167,166,165,164,163,162,160,159,158,157,156,154,154,152,151,149,148,146,145,143,142,140,139,138,137,135,134,132,131,130,128,127,125,124,122,121,119,118,116,115,113,112,110,109,106,105,104,102,101,99,98,96,95,93,92,90,89,87,86,84,83,81,80,79,77,76,74,73,71,70,68,67,65,64,62,61,59,58,56,55,54,52,51,49,48,46,45,43,42,40,39,38,37,35,34,32,31,30,29,28,27,26,24,24,22,21,20,19,18,18,16,16,15,14,13,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,175,174,173,172,172,170,170,168,168,166,165,164,163,162,160,160,158,157,155,154,153,152,150,149,147,145,144,142,141,140,139,137,136,134,133,131,130,128,126,125,123,122,120,119,117,116,114,113,111,110,108,106,104,102,101,99,98,96,95,93,92,90,89,87,86,84,83,81,79,78,76,75,73,72,70,69,67,66,64,63,61,60,58,56,55,53,52,50,49,47,46,44,43,41,40,39,37,36,34,33,31,31,29,28,27,26,24,24,22,21,20,19,18,17,16,15,15,14,13,12,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,175,174,173,172,172,170,170,168,168,166,165,164,163,162,160,160,158,157,155,154,153,152,150,149,147,145,144,142,141,140,139,137,136,134,133,131,130,128,126,125,123,122,120,119,117,116,114,113,111,110,108,106,104,102,101,99,98,96,95,93,92,90,89,87,86,84,83,81,79,78,76,75,73,72,70,69,67,66,64,63,61,60,58,56,55,53,52,50,49,47,46,44,43,41,40,39,37,36,34,33,31,31,29,28,27,26,24,24,22,21,20,19,18,17,16,15,15,14,13,12,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,175,174,173,172,172,170,170,168,168,166,165,164,163,162,160,160,158,157,155,154,153,152,150,149,147,145,144,142,141,140,139,137,136,134,133,131,130,128,126,125,123,122,120,119,117,116,114,113,111,110,108,106,104,102,101,99,98,96,95,93,92,90,89,87,86,84,83,81,79,78,76,75,73,72,70,69,67,66,64,63,61,60,58,56,55,53,52,50,49,47,46,44,43,41,40,39,37,36,34,33,31,31,29,28,27,26,24,24,22,21,20,19,18,17,16,15,15,14,13,12,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,173,172,170,170,168,168,166,165,164,163,162,160,159,158,156,155,154,152,151,149,148,146,144,143,141,140,139,137,136,134,133,131,129,128,126,125,123,121,120,118,117,115,113,112,110,109,106,104,103,101,100,98,96,95,93,92,90,89,87,85,84,82,81,79,77,76,74,73,71,69,68,66,65,63,61,60,58,57,55,53,52,50,49,47,45,44,42,41,39,38,37,35,34,32,31,30,28,27,26,24,23,22,21,20,19,18,17,16,15,14,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,173,172,170,170,168,168,166,165,164,163,162,160,159,158,156,155,154,152,151,149,148,146,144,143,141,140,139,137,136,134,133,131,129,128,126,125,123,121,120,118,117,115,113,112,110,109,106,104,103,101,100,98,96,95,93,92,90,89,87,85,84,82,81,79,77,76,74,73,71,69,68,66,65,63,61,60,58,57,55,53,52,50,49,47,45,44,42,41,39,38,37,35,34,32,31,30,28,27,26,24,23,22,21,20,19,18,17,16,15,14,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,173,173,172,170,170,169,167,166,165,164,163,161,160,159,157,155,154,153,151,150,148,146,145,143,141,141,139,138,136,134,133,131,129,128,126,124,123,121,119,118,116,114,113,111,109,108,105,103,102,100,98,97,95,93,92,90,88,87,85,83,82,80,78,77,75,73,72,70,68,67,65,63,62,60,58,57,55,53,52,50,48,47,45,44,42,40,39,38,36,35,33,31,31,29,27,26,25,23,23,21,20,19,18,17,16,15,14,13,12,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,173,173,172,170,170,169,167,166,165,164,163,161,160,159,157,155,154,153,151,150,148,146,145,143,141,141,139,138,136,134,133,131,129,128,126,124,123,121,119,118,116,114,113,111,109,108,105,103,102,100,98,97,95,93,92,90,88,87,85,83,82,80,78,77,75,73,72,70,68,67,65,63,62,60,58,57,55,53,52,50,48,47,45,44,42,40,39,38,36,35,33,31,31,29,27,26,25,23,23,21,20,19,18,17,16,15,14,13,12,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,173,173,172,170,170,169,167,166,165,164,163,161,160,159,157,155,154,153,151,150,148,146,145,143,141,141,139,138,136,134,133,131,129,128,126,124,123,121,119,118,116,114,113,111,109,108,105,103,102,100,98,97,95,93,92,90,88,87,85,83,82,80,78,77,75,73,72,70,68,67,65,63,62,60,58,57,55,53,52,50,48,47,45,44,42,40,39,38,36,35,33,31,31,29,27,26,25,23,23,21,20,19,18,17,16,15,14,13,12,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,173,173,172,171,169,169,167,166,164,164,162,160,160,158,156,155,154,152,150,149,147,145,143,142,141,139,137,136,134,132,131,129,127,125,124,122,120,118,117,115,113,112,110,108,105,104,102,100,99,97,95,93,92,90,88,86,85,83,81,80,78,76,74,73,71,69,68,66,64,62,61,59,57,55,54,52,50,49,47,45,43,42,40,38,37,36,34,32,31,30,28,26,26,24,23,22,21,19,18,17,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,173,173,172,171,169,169,167,166,164,164,162,160,160,158,156,155,154,152,150,149,147,145,143,142,141,139,137,136,134,132,131,129,127,125,124,122,120,118,117,115,113,112,110,108,105,104,102,100,99,97,95,93,92,90,88,86,85,83,81,80,78,76,74,73,71,69,68,66,64,62,61,59,57,55,54,52,50,49,47,45,43,42,40,38,37,36,34,32,31,30,28,26,26,24,23,22,21,19,18,17,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,172,171,171,169,168,167,165,164,163,161,160,159,157,155,154,152,151,149,147,145,143,142,141,139,137,135,134,132,130,128,127,125,123,121,119,118,116,114,112,110,109,106,104,102,101,99,97,95,93,92,90,88,86,84,83,81,79,77,76,74,72,70,68,67,65,63,61,59,58,56,54,52,51,49,47,45,43,42,40,38,37,35,34,32,30,29,27,26,25,23,22,21,20,18,17,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,172,171,170,169,167,166,164,164,162,161,159,157,155,154,153,151,149,147,145,143,142,141,139,137,135,133,131,130,128,126,124,122,120,118,117,115,113,111,109,106,105,103,101,99,97,95,93,92,90,88,86,84,82,80,79,77,75,73,71,69,68,66,64,62,60,58,56,55,53,51,49,47,45,43,42,40,38,37,35,33,32,30,29,27,26,24,23,22,20,19,18,17,15,14,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,172,171,170,169,167,166,164,164,162,161,159,157,155,154,153,151,149,147,145,143,142,141,139,137,135,133,131,130,128,126,124,122,120,118,117,115,113,111,109,106,105,103,101,99,97,95,93,92,90,88,86,84,82,80,79,77,75,73,71,69,68,66,64,62,60,58,56,55,53,51,49,47,45,43,42,40,38,37,35,33,32,30,29,27,26,24,23,22,20,19,18,17,15,14,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,172,171,169,168,167,165,164,162,161,159,157,156,155,153,151,149,147,145,143,142,140,138,137,135,133,131,129,127,125,123,121,119,117,115,114,112,110,108,105,103,101,99,97,95,93,92,90,88,86,84,82,80,78,76,74,72,71,69,67,65,63,61,59,57,55,53,51,49,48,46,44,42,40,38,37,35,33,31,30,29,27,26,24,22,21,20,18,17,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,172,171,169,168,167,165,164,162,161,159,157,156,155,153,151,149,147,145,143,142,140,138,137,135,133,131,129,127,125,123,121,119,117,115,114,112,110,108,105,103,101,99,97,95,93,92,90,88,86,84,82,80,78,76,74,72,71,69,67,65,63,61,59,57,55,53,51,49,48,46,44,42,40,38,37,35,33,31,30,29,27,26,24,22,21,20,18,17,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,173,172,171,170,169,167,166,165,163,161,160,158,156,155,153,151,149,147,145,143,142,140,138,136,134,132,130,128,126,124,122,120,118,116,114,112,110,108,105,103,101,99,97,95,93,92,90,88,86,84,82,80,78,76,74,72,70,68,66,64,62,60,58,56,54,52,50,48,46,44,42,40,38,37,35,33,31,30,28,26,25,23,22,20,19,18,16,16,15,14,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,171,170,169,167,166,165,163,161,160,158,156,155,153,151,149,147,144,143,141,139,137,135,133,131,129,127,125,123,121,119,117,115,113,111,109,107,104,102,100,98,96,94,91,89,87,85,83,81,79,77,75,73,71,69,67,65,63,61,59,57,55,53,51,49,47,45,43,41,38,37,35,33,31,30,28,26,25,23,22,20,19,18,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,173,171,170,169,167,166,165,163,161,160,158,156,155,153,151,149,147,144,143,141,139,137,135,133,131,129,127,125,123,121,119,117,115,113,111,109,107,104,102,100,98,96,94,91,89,87,85,83,81,79,77,75,73,71,69,67,65,63,61,59,57,55,53,51,49,47,45,43,41,38,37,35,33,31,30,28,26,25,23,22,20,19,18,16,15,14,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,174,173,172,171,169,168,166,165,163,161,160,158,156,155,152,150,148,146,144,143,141,139,137,134,132,130,128,126,124,122,120,118,116,113,111,109,107,104,102,100,98,96,94,91,89,87,85,83,81,79,77,75,73,70,68,66,64,62,60,58,56,54,52,49,47,45,43,41,39,37,36,34,31,29,28,26,25,23,22,20,19,18,16,15,14,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,174,173,172,171,170,168,166,165,163,161,160,158,156,154,152,150,148,146,143,142,140,138,136,134,131,129,127,125,123,121,118,116,114,112,110,108,104,102,100,98,96,94,91,89,87,85,83,81,78,76,74,72,70,68,65,63,61,59,57,55,52,50,48,46,44,42,39,37,36,34,32,30,28,26,25,23,22,20,18,17,16,15,14,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,174,173,172,171,170,168,166,165,163,161,160,158,156,154,152,150,148,146,143,142,140,138,136,134,131,129,127,125,123,121,118,116,114,112,110,108,104,102,100,98,96,94,91,89,87,85,83,81,78,76,74,72,70,68,65,63,61,59,57,55,52,50,48,46,44,42,39,37,36,34,32,30,28,26,25,23,22,20,18,17,16,15,14,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,176,175,174,172,171,170,168,166,165,163,162,159,157,156,154,152,149,147,145,143,141,139,137,135,132,130,128,126,124,121,119,117,115,112,110,108,106,103,100,98,96,94,91,89,87,85,82,80,78,76,74,71,69,67,65,62,60,58,56,54,51,49,47,45,42,40,38,37,34,32,30,29,27,25,23,22,20,18,17,16,15,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,174,172,171,170,168,166,165,163,161,159,157,156,153,151,149,146,144,143,140,138,136,134,131,129,127,124,122,120,118,115,113,111,108,106,103,101,98,96,94,91,89,87,84,82,80,78,75,73,71,68,66,64,62,59,57,55,52,50,48,46,43,41,39,37,35,33,30,29,27,25,23,22,20,18,17,16,15,13,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,174,172,171,170,168,166,165,162,161,159,156,155,153,150,148,145,144,142,139,137,135,132,130,128,125,123,121,118,116,114,111,109,106,103,101,98,96,94,91,89,87,84,82,80,77,75,72,70,68,65,63,61,58,56,54,51,49,47,44,42,40,37,36,33,31,29,27,25,24,22,20,19,17,16,14,13,12,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,177,175,174,172,171,169,168,166,164,162,160,158,156,154,152,149,147,144,143,141,138,136,133,131,129,126,124,121,119,116,114,112,109,107,104,101,99,96,94,91,89,86,84,82,79,77,74,72,70,67,65,62,60,57,55,53,50,48,45,43,41,38,37,34,32,29,28,26,24,22,20,19,17,16,14,13,12,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,177,175,174,172,171,169,168,165,164,162,160,157,156,153,151,148,146,144,142,139,137,134,132,129,127,125,122,120,117,115,112,110,107,105,102,100,96,94,91,89,86,84,81,79,76,74,71,69,66,64,61,59,57,54,52,49,47,44,42,39,37,35,33,30,29,26,25,22,21,19,17,16,14,13,12,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,173,172,170,169,167,165,163,161,159,157,155,152,150,147,145,143,141,138,135,133,130,128,125,123,120,118,115,113,110,107,105,102,100,97,95,91,89,86,84,81,79,76,73,71,68,66,63,61,58,56,53,51,48,45,43,40,38,36,34,31,29,27,25,23,21,19,17,16,14,13,12,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,173,172,170,168,166,165,162,161,158,156,154,151,149,146,144,142,139,137,134,131,129,126,123,121,118,116,113,110,108,105,103,100,97,95,92,89,86,83,81,78,76,73,70,68,65,63,60,57,55,52,49,47,44,42,39,37,35,32,30,28,25,24,22,20,18,16,15,13,12,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,173,172,170,168,166,164,162,160,157,155,153,150,147,145,143,140,138,135,132,130,127,124,122,119,116,114,111,108,106,103,100,98,95,92,88,86,83,80,78,75,72,70,67,64,62,59,56,54,51,48,46,43,40,38,36,33,31,29,26,25,22,20,19,17,15,14,12,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,174,173,171,169,167,166,163,161,158,157,154,151,149,146,144,141,139,136,133,130,128,125,122,119,117,114,111,109,106,103,100,98,95,92,89,86,83,80,77,75,72,69,67,64,61,58,56,53,50,47,45,42,39,37,35,32,29,28,25,23,21,19,17,16,14,13,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,173,172,170,168,166,163,162,159,157,154,151,148,145,144,141,138,135,132,129,126,124,121,118,115,112,109,106,104,101,98,95,92,89,85,82,80,77,74,71,68,65,62,60,57,54,51,48,45,42,40,37,35,32,29,27,25,23,21,19,17,15,13,12,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,173,171,169,167,165,162,160,157,155,152,149,147,144,142,139,136,133,130,127,124,121,118,115,112,110,107,104,101,98,95,92,89,86,82,79,76,74,71,68,65,62,59,56,53,50,47,44,41,38,37,34,31,29,26,24,22,19,17,16,14,12,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,174,172,170,168,166,164,162,159,157,154,151,148,145,143,140,137,134,131,128,125,122,119,116,113,110,107,104,101,98,95,92,89,86,82,79,76,73,70,67,64,61,58,55,52,49,46,43,40,37,35,32,29,27,25,22,20,18,16,14,13,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,174,172,170,168,166,164,162,158,156,153,150,147,144,142,139,136,132,129,126,123,120,117,114,111,108,104,101,98,95,92,89,86,82,78,75,72,69,66,63,60,57,54,50,47,44,41,38,36,33,30,28,25,22,20,18,16,14,13,11,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,176,175,172,170,168,166,163,161,158,156,152,149,146,144,140,137,134,131,127,124,121,118,115,111,108,105,102,98,95,92,89,85,81,78,75,71,68,65,62,59,55,52,49,46,42,39,37,34,30,28,25,23,20,18,16,15,12,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,177,175,173,172,169,167,165,162,159,156,154,150,147,144,141,138,135,131,128,125,122,118,115,112,108,105,102,98,95,92,89,85,81,78,74,71,68,64,61,58,55,51,48,45,41,38,36,32,30,27,25,22,20,18,15,13,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,173,171,169,167,164,161,158,156,152,149,146,143,140,136,133,129,126,123,119,116,112,109,105,102,99,95,92,88,85,81,77,74,70,67,63,60,57,53,50,46,43,39,37,34,30,28,25,22,20,18,16,14,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,173,171,168,166,163,161,157,155,151,148,144,141,138,134,131,127,124,120,117,113,109,106,102,99,95,92,88,85,80,77,73,69,66,62,59,55,52,48,45,41,38,35,31,29,26,23,20,18,16,14,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,173,170,168,165,162,160,156,153,150,146,142,139,136,132,128,125,121,117,114,110,106,103,99,95,92,88,84,80,76,72,69,65,61,58,54,50,47,43,40,36,33,30,26,24,21,18,17,14,12,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,175,173,171,168,165,162,159,155,152,149,145,141,138,134,130,126,123,119,115,111,107,103,99,95,92,88,84,79,75,71,67,63,60,56,52,48,44,41,37,34,31,27,24,21,19,16,14,13,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,174,172,169,166,163,160,157,154,150,146,142,139,135,131,127,123,119,115,111,107,103,99,95,92,88,84,79,75,71,67,63,59,55,51,47,43,40,36,32,29,26,23,20,18,15,13,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,176,174,171,169,166,163,160,156,153,149,145,141,137,133,129,125,121,117,112,108,104,100,96,91,87,83,78,74,69,65,61,57,53,49,44,41,37,33,30,26,23,20,18,16,13,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,173,171,168,165,162,158,155,152,147,143,138,135,131,126,122,118,113,109,104,100,96,91,87,83,77,73,68,64,60,55,51,47,43,39,34,31,28,24,21,19,16,14,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,175,172,170,167,164,161,157,153,150,145,140,136,132,128,123,119,114,109,105,100,96,91,87,81,77,72,67,63,58,54,49,46,41,36,33,29,26,22,20,17,15,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,174,172,170,167,163,160,156,152,148,143,138,134,130,125,120,115,110,106,101,96,91,86,80,76,71,66,61,56,52,48,43,38,34,31,27,23,20,17,15,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,174,171,169,166,162,158,154,150,146,141,136,131,126,121,116,111,106,101,96,91,86,80,75,70,65,60,55,50,45,40,36,32,28,24,21,18,16,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,173,173,170,167,164,160,156,152,147,143,138,132,127,123,117,112,107,101,96,91,86,79,74,69,63,59,54,48,43,39,34,30,26,22,20,17,14,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,172,172,169,166,163,159,154,150,145,140,135,129,123,119,113,108,102,96,91,85,79,74,68,63,57,51,46,41,36,32,28,24,21,18,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,171,171,168,165,161,157,153,148,143,137,132,126,120,114,109,103,97,90,84,78,72,66,60,54,49,43,38,34,29,26,22,19,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
uint8_t image_transformY[120 * 188] = { 83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,
83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,
83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,
83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,
83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,
83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,79,79,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
76,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,76,76,76,
0,0,75,75,75,75,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,75,75,75,75,75,75,0,0,
0,0,75,75,75,75,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,75,75,75,75,75,75,0,0,
0,0,75,75,75,75,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,75,75,75,75,75,75,0,0,
0,0,75,75,75,75,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,75,75,75,75,75,75,0,0,
0,0,75,75,75,75,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,75,75,75,75,75,75,0,0,
0,0,75,75,75,75,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,75,75,75,75,75,75,0,0,
0,0,0,0,0,0,0,74,74,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,74,74,74,74,74,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,74,74,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,74,74,74,74,74,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,74,74,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,74,74,74,74,74,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,74,74,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,74,74,74,74,74,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,74,74,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,74,74,74,74,74,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,73,73,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,73,73,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,73,73,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,77,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,73,73,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,71,71,71,71,71,71,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,71,71,71,71,71,71,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,71,71,71,71,71,71,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,70,70,71,71,71,71,71,71,71,71,71,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,71,71,70,70,70,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,70,70,71,71,71,71,71,71,71,71,71,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,71,71,70,70,70,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,70,70,71,71,71,71,71,71,71,71,71,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,71,71,70,70,70,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,70,70,71,71,71,71,71,71,71,71,71,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,72,72,72,72,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,71,71,70,70,70,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,69,69,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,69,69,69,69,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,69,69,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,71,71,71,71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,69,69,69,69,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,68,68,69,69,69,69,69,69,69,69,69,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,70,70,70,69,69,69,69,69,69,69,69,69,68,68,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,68,68,69,69,69,69,69,69,69,69,69,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,70,70,70,69,69,69,69,69,69,69,69,69,68,68,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,68,68,69,69,69,69,69,69,69,69,69,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,70,70,70,69,69,69,69,69,69,69,69,69,68,68,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,68,68,68,68,68,68,68,68,68,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,69,69,69,69,69,69,69,69,69,69,69,69,69,68,68,68,68,68,68,68,68,68,67,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,68,68,68,68,68,68,68,68,68,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,69,69,69,69,69,69,69,69,69,69,69,69,69,68,68,68,68,68,68,68,68,68,67,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,67,67,67,67,67,67,67,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,68,68,68,68,68,68,68,68,68,68,68,68,68,67,67,67,67,67,67,67,67,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,67,67,67,67,67,67,67,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,68,68,68,68,68,68,68,68,68,68,68,68,68,67,67,67,67,67,67,67,67,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,67,67,67,67,67,67,67,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,68,68,68,68,68,68,68,68,68,68,68,68,68,67,67,67,67,67,67,67,67,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,66,66,66,66,66,66,66,67,67,67,67,67,67,67,67,67,67,67,67,67,67,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,67,67,67,67,67,67,67,67,67,67,67,67,67,66,66,66,66,66,66,66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,66,66,66,66,66,66,66,67,67,67,67,67,67,67,67,67,67,67,67,67,67,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,67,67,67,67,67,67,67,67,67,67,67,67,67,66,66,66,66,66,66,66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,65,65,65,65,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,66,66,66,66,66,66,66,66,66,66,66,66,66,65,65,65,65,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,64,64,64,64,64,65,65,65,65,65,65,65,65,65,65,65,65,65,65,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,65,65,65,65,65,65,65,65,65,65,65,65,65,64,64,64,64,64,64,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,64,64,64,64,64,65,65,65,65,65,65,65,65,65,65,65,65,65,65,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,65,65,65,65,65,65,65,65,65,65,65,65,65,64,64,64,64,64,64,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,63,63,63,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,64,64,64,64,64,64,64,64,64,64,64,64,64,63,63,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,63,63,63,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,64,64,64,64,64,64,64,64,64,64,64,64,64,63,63,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,62,62,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,63,63,63,63,63,63,63,63,63,63,63,63,63,62,62,62,62,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,61,61,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,62,62,62,62,62,62,62,62,62,62,62,62,62,62,61,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,61,61,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,62,62,62,62,62,62,62,62,62,62,62,62,62,62,61,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,59,59,59,59,59,59,59,59,59,59,59,59,59,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,59,59,59,59,59,59,59,59,59,59,59,59,59,59,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,58,58,58,58,58,58,58,58,58,58,58,58,58,58,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,58,58,58,58,58,58,58,58,58,58,58,58,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,57,57,57,57,57,57,57,57,57,57,57,57,57,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,57,57,57,57,57,57,57,57,57,57,57,57,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,56,56,56,56,56,56,56,56,56,56,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,56,56,56,56,56,56,56,56,56,56,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,55,55,55,55,55,55,55,55,55,55,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,55,55,55,55,55,55,55,55,55,55,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,54,54,54,54,54,54,54,54,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,54,54,54,54,54,54,54,54,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,53,53,53,53,53,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,53,53,53,53,53,53,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,52,52,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,52,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,43,43,43,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,45,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,42,42,42,42,42,42,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,44,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,42,42,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,40,40,40,40,40,40,40,40,40,41,41,41,41,41,41,41,41,41,41,41,41,41,42,42,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,40,40,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,38,38,38,38,38,38,38,38,38,38,39,39,39,39,39,39,39,39,39,39,39,40,40,40,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,38,38,38,37,37,37,37,37,37,37,37,37,37,37,37,37,36,36,36,37,37,37,37,37,37,37,36,36,36,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,38,38,38,38,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,35,35,35,35,34,34,34,34,34,34,34,34,34,34,33,33,33,33,33,33,34,34,34,34,33,33,33,33,33,33,33,33,33,33,33,34,34,34,34,34,34,34,34,35,35,35,35,36,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,34,33,33,33,32,32,32,32,32,32,32,32,32,32,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,32,32,32,32,32,33,33,33,33,34,34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,31,31,30,30,30,29,29,29,29,29,29,29,29,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,30,30,30,31,31,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,28,28,27,27,27,26,26,26,26,26,26,26,26,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,27,27,27,28,28,29,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,26,25,25,24,24,24,23,23,23,23,23,23,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,24,24,24,25,25,26,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,22,22,21,21,20,20,19,19,19,19,19,19,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,20,20,21,21,22,23,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,19,18,17,17,16,16,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,16,16,17,17,18,18,19,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,17,15,15,14,13,13,12,12,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,12,12,13,13,14,15,16,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,13,12,10,10,9,8,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,6,6,6,6,6,7,8,8,9,10,11,12,13,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,7,6,5,4,3,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,4,5,6,8,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };


//阈值方案
int threPlan = 1;

uint16_t image_histGram[256] = { 0 };
float image_histPorprotion[256];

int ThreMax = 170, ThreMin = 65;
float image_threUpFix = 1.1, image_threDownFix = 0.90, image_threUpbB = 0, image_threDownB = 0;/*, image_threMiddleFix = 1.0*/;
int threOriginal = 255, threUp = 255, threDown = 255/*, threMiddle = 255*/;

uint8_t image_rushFlag = 0;
int image_enterGaragePara = 75;
int gray_sum[256], threshold_original, threshold_n, threshold_w, threshold_l;
float pixepro[256];

void image_Preprocess(void)
{
    switch (threPlan)
    {
    case 0:
    {
        //先逆透视
        uint8_t* myMap, * ptrTransX, * ptrTransY;
        for (uint8_t i = 0; i < 120; i++)
        {
            myMap = &IMG[i][0];
            ptrTransX = &image_transformX[i * 188];
            ptrTransY = &image_transformY[i * 188];
            for (uint8_t j = 0; j < 188; j++)
            {
                if (*ptrTransX == 0)
                {
                    *myMap = 5;
                }
                else
                {
                    *myMap = fullBuffer[(*ptrTransY) * 188 + (*ptrTransX)];
                }
                myMap++, ptrTransX++, ptrTransY++;
            }
        }
        threOriginal = image_Kittler();
        if (threOriginal > ThreMax)threOriginal = ThreMax;
        if (threOriginal < ThreMin)threOriginal = ThreMin;
        threUp = threOriginal * image_threUpFix+ image_threUpbB, threDown = threOriginal * image_threDownFix+ image_threDownB/*, threMiddle = threOriginal * image_threMiddleFix*/;
        printf("ThreUp:%d\n", threUp);
        printf("ThreDown:%d\n", threDown);
        //image_RemoveDistortion();
        image_Binarization();
        break;
    }
    case 1:
    {
        image_GetHistGram(image_histGram, 0, CAMERA_H-CUT_LINE);
        threOriginal = image_GetOtsuThre();
        if (threOriginal > ThreMax)threOriginal = ThreMax;
        if (threOriginal < ThreMin)threOriginal = ThreMin;
        threUp = threOriginal * image_threUpFix + image_threUpbB, threDown = threOriginal * image_threDownFix + image_threDownB;/*, threMiddle = threOriginal * image_threMiddleFix*/
        printf("ThreUp:%d\n", threUp);
        printf("ThreDown:%d\n", threDown);
        image_RemoveDistortion();
        break;
    }
    case 2:
    {
        image_GetHistGram(image_histGram, 0, CAMERA_H - CUT_LINE);
        threOriginal = image_Iteration();
        if (threOriginal > ThreMax)threOriginal = ThreMax;
        if (threOriginal < ThreMin)threOriginal = ThreMin;
        threUp = threOriginal * image_threUpFix, threDown = threOriginal * image_threDownFix/*, threMiddle = threOriginal * image_threMiddleFix*/;
        printf("ThreUp:%d\n", threUp);
        printf("ThreDown:%d\n", threDown);
        image_RemoveDistortion();
        break;
    }
    default:
        break;
    }
}

int image_Kittler(void)
{
    uint8_t* pLineAdd = NULL, * pNextLine = NULL, * pPreLine = NULL;
    int threShold = 0;
    uint8_t* mymap = &IMG[0][0];
    int FirGrads = 0,SecGrads = 0,Grads = 0, sumGrads = 0, sumGrayGrads = 0;
    for (uint8_t i = 1; i < 38; i++)
    {
        pLineAdd = mymap + i * CAMERA_W;
        pNextLine = mymap + (i + 1) * CAMERA_W;
        pPreLine = mymap + (i - 1) * CAMERA_W;
        for (uint8_t j = left_side[i]+1; j < right_side[i]-1; j++)
        {
            float YGrads = abs((int)pPreLine[j] - (int)pNextLine[j]);
            float XGrads = abs((int)pLineAdd[j - 1] - (int)pLineAdd[j + 1]);
            float FirTiltGrads = (abs((int)pPreLine[j + 1] - (int)pNextLine[j - 1]))/1.4;
            float SecTiltGrads = (abs((int)pPreLine[j - 1] - (int)pNextLine[j + 1]))/1.4;
            FirGrads = (XGrads > YGrads) ? XGrads : YGrads;
            SecGrads = (FirTiltGrads > SecTiltGrads) ? FirTiltGrads : SecTiltGrads;
            Grads = (FirGrads > SecGrads) ? FirGrads : SecGrads;
            sumGrads += Grads;
            sumGrayGrads += ((int)pLineAdd[j]) * Grads;
        }
    }
    for (uint8_t i = 38; i < CAMERA_H - 1; i++)
    {
        pLineAdd = mymap + i * CAMERA_W;
        pNextLine = mymap + (i + 1) * CAMERA_W;
        pPreLine = mymap + (i - 1) * CAMERA_W;
        for (uint8_t j = left_side[i] + 6; j < right_side[i] - 6; j++)
        {
            float YGrads = abs((int)pPreLine[j] - (int)pNextLine[j]);
            float XGrads = abs((int)pLineAdd[j - 1] - (int)pLineAdd[j + 1]);
            float FirTiltGrads = (abs((int)pPreLine[j + 1] - (int)pNextLine[j - 1])) / 1.4;
            float SecTiltGrads = (abs((int)pPreLine[j - 1] - (int)pNextLine[j + 1])) / 1.4;
            FirGrads = (XGrads > YGrads) ? XGrads : YGrads;
            SecGrads = (FirTiltGrads > SecTiltGrads) ? FirTiltGrads : SecTiltGrads;
            Grads = (FirGrads > SecGrads) ? FirGrads : SecGrads;
            sumGrads += Grads;
            sumGrayGrads += ((int)pLineAdd[j]) * Grads;
        }
    }
    threShold = sumGrayGrads / sumGrads;
    printf("threshold:%d\n", threShold);
    return threShold;
}

int image_GetOtsuThre(void)
{
    int thresholdOrigin = 0;
    uint16_t minValue = 0, maxValue = 255, * ptrHistGram;
    float forePorprotion = 0, backPorprotion = 0, foreAverage = 0, backAverage = 0, maxVariance = 0, tmpVariance = 0, * ptrHistPorprotion;
    float tmpBackAverage = 0, tmpForeAverage = 0;
    //测试
    /*uint16_t amount = 0;
    float porAmount = 0;
    for (uint16_t i = CUT_LINE; i < 256; i++)
    {
        amount += image_histGram[i];
        porAmount += image_histPorprotion[i];
    }
    printf("amount:%d\n", amount);
    printf("porAmount:%f\n", porAmount);*/

    ptrHistGram = &image_histGram[0];
    for (minValue = 0; (*ptrHistGram) == 0 && minValue < 256; minValue++, ptrHistGram++);
    ptrHistGram = &image_histGram[255];
    for (maxValue = 255; (*ptrHistGram) == 0 && maxValue > 0; maxValue--, ptrHistGram--);
    printf("maxValue:%d\n", maxValue);
    ptrHistPorprotion = &image_histPorprotion[minValue];
    for (uint16_t i = minValue; i <= maxValue; i++, ptrHistPorprotion++)
    {
        forePorprotion += (*ptrHistPorprotion);
        tmpForeAverage += (i * (*ptrHistPorprotion));
    }
    ptrHistPorprotion = &image_histPorprotion[minValue];
    for (uint16_t i = minValue; i <= maxValue; i++, ptrHistPorprotion++)
    {
        //背景
        backPorprotion += (*ptrHistPorprotion);
        tmpBackAverage += (i * (*ptrHistPorprotion));
        backAverage = tmpBackAverage / backPorprotion;
        //前景
        forePorprotion -= (*ptrHistPorprotion);
        tmpForeAverage -= (i * (*ptrHistPorprotion));
        foreAverage = tmpForeAverage / forePorprotion;
        //
        tmpVariance = backPorprotion * forePorprotion * (backAverage - foreAverage) * (backAverage - foreAverage);
        //printf("%d:tmpVariance %f\n",i,tmpVariance);
        if (tmpVariance > maxVariance)
        {
            maxVariance = tmpVariance;
            thresholdOrigin = i;
        }
    }
    printf("maxVariance:%f\n", maxVariance);
    printf("threshold origin:%d\n", thresholdOrigin);
    if (maxValue<175 && maxValue>thresholdOrigin && maxValue - thresholdOrigin > 80)
    {
        thresholdOrigin += 25;
    }
    else if(maxValue<175 && maxValue>thresholdOrigin && maxValue - thresholdOrigin > 70)
    {
        thresholdOrigin += 10;
    }
    return thresholdOrigin;
}



void image_RemoveDistortion(void)
{
    uint8_t* myMap, * ptrTransX, * ptrTransY;
    for (uint8_t i = 0; i < 15; i++)
    {
        myMap = &IMG[i][0];
        ptrTransX = &image_transformX[i * 188];
        ptrTransY = &image_transformY[i * 188];
        for (uint8_t j = 0; j < 188; j++)
        {
            if (*ptrTransX == 0)
            {
                *myMap = 5;
            }
            else if (fullBuffer[(*ptrTransY) * 188 + (*ptrTransX)] > threUp)
            {
                *myMap = 1;
            }
            else
            {
                *myMap = 0;
            }
            myMap++, ptrTransX++, ptrTransY++;
        }
    }
    for (uint8_t i = 15; i < 120; i++)
    {
        myMap = &IMG[i][0];
        ptrTransX = &image_transformX[i * 188];
        ptrTransY = &image_transformY[i * 188];
        for (uint8_t j = 0; j < 188; j++)
        {
            if (*ptrTransX == 0)
            {
                *myMap = 5;
            }
            else if (j <= left_side[i]+25 || j >= right_side[i]-25)//图像边缘偏黑
            {
                if (fullBuffer[(*ptrTransY) * 188 + (*ptrTransX)] > threDown)
                {
                    *myMap = 1;
                }
                else
                {
                    *myMap = 0;
                }
            }
            else
            {
                if (fullBuffer[(*ptrTransY) * 188 + (*ptrTransX)] > threUp)
                {
                    *myMap = 1;
                }
                else
                {
                    *myMap = 0;
                }
            }
            myMap++, ptrTransX++, ptrTransY++;
        }
    }
}
uint8_t staticCurThre = 40;
int image_Iteration(void)
{
    int lastThre = 120, curThre = staticCurThre;
    while (abs(lastThre - curThre) > 2)
    {
        uint32_t firAmount = 0,firAver = 0,secAmount = 0,secAver = 0;
        lastThre = curThre;
        //计算大于的均值
        for (uint16_t i = lastThre; i <= 255; i++)
        {
            firAver += image_histGram[i]*i;
            firAmount += image_histGram[i];
        }
        firAver /= firAmount;
        //计算小于的均值
        for (uint8_t i = 0; i <=lastThre; i++)
        {
            secAver += image_histGram[i] * i;
            secAmount += image_histGram[i];
        }
        secAver /= secAmount;
        curThre = (firAver + secAver) / 2;
    }
    printf("curThre:%d\n", curThre);
    staticCurThre = curThre;
    return curThre;
}


////////////////////////////////////////////
//功能：统计灰度直方图
//输入：灰度表数组
//输出：
//备注：指针版 不统计endLine 归一化
///////////////////////////////////////////
void image_GetHistGram(uint16_t* ptrHistGram, uint8_t startLine, uint8_t endLine)
{
    float* ptrhistPorprotion = &image_histPorprotion[0];
    uint16_t* ptrHistGramCy = ptrHistGram,threAmount = 0;
    uint8_t* fullBufferCy = fullBuffer;
    for (uint16_t i = 0; i < 256; i++, ptrHistGramCy++)
    {
        *ptrHistGramCy = 0; //初始化灰度直方图
    }
    ptrHistGramCy = ptrHistGram;
    for (uint8_t i = startLine; i < 52; i++)
    {
        for (uint8_t j = 0; j < CAMERA_W; j++, fullBufferCy++)
        {
            (*(ptrHistGramCy + (*fullBufferCy)))++; //统计每个灰度值的个数信息
            threAmount++;
        }
    }
    for (uint8_t i = 52; i < 72; i++)
    {
        for (uint8_t j = 0; j < CAMERA_W; j++, fullBufferCy++)
        {
            (*(ptrHistGramCy + (*fullBufferCy)))+= 3; //统计每个灰度值的个数信息
            threAmount += 3;
        }
    }
    for (uint8_t i = 72; i < endLine; i++)
    {
        for (uint8_t j = 0; j < CAMERA_W; j++, fullBufferCy++)
        {
            (*(ptrHistGramCy + (*fullBufferCy)))+=6; //统计每个灰度值的个数信息
            threAmount += 6;
        }
    }
    printf("threAmount:%d\n", threAmount);
    /*ptrHistGramCy = ptrHistGram;
    for (uint8_t i = 0; i < 3; i++)
    {
        if ((*ptrHistGramCy) > 300)
        {
            threAmount -= ((*ptrHistGramCy));
            *ptrHistGramCy = 0;
        }
        ptrHistGramCy++;
    }*/
    //for (uint8_t i = startLine; i < endLine; i++)
    //{
    //	for (uint8_t j = 0; j < CAMERA_W; j++, fullBufferCy++)
    //	{
    //		(*(ptrHistGramCy + (*fullBufferCy)))++; //统计每个灰度值的个数信息
    //		threAmount++;
    //	}
    //}

    //归一化
    for (uint16_t i = 0; i < 256; i++, ptrHistGramCy++, ptrhistPorprotion++)
    {
        *ptrhistPorprotion = (float)(*ptrHistGramCy) / threAmount;
    }
}


void image_Binarization(void)
{
    uint8_t* myMap, * ptrTransX;
    for (uint8_t i = 0; i < 15; i++)
    {
        myMap = &IMG[i][0];
        ptrTransX = &image_transformX[i * 188];
        for (uint8_t j = 0; j < 188; j++)
        {
            if (*ptrTransX == 0)
            {
                //*myMap = 5;
            }
            else if (*myMap > threUp)
            {
                *myMap = 1;
            }
            else
            {
                *myMap = 0;
            }
            myMap++, ptrTransX++;
        }
    }
    for (uint8_t i = 15; i < 120; i++)
    {
        myMap = &IMG[i][0];
        ptrTransX = &image_transformX[i * 188];
        for (uint8_t j = 0; j < 188; j++)
        {
            if (*ptrTransX == 0)
            {
                //*myMap = 5;
            }
            else if (j<=left_side[i]+25||j>=right_side[i]-25)
            {
                if ((*myMap)*1.2 > threDown)
                {
                    *myMap = 1;
                }
                else
                {
                    *myMap = 0;
                }
            }
            else
            {
                if (*myMap >= threUp)
                {
                    *myMap = 1;
                }
                else
                {
                    *myMap = 0;
                }
            }
            myMap++, ptrTransX++;
        }
    }
}



//////////////////////////////////////////////
////功能：粗犷的清车头
////输入：
////输出：
////备注：要根据自己车头的大小进行修改
/////////////////////////////////////////////
//void head_clear(void)
//{
//	uint8_t* my_map;
//	for (int i = 119; i >= 84; i--)
//	{
//		my_map = &IMG[i][0];
//		for (int j = 40; j <= 135; j++)
//		{
//			*(my_map+j) = white;
//		}
//	}
//}

////////////////////////////////////////////
//功能：查找父节点
//输入：节点编号
//输出：最老祖先
//备注：含路径压缩
///////////////////////////////////////////
int find_f(int node)
{
    if (f[node] == node)return node;//找到最古老祖先，return
    f[node] = find_f(f[node]);//向上寻找自己的父节点
    return f[node];
}

////////////////////////////////////////////
//功能：提取跳变沿 并对全部白条子标号
//输入：IMG[120][188]
//输出：white_range[120]
//备注：指针提速
///////////////////////////////////////////
void search_white_range()
{
    uint8_t i, j;
    int istart = NEAR_LINE;//处理起始行
    int iend = FAR_LINE;//处理终止行
    int tnum = 0;//当前行白条数
    all_connect_num = 0;//白条编号初始化
    uint8_t* map = NULL;
    uint8_t* ptrLeftSide = &left_side[0];
    uint8_t* ptrRightSide = &right_side[0];
    for (i = istart; i >= iend; i--)
    {
        //map = &IMG[i][LEFT_SIDE];//指针行走加快访问速度
        map = &IMG[i][ptrLeftSide[i]];
        tnum = 0;
        for (j = ptrLeftSide[i]; j <= ptrRightSide[i]; j++, map++)//j为横坐标
        {
            if ((*map))//遇白条左边界
            {
                tnum++;
                if (tnum >= white_num_MAX)break;
                range* now_white = &white_range[i].area[tnum];
                now_white->left = j;

                //开始向后一个一个像素点找这个白条右边界
                map++;
                j++;

                while ((*map) && j <= ptrRightSide[i])
                {
                    map++;
                    j++;
                }
                now_white->right = j - 1;
                now_white->connect_num = ++all_connect_num;//白条数加一，给这个白条编号
            }
        }
        white_range[i].num = tnum;
    }
}

////////////////////////////////////////////
//功能：寻找白条子连通性，将全部联通白条子的节点编号刷成最古老祖先的节点编号
//输入：
//输出：
//备注：
///////////////////////////////////////////
void find_all_connect()
{
    //f数组初始化
    for (int i = 1; i <= all_connect_num; i++)
        f[i] = i;

    //u为up d为down 即为当前处理的这两行中的上面那行和下面那行
    //u_num：上面行白条数
    //u_left：上面行当前白条左边界
    //u_right：上面行当前白条右边界
    //i_u：当前处理的这个白条是当前这行（上面行）白条中的第i_u个
    int u_num, i_u, u_left, u_right;
    int d_num, i_d, d_left, d_right;
    all_range* u_white = NULL;
    all_range* d_white = NULL;
    for (int i = NEAR_LINE; i > FAR_LINE; i--)//因为每两行每两行比较 所以循环到FAR_LINE+1
    {
        u_num = white_range[i - 1].num;
        d_num = white_range[i].num;
        u_white = &white_range[i - 1];
        d_white = &white_range[i];
        i_u = 1; i_d = 1;

        //循环到当前行或上面行白条子数耗尽为止/-
        while (i_u <= u_num && i_d <= d_num)
        {
            //变量先保存，避免下面访问写的冗杂且访问效率低
            u_left = u_white->area[i_u].left;
            u_right = u_white->area[i_u].right;
            d_left = d_white->area[i_d].left;
            d_right = d_white->area[i_d].right;

            if (u_left <= d_right && u_right >= d_left)//如果两个白条联通
                f[find_f(u_white->area[i_u].connect_num)] = find_f(d_white->area[i_d].connect_num);//父节点连起来

            //当前算法规则，手推一下你就知道为啥这样了
            if (d_right > u_right)i_u++;
            if (d_right < u_right)i_d++;
            if (d_right == u_right) { i_u++; i_d++; }
        }
    }
}

////////////////////////////////////////////
//功能：寻找赛道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void find_road()
{
    uint8_t istart = NEAR_LINE;
    uint8_t iend = FAR_LINE;
    top_road = NEAR_LINE;//赛道最高处所在行数，先初始化话为最低处
    int road_f = -1;//赛道所在连通域父节点编号，先初始化为-1，以判断是否找到赛道
    int while_range_num = 0, roud_while_range_num = 0;
    all_range* twhite_range = NULL;
    road* tmy_road = NULL;
    //寻找赛道所在连通域
    // 寻找最中心的白条子
    for (int i = 1; i <= white_range[istart].num; i++)
        if (white_range[istart].area[i].left <= CAMERA_W / 2
            && white_range[istart].area[i].right >= CAMERA_W / 2 && (white_range[istart].area[i].right - white_range[istart].area[i].left) >= 90)
            road_f = find_f(white_range[istart].area[i].connect_num);

    if (road_f == -1)//若赛道没在中间，在113行选一行最长的认为这就是赛道
    {
        int widthmax = 0, jselect = 1;
        for (int i = 1; i <= white_range[istart].num; i++)
            if (white_range[istart].area[i].right - white_range[istart].area[i].left > widthmax)
            {
                widthmax = white_range[istart].area[i].right - white_range[istart].area[i].left;
                jselect = i;
            }
        road_f = find_f(white_range[istart].area[jselect].connect_num);
    }

    //现在我们已经得到了赛道所在连通域父节点编号，接下来把所有父节点编号是road_f的所有白条子扔进赛道数组就行了
    for (int i = istart; i >= iend; i--)
    {
        //变量保存，避免之后写的冗杂且低效
        twhite_range = &white_range[i];
        tmy_road = &my_road[i];
        while_range_num = twhite_range->num;
        tmy_road->white_num = 0;
        roud_while_range_num = 0;
        for (int j = 1; j <= while_range_num; j++)
        {
            if (find_f(twhite_range->area[j].connect_num) == road_f)
            {
                top_road = i;
                tmy_road->white_num++; roud_while_range_num++;
                tmy_road->connected[roud_while_range_num].left = twhite_range->area[j].left;
                tmy_road->connected[roud_while_range_num].right = twhite_range->area[j].right;
                tmy_road->connected[roud_while_range_num].width = twhite_range->area[j].right - twhite_range->area[j].left;

            }
        }
    }
}

////////////////////////////////////////////
//功能：返回相连下一行白条子编号
//输入：i_start起始行  j_start白条标号
//输出：白条标号
//备注：认为下一行与本行赛道重叠部分对多的白条为选定赛道
///////////////////////////////////////////
uint8_t find_continue(uint8_t i_start, uint8_t j_start)
{
    uint8_t j_return;
    uint8_t j;
    uint8_t width_max = 0;
    uint8_t width_new = 0;
    uint8_t left = 0;
    uint8_t right = 0;
    uint8_t dright, dleft, uright, uleft;
    j_return = MISS;//如果没找到，输出255
    if (j_start > my_road[i_start].white_num)
        return MISS;
    //选一个重叠最大的
    for (j = 1; j <= my_road[i_start - 1].white_num; j++)
    {
        dleft = my_road[i_start].connected[j_start].left;
        dright = my_road[i_start].connected[j_start].right;
        uleft = my_road[i_start - 1].connected[j].left;
        uright = my_road[i_start - 1].connected[j].right;
        if (//相连
            dleft < uright
            &&
            dright > uleft
            )
        {
            //计算重叠大小
            if (dleft < uleft) left = uleft;
            else left = dleft;

            if (dright > uright) right = uright;
            else right = dright;

            width_new = right - left + 1;

            if (width_new > width_max)
            {
                width_max = width_new;
                j_return = j;
            }
        }

    }
    return j_return;
}

////////////////////////////////////////////
//功能：通用决定双边（找连通路径）
//输入：
//输出：
//备注：
///////////////////////////////////////////
void ordinary_two_line(void)
{
    uint8_t i;
    uint8_t j;
    uint8_t j_continue[CAMERA_H];//第一条连通路径
    uint8_t i_start;
    uint8_t i_end;
    uint8_t j_start = MISS;
    int width_max;

    //寻找起始行最宽的白条子
    i_start = NEAR_LINE;
    i_end = FAR_LINE;
    width_max = 0;
    for (j = 1; j <= my_road[i_start].white_num; j++)
    {
        if (my_road[i_start].connected[j].width > width_max)
        {
            width_max = my_road[i_start].connected[j].width;
            j_start = j;
        }
    }
    j_continue[i_start] = j_start;

    //记录连贯区域编号
    for (i = i_start; i > i_end; i--)
    {
        //如果相连编号大于该行白条数，非正常，从此之后都MISS
        if (j_continue[i] > my_road[i].white_num)
        {
            j_continue[i - 1] = MISS;
        }
        else
        {
            j_continue[i - 1] = find_continue(i, j_continue[i]);
        }

    }

    //全部初始化为MISS
    my_memset(left_line, MISS, CAMERA_H);
    my_memset(right_line, MISS, CAMERA_H);


    for (i = i_start; i > i_end; i--)
    {
        if (j_continue[i] <= my_road[i].white_num)
        {
            left_line[i] = my_road[i].connected[j_continue[i]].left;
            right_line[i] = my_road[i].connected[j_continue[i]].right;
            IMG[i][left_line[i]] = blue;
            IMG[i][right_line[i]] = red;
        }
        else
        {
            left_line[i] = MISS;
            right_line[i] = MISS;
        }
    }
}

////////////////////////////////////////////
//功能：数组初始化
//输入：uint8_t* ptr 数组首地址, uint8_t num初始化的值, uint8_t size数组大小
//输出：
//备注：因为k66库中认为memset函数不安全，所以无法使用；因此需要自己写一个my_memset
///////////////////////////////////////////
void my_memset(uint8_t* ptr, uint8_t num, uint8_t size)
{
    uint8_t* p = ptr;
    uint8_t my_num = num;
    uint8_t Size = size;
    for (int i = 0; i < Size; i++, p++)
    {
        *p = my_num;
    }
}
////////////////////////////////////////////
//功能：中线合成
//输入：左右边界
//输出：中线
//备注：
///////////////////////////////////////////
void get_mid_line(void)
{
    my_memset(mid_line, MISS, CAMERA_H);
    for (int i = NEAR_LINE; i >= FAR_LINE; i--)
        if (left_line[i] != MISS)
        {
            mid_line[i] = (left_line[i] + right_line[i]) / 2;
        }
        else
        {
            mid_line[i] = MISS;
        }

}
void GetMidLine(void)
{
    for (int i = NEAR_LINE; i >= FAR_LINE; i--)
        if (left_line[i] != MISS)
        {
            midLine[i] = (left_line[i] + right_line[i]) / 2;
        }
        else
        {
            midLine[i] = MISS;
        }
}
////////////////////////////////////////////
//功能：图像处理主程序
//输入：
//输出：
//备注：
///////////////////////////////////////////

uint8_t circleNum = 1;
int tridentDir = 0;
void image_main(uint8_t adcJudge)
{
    //获得电磁判据
    image_adcJudge = adcJudge;
    //白条提取
    image_Preprocess();
    search_white_range();
    find_all_connect();
    find_road();
    /*到此处为止，我们已经得到了属于赛道的结构体数组my_road[CAMERA_H]*/
    image_TellIfOutOfRoad();
    if (stateMgr.curtState == stop)
    {
        printf("stop\n");
        return;
    }
    image_FeatureExtract();
    //image_AdcCheck();
    image_TellIfEnterZebra();
    if (tridentDir == 0)
    {
        if (stateMgr.curtState == enterZebra)
        {
            if (circleNum == 0)
            {
                image_TellIfQuitZebra();
                if (stateMgr.curtState == others)
                {
                    circleNum++;
                }
            }
            else if (circleNum == 1)
            {
                if (ctrl_cirDir == 1)
                {
                    image_TellIfEnterLeftGarage(&supplyStateEnum);
                }
                else if (ctrl_cirDir == -1)
                {
                    image_TellIfEnterRightGarage(&supplyStateEnum);
                }
                if (supplyStateEnum & 0x1000)
                {
                    stateMgr.lastState = stateMgr.curtState;
                    stateMgr.curtState = enterGarage;
                }
            }
        }
    }
    else if(tridentDir==1)
    {
        if (stateMgr.curtState == enterZebra)
        {
            if (circleNum == 1)
            {
                image_TellIfQuitZebra();
                if (stateMgr.curtState == others)
                {
                    circleNum--;
                }
            }
            else if (circleNum == 0)
            {
                if (ctrl_cirDir == 1)
                {
                    image_TellIfEnterLeftGarage(&supplyStateEnum);
                }
                else if (ctrl_cirDir == -1)
                {
                    image_TellIfEnterRightGarage(&supplyStateEnum);
                }
                if (supplyStateEnum & 0x1000)
                {
                    stateMgr.lastState = stateMgr.curtState;
                    stateMgr.curtState = enterGarage;
                }
            }
        }
    }
    printf("circleNum:%d\n", circleNum);
    if (stateMgr.curtState != enterZebra)
    {
        if (image_JudgeElement())
        {
            image_JudgeElement();
        }
        image_EdgePatching();
    }
    else
    {
        image_EdgePatching();
    }
    for (int i = NEAR_LINE; i >= FAR_LINE; i--)
    {
        if (mid_line[i] < 188)
        {
            IMG[i][mid_line[i]] = 2;
        }
    }
    image_getDeviation();
}


////////////////////////////////////////////
//功能：电磁校验函数
//输入：
//输出：
//备注：
///////////////////////////////////////////

void image_AdcCheck(void)
{
    if (image_adcJudge == 1)//环岛电磁判据
    {
        switch (stateMgr.curtState)
        {
        //允许的状态
        case leftRoundaboutStage3:
        case leftRoundaboutStage4:
        case leftRoundaboutStage5:
        case leftRoundaboutStage6:
        case leftRoundaboutStage7:
        case leftRoundaboutStage8:
        case leftRoundaboutStage9:
        case rightRoundaboutStage3:
        case rightRoundaboutStage4:
        case rightRoundaboutStage5:
        case rightRoundaboutStage6:
        case rightRoundaboutStage7:
        case rightRoundaboutStage8:
        case rightRoundaboutStage9:
            break;
        //校验失败
        default:
            if (leftVaric < 10)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = rightRoundaboutStage3;
            }
            if (rightVaric < 10)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = leftRoundaboutStage3;
            }
            break;
        }
    }
}

void image_TellIfOutOfRoad(void)
{
    uint8_t outCounter = 0;
    for (uint8_t i = NEAR_LINE - 3; i > NEAR_LINE - 43; i--)
    {
        if (my_road[i].white_num == 0)
        {
            outCounter++;
        }
    }
    if (outCounter > 20)
    {
        stateMgr.curtState = stop;
        return;
    }
}


void image_TellIfEnterZebra(void)
{
    static uint8_t stateCounter = 0;
    uint8_t counter = 0;
    if ((ctrl_cirDir == 1 && rightVaric>5) || (ctrl_cirDir == -1 && leftVaric>5))//延申与车库位置不对应
    {
        stateCounter = 0;
        return;
    }
    for (uint8_t i = FAR_LINE; i <= 70; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd >= 5)
        {
            if (abs(my_road[i].connected[jEnd / 2].width - my_road[i].connected[jEnd / 2 + 1].width) <= 2 && abs(my_road[i].connected[jEnd / 2 + 1].width - my_road[i].connected[jEnd / 2 + 2].width) <= 2)
            {
                counter++;
            }
        }
    }
    if (counter >= 15)
    {
        stateCounter+=2;
    }
    else if (counter >= 9)
    {
        stateCounter++;
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        stateMgr.lastState = stateMgr.curtState;
        stateMgr.curtState = enterZebra;
        stateCounter = 0;
    }
}

void image_TellIfQuitZebra(void)
{
    static uint8_t stateCounter = 0;
    uint8_t counter = 0;
    if (ctrl_cirDir == 1)//左车库
    {
        if (edgeLineEnum & 0x80)//左边线左延申肯定还没有经历完车库
        {
            stateCounter = 0;
            return;
        }
        else if (edgeLineEnum & 0x40 && leftJumpPos <= 90)
        {
            stateCounter = 0;
            return;
        }
    }
    else if (ctrl_cirDir == -1)
    {
        if (edgeLineEnum & 0x04)//右边线右延申肯定没有经历完车库
        {
            stateCounter = 0;
            return;
        }
        else if (edgeLineEnum & 0x08 && rightJumpPos <= 90)
        {
            stateCounter = 0;
            return;
        }
    }
    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
    {
        if (my_road[i].white_num >= 5)
        {
            counter++;
        }
    }
    if (counter >= 9)
    {
        stateCounter = 0;
        return;
    }
    else
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        stateMgr.lastState = stateMgr.curtState;
        stateMgr.curtState = others;
        stateCounter = 0;
    }
}

void image_TellIfEnterLeftGarage(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t zebraPos = MISS;
    for (uint8_t i = FAR_LINE; i <= NEAR_LINE; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd >= 6)
        {
            if (abs(my_road[i].connected[jEnd / 2].width - my_road[i].connected[jEnd / 2 + 1].width) <= 2 && abs(my_road[i].connected[jEnd / 2 + 1].width - my_road[i].connected[jEnd / 2 + 2].width) <= 2)
            {
                zebraPos = i;
            }
        }
    }
    printf("zebraPos:%d\n", zebraPos);
    if (zebraPos >= image_enterGaragePara)
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x1000;
        stateCounter = 0;
    }
}

void image_TellIfEnterRightGarage(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t zebraPos = MISS;
    for (uint8_t i = FAR_LINE; i <= NEAR_LINE; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd >= 6)
        {
            if (abs(my_road[i].connected[jEnd / 2].width - my_road[i].connected[jEnd / 2 + 1].width) <= 2 && abs(my_road[i].connected[jEnd / 2 + 1].width - my_road[i].connected[jEnd / 2 + 2].width) <= 2)
            {
                zebraPos = i;
            }
        }
    }
    printf("zebraPos:%d\n", zebraPos);
    if (zebraPos >= image_enterGaragePara)
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x1000;
        stateCounter = 0;
    }
}





////////////////////////////////////////////
//功能：图像特征粗提取
//输入：
//输出：
//备注：采用位标志变量edgeLineEnum 左边缘线： _      _      _      _				右边缘线同理
//											  左延申 右延申 弯不弯 信息是否完全丢失
///////////////////////////////////////////

void image_FeatureExtract(void)
{
    edgeLineEnum = 0, supplyEdgeLineEnum = 0;//初始化位枚举变量
    image_remedyFlag = MISS;
    leftVaric = 0, rightVaric = 0;
    if (stateMgr.curtState == enterCrossStage2)
    {
        //选择中间为双边
        image_InitRoadLine();
    }
    else
    {
        //初始化两条边缘线
        image_InitEdgeLine();
    }
    //判断边缘线信息是否丢失
    image_IfEdgeLineLose(&edgeLineEnum);
    jumpPosVar = image_FindJumpos(&edgeLineEnum, 90, 10);
    //若两条边缘线均未丢失
    if ((edgeLineEnum & 0x01) && (edgeLineEnum & 0x10))
    {
        switch (stateMgr.curtState)
        {
        case leftRoundaboutStage7:
        case rightRoundaboutStage7:
            edgeLineEnum |= (image_LineIfStraight(leftEdge, 0, 75, &leftVaric) << 4);
            edgeLineEnum |= image_LineIfStraight(rightEdge, 0, 75, &rightVaric);
            break;
        default:
            edgeLineEnum |= (image_LineIfStraight(leftEdge, 0, 80, &leftVaric) << 4);
            edgeLineEnum |= image_LineIfStraight(rightEdge, 0, 80, &rightVaric);
            supplyEdgeLineEnum |= ((image_RootLineIfAbsStraight(leftEdge, 0)) << 4);
            supplyEdgeLineEnum |= image_RootLineIfAbsStraight(rightEdge, 1);
            break;
        }
    }
    //若任意一条边缘线丢失
    else
    {
        switch (stateMgr.curtState)
        {
        case enterLeftRoundabout:
        case enterRightRoundabout:
            edgeLineEnum |= (image_LineIfStraight(leftEdge, 0, 80, &leftVaric) << 4);
            edgeLineEnum |= image_LineIfStraight(rightEdge, 0, 80, &rightVaric);
            break;
        case others:
            if (edgeLineEnum & 0x10)
            {
                supplyEdgeLineEnum |= ((image_RootLineIfAbsStraight(leftEdge, 0)) << 4);
                edgeLineEnum |= (image_LineIfStraight(leftEdge, 0, 80, &leftVaric) << 4);
            }
            else if (edgeLineEnum & 0x01)
            {
                supplyEdgeLineEnum |= image_RootLineIfAbsStraight(rightEdge, 1);
                edgeLineEnum |= image_LineIfStraight(rightEdge, 0, 80, &rightVaric);
            }
            break;
        case leftRoundaboutStage7:
        case rightRoundaboutStage7:
            edgeLineEnum |= (image_LineIfStraight(leftEdge, 0, 75, &leftVaric) << 4);
            edgeLineEnum |= image_LineIfStraight(rightEdge, 0, 75, &rightVaric);
            break;
        case quitCross:
            jumpPosVar = image_FindJumpos(&edgeLineEnum, 100, 10);
            supplyEdgeLineEnum |= ((image_RootLineIfAbsStraight(leftEdge, 0)) << 4);
            supplyEdgeLineEnum |= image_RootLineIfAbsStraight(rightEdge, 1);
            break;
        default:
            if (edgeLineEnum & 0x10)
            {
                supplyEdgeLineEnum |= ((image_RootLineIfAbsStraight(leftEdge, 0)) << 4);
                edgeLineEnum |= (image_LineIfStraight(leftEdge, 0, 80, &leftVaric) << 4);
            }
            else if (edgeLineEnum & 0x01)
            {
                supplyEdgeLineEnum |= image_RootLineIfAbsStraight(rightEdge, 1);
                edgeLineEnum |= image_LineIfStraight(rightEdge, 0, 80, &rightVaric);
            }
            break;
        }
    }
    //斜入特征提取
    image_TiltEnterTriCrossGetFeature(&TiltFeatureMgr);
    image_remedyFlag = image_TellIfNeedRemedy();
    //识别结果打印
    printf("edgeLineEnum:%d\n", edgeLineEnum);
    printf("jumpPosVar:%d\n", jumpPosVar);
    if (edgeLineEnum & 0x02)
    {
        printf("right line not straight\n");
    }
    else
    {
        printf("right line straight\n");
    }
    if (edgeLineEnum & 0x20)
    {
        printf("left line not straight\n");
    }
    else
    {
        printf("left line straight\n");
    }
}
////////////////////////////////////////////
//功能：元素判断主程序
//输入：
//输出：是否需要再次判断
//备注：状态机还不是位标志变量，状态机权限下放
///////////////////////////////////////////
uint8_t downRampFlag = 0;
uint8_t image_JudgeElement(void)
{
    stateEnum = 0, supplyStateEnum = 0;//初始化位枚举变量
    uint8_t ifJudgeAgain = 0;
    //此处应根据状态机来决定进行怎样逻辑的赛道元素验证（正 or 正反） 判断顺序有待考量
    switch (stateMgr.curtState)
    {
    case others:
    {
        image_TellIfEnterRamp(&supplyStateEnum);
        if (downRampFlag == 1)
        {
            return ifJudgeAgain;
        }
        if (supplyStateEnum & 0x8000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterRamp;
            break;
        }
        if ((edgeLineEnum & 0x01) && (edgeLineEnum & 0x10))//两条边缘线未丢失
        {
            image_TellIfEnterTricross(&stateEnum);//比较正，不需要特殊补线
            if (stateEnum & 0x0001)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = enterTriCross;
                ifJudgeAgain = 1;
                break;
            }
            image_TellIfLateEnterTrident(&supplyStateEnum);
            if (supplyStateEnum & 0x4000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = enterTrident;
                break;
            }
            if (edgeLineEnum == 0x17)
            {
                image_TellIfEnterRightRoundabout(&stateEnum);
                if (stateEnum & 0x0400)
                {
                    stateMgr.lastState = stateMgr.curtState;
                    stateMgr.curtState = enterRightRoundabout;
                }
            }
            else if (edgeLineEnum == 0xB1)
            {
                image_TellIfEnterLeftRoundabout(&stateEnum);
                if (stateEnum & 0x0200)
                {
                    stateMgr.lastState = stateMgr.curtState;
                    stateMgr.curtState = enterLeftRoundabout;
                }
            }
        }
        if (edgeLineEnum & 0x10)
        {
            image_TellIfTiltEnterRightRoundabout(&stateEnum);
            if (stateEnum & 0x0800)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = rightRoundaboutStage2;
                break;
            }
        }
        if (edgeLineEnum & 0x01)
        {
            image_TellIfTiltEnterLeftRoundabout(&stateEnum);
            if (stateEnum & 0x1000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = leftRoundaboutStage2;
                break;
            }
        }
        TiltFeatureMgr.tridentFlag = image_TellIfLeftTiltEnterTrident(&supplyStateEnum);
        if (supplyStateEnum & 0x2000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftTiltEnterTrident;
            ifJudgeAgain = 1;
            break;
        }
        TiltFeatureMgr.tridentFlag = image_TellIfRightTiltEnterTrident(&supplyStateEnum);
        if (supplyStateEnum & 0x1000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightTiltEnterTrident;
            ifJudgeAgain = 1;
            break;
        }
        //image_TellIfSlightLeftTiltEnterCross(&stateEnum);
        //image_TellIfSlightRightTiltEnterCross(&stateEnum);
        if (stateEnum & 0x0010)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterCrossStage2;
            break;
        }
        image_TellIfRightTiltEnterCross(&stateEnum);//跳变位置有要求，斜入需特殊补线
        if (stateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightTiltEnterCross;
            break;
        }
        image_TellIfLeftTiltEnterCross(&stateEnum);
        if (stateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftTiltEnterCross;
            break;
        }
        break;
    }
    case enterTriCross://三叉或十字 该分支下需进一步分辨两状态
    {
        if (TiltFeatureMgr.notTridentFlag != 1 && TiltFeatureMgr.crossFlag != 1)
        {
            image_TellIfEnterTrident(&supplyStateEnum);
            if (supplyStateEnum & 0x4000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = enterTrident;
                break;
            }
        }
        uint8_t ifGetBlackRange = 0;
        ifGetBlackRange = image_TellIfEnterTridentStage2(&stateEnum);//能否进入三叉2阶段
        if (stateEnum & 0x0002)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = TridentStage2;
            break;
        }
        image_TellIfLateEnterTrident(&supplyStateEnum);
        if (supplyStateEnum & 0x4000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterTrident;
            break;
        }
        //顶上有黑条不用判断十字
        if (!ifGetBlackRange)//依旧保持良好的左右延申
        {
            image_TellIfEnterCross(&stateEnum);//能否进入十字2阶段，正进情况，要求较严
            if (stateEnum & 0x0010)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = enterCrossStage2;
                break;
            }
            image_TellIfQuitCross(&stateEnum);
            if (stateEnum & 0x0020)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = quitCross;
                break;
            }
        }
        image_TellIfRightTiltEnterCross(&stateEnum);//跳变位置有要求，斜入需特殊补线
        if (stateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightTiltEnterCross;
            break;
        }
        image_TellIfLeftTiltEnterCross(&stateEnum);
        if (stateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftTiltEnterCross;
            break;
        }
        break;
    }
    case enterTrident:
    {
        uint8_t ifGetBlackRange = 0;
        ifGetBlackRange = image_TellIfEnterTridentStage2(&stateEnum);//能否进入三叉2阶段
        if (stateEnum & 0x0002)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = TridentStage2;
            break;
        }
        break;
    }
    case TridentStage2:
        image_TellIfEnterTridentStage3(&stateEnum);//看找不找得到黑尖点
        if (stateEnum & 0x0004)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }
        break;
    case enterCrossStage2:
        image_TellIfQuitCross(&stateEnum);
        if (stateEnum & 0x0020)
        {
            if (stateMgr.lastState == leftTiltEnterCross || stateMgr.lastState == rightTiltEnterCross)
            {
                stateMgr.curtState = quitCross;
                break;
            }
            else
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = quitCross;
                break;
            }
        }
        break;
    case leftTiltEnterTrident:
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 12);
        if (TiltFeatureMgr.crossFlag == 1||blackNum>=5)
        {
            stateMgr.curtState = others;
            ifJudgeAgain = 1;
            break;
        }
        image_TellIfLeftTiltQuitTrident(&supplyStateEnum);
        if (supplyStateEnum & 0x0004)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }
        break;
    }
    case rightTiltEnterTrident:
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 12);
        if (TiltFeatureMgr.crossFlag == 1||blackNum>=5)
        {
            stateMgr.curtState = others;
            ifJudgeAgain = 1;
            break;
        }
        image_TellIfRightTiltQuitTrident(&supplyStateEnum);
        if (supplyStateEnum & 0x0004)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }
        break;
    }
    case rightTiltEnterCross:
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 12);
        if (blackNum >= 5)
        {
            stateMgr.curtState = others;
            ifJudgeAgain = 1;
            break;
        }
        if (edgeLineEnum & 0x10 && edgeLineEnum & 0x04 && leftVaric < 5)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterRightRoundabout;
            break;
        }
        image_TellIfMissJudgeTiltCross(&stateEnum);
        if (stateEnum & 0x0002)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = TridentStage2;
            break;
        }
        image_TellIfEnterCross(&stateEnum);//能否进入十字2阶段，正进情况，要求较严
        if (stateEnum & 0x0010)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterCrossStage2;
            break;
        }
        image_TellIfQuitCross(&stateEnum);
        if (stateEnum & 0x0020)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = quitCross;
            break;
        }
        /*image_TellIfTiltQuitCross(&supplyStateEnum);
        if (supplyStateEnum & 0x1000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = quitCross;
            break;
        }*/
        /*image_TellIfCrossComplete(&stateEnum);
        if (stateEnum & 0x0040)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }*/
        break;
    }
    case leftTiltEnterCross:
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 12);
        if (blackNum >= 5)
        {
            stateMgr.curtState = others;
            ifJudgeAgain = 1;
            break;
        }
        if (edgeLineEnum & 0x01 && edgeLineEnum & 0x80 && rightVaric < 5)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterLeftRoundabout;
            break;
        }
        image_TellIfMissJudgeTiltCross(&stateEnum);
        if (stateEnum & 0x0002)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = TridentStage2;
            break;
        }
        image_TellIfEnterCross(&stateEnum);//能否进入十字2阶段，正进情况，要求较严
        if (stateEnum & 0x0010)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = enterCrossStage2;
            break;
        }
        image_TellIfQuitCross(&stateEnum);
        if (stateEnum & 0x0020)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = quitCross;
            break;
        }
        /*image_TellIfTiltQuitCross(&supplyStateEnum);
        if (supplyStateEnum & 0x1000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = quitCross;
            break;
        }*/
        /*image_TellIfCrossComplete(&stateEnum);
        if (stateEnum & 0x0040)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }*/
        break;
    }
    case quitCross:
        image_TellIfCrossComplete(&stateEnum);
        if (stateEnum & 0x0040)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }
        break;
    case specialQuitCross:
        image_TellIfCrossComplete(&stateEnum);
        if (stateEnum & 0x0040)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            break;
        }
        break;
    case enterLeftRoundabout:
        image_TellIfMissJudgeLeftRound(&stateEnum);
        if (stateEnum & 0x0001)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            ifJudgeAgain = 1;
            break;
        }
        if (stateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftTiltEnterCross;
            break;
        }
        image_TellIfLeftRoundStage2(&stateEnum);
        if (stateEnum & 0x1000)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftRoundaboutStage2;
            break;
        }
        if (edgeLineEnum & 0x01)
        {
            image_TellIfTiltEnterLeftRoundabout(&stateEnum);
            if (stateEnum & 0x1000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = leftRoundaboutStage2;
                break;
            }
        }
        break;
    case enterRightRoundabout:
        image_TellIfMissJudgeRightRound(&stateEnum);
        if (stateEnum & 0x0001)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
            ifJudgeAgain = 1;
            break;
        }
        if (stateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightTiltEnterCross;
            break;
        }
        image_TellIfRightRoundStage2(&stateEnum);
        if (stateEnum & 0x0800)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightRoundaboutStage2;
            break;
        }
        if (edgeLineEnum & 0x10)
        {
            image_TellIfTiltEnterRightRoundabout(&stateEnum);
            if (stateEnum & 0x0800)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = rightRoundaboutStage2;
                break;
            }
        }
        break;
    case leftRoundaboutStage2:
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 25, 12);
        if (blackNum >= 8)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        if (rightVaric > 10)//右边线变弯,有问题
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        else
        {
            image_TellIfLeftRoundStage3(&stateEnum);
            if (stateEnum & 0x4000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = leftRoundaboutStage3;
                break;
            }
        }
        break;
    }
    case rightRoundaboutStage2:
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 25, 12);
        if (blackNum >= 8)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        if (leftVaric > 10)//左边线变弯，有问题
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        else
        {
            image_TellIfRightRoundStage3(&stateEnum);
            if (stateEnum & 0x2000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = rightRoundaboutStage3;
            }
        }
        break;
    }
    case leftRoundaboutStage3:
        if (edgeLineEnum & 0x02)//右边线变弯,有问题
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        else
        {
            image_TellIfLeftRoundStage4(&stateEnum);
            if (stateEnum & 0x8000)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = leftRoundaboutStage4;
            }
        }
        break;
    case rightRoundaboutStage3:
        if (edgeLineEnum & 0x20)//左边线变弯，有问题
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        else
        {
            image_TellIfRightRoundStage4(&supplyStateEnum);
            if (supplyStateEnum & 0x0001)
            {
                stateMgr.lastState = stateMgr.curtState;
                stateMgr.curtState = rightRoundaboutStage4;
            }
        }
        break;
    case leftRoundaboutStage4:
        image_TellIfLeftRoundStage5(&supplyStateEnum);
        if (supplyStateEnum & 0x0002)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftRoundaboutStage5;
        }
        break;
    case rightRoundaboutStage4:
        image_TellIfRightRoundStage5(&supplyStateEnum);
        if (supplyStateEnum & 0x0004)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightRoundaboutStage5;
        }
        break;
    case leftRoundaboutStage5:
        image_TellIfLeftRoundStage6(&supplyStateEnum);
        if (supplyStateEnum & 0x0008)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftRoundaboutStage6;
        }
        break;
    case rightRoundaboutStage5:
        image_TellIfRightRoundStage6(&supplyStateEnum);
        if (supplyStateEnum & 0x0010)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightRoundaboutStage6;
        }
        break;
    case leftRoundaboutStage6:
        image_TellIfLeftRoundStage7(&supplyStateEnum);
        if (supplyStateEnum & 0x0020)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftRoundaboutStage7;
        }
        break;
    case rightRoundaboutStage6:
        image_TellIfRightRoundStage7(&supplyStateEnum);
        if (supplyStateEnum & 0x0040)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightRoundaboutStage7;
        }
        break;
    case leftRoundaboutStage7:
        image_TellIfLeftRoundStage8(&supplyStateEnum);
        if (supplyStateEnum & 0x0080)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftRoundaboutStage8;
        }
        break;
    case rightRoundaboutStage7:
        image_TellIfRightRoundStage8(&supplyStateEnum);
        if (supplyStateEnum & 0x0100)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightRoundaboutStage8;
        }
        break;
    case leftRoundaboutStage8:
        image_TellIfLeftRoundStage9(&supplyStateEnum);
        if (supplyStateEnum & 0x0200)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = leftRoundaboutStage9;
        }
        break;
    case rightRoundaboutStage8:
        image_TellIfRightRoundStage9(&supplyStateEnum);
        if (supplyStateEnum & 0x0400)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = rightRoundaboutStage9;
        }
        break;
    case leftRoundaboutStage9:
        image_TellIfQuitLeftRound(&supplyStateEnum);
        if (supplyStateEnum & 0x0800)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        break;
    case rightRoundaboutStage9:
        image_TellIfQuitRightRound(&supplyStateEnum);
        if (supplyStateEnum & 0x0800)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = others;
        }
        break;
    default:
        break;
    }
    curState = stateMgr.curtState;
    //状态机更新结果打印
    printf("stateMgr curState:%d\n", stateMgr.curtState);
    return ifJudgeAgain;
}

////////////////////////////////////////////
//功能：判断是否一行实际的白条数
//输入：哪一行
//输出：
//备注：
///////////////////////////////////////////

uint8_t image_TellRealWhiteNum(uint8_t row)
{
    uint8_t realWhiteNum = 0;
    uint8_t jEnd = my_road[row].white_num;
    for (uint8_t j = 1; j <= jEnd; j++)
    {
        if (my_road[row].connected[j].width >= 20)
        {
            realWhiteNum++;
        }
    }
    return realWhiteNum;
}

void image_TellIfEnterRamp(int16_t* ptrStateEnum)
{
    downRampFlag = 0;
    //信息没有缺失的线不能有跳变
    if (edgeLineEnum & 0x10)
    {
        if (edgeLineEnum & 0x80 || edgeLineEnum & 0x40)
        {
            return;
        }
    }
    if (edgeLineEnum & 0x01)
    {
        if (edgeLineEnum & 0x08 || edgeLineEnum & 0x04)
        {
            return;
        }
    }
    //长白条个数
    uint8_t largeWhiteNum = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 38; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 95)
            {
                largeWhiteNum++;
                break;
            }
        }
    }
    for (uint8_t i = FAR_LINE+38; i < FAR_LINE + 60; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > (right_side[i]-left_side[i])*0.505)
            {
                largeWhiteNum++;
                break;
            }
        }
    }
    if (largeWhiteNum > 45)
    {
        if (image_rampCanUp)
        {
            *ptrStateEnum |= 0x8000;
        }
        else
        {
            downRampFlag = 1;
        }
    }
    //左右两直线打开
    if (edgeLineEnum & 0x10 && edgeLineEnum & 0x01)
    {
        if (leftVaric < 5 && rightVaric < 5)
        {
            float leftK = MISS,rightK = MISS;
            if (leftEdge[FAR_LINE] != leftEdge[75])
            {
                leftK = ((float)FAR_LINE - 75) / (leftEdge[FAR_LINE] - leftEdge[75]);
            }
            if (rightEdge[FAR_LINE] != rightEdge[75])
            {
                rightK = ((float)FAR_LINE - 75) / (rightEdge[FAR_LINE] - rightEdge[75]);
            }
            printf("leftK:%f,rightK:%f\n", leftK, rightK);
            if (leftK < 3.5 && leftK>1.5 && rightK > -3.5 && rightK < -1.5)
            {
                if (image_rampCanUp)
                {
                    *ptrStateEnum |= 0x8000;
                }
                else
                {
                    downRampFlag = 1;
                }
            }
        }
    }
    printf("Ramp:largeWhiteNum:%d\n", largeWhiteNum);
}

////////////////////////////////////////////
//功能：判断是否需要补救补线
//输入：
//输出：
//备注：目前针对单边有跳变，顶部有长白条
///////////////////////////////////////////

uint8_t image_TellIfNeedRemedy(void)
{
    uint8_t remedyFlag = MISS;
    if (TiltFeatureMgr.leftMissCount < 30 && TiltFeatureMgr.rightMissCount>30 && (TiltFeatureMgr.leftBreakPoint != MISS || (edgeLineEnum & 0x80 && edgeLineEnum & 0x20)))//左斜入
    {
        //左线弯，右线丢失信息
        if (edgeLineEnum & 0x20 && ~edgeLineEnum & 0x01)
        {
            remedyFlag = 0;
        }
        //看顶部是否有大长白条
        uint8_t whiteNumCounter = 0;
        for (uint8_t i = FAR_LINE; i <= 30; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 90)
                {
                    whiteNumCounter++;
                    break;
                }
            }
        }
        printf("whiteNumCounter:%d\n", whiteNumCounter);
        if (whiteNumCounter > 12)
        {
            remedyFlag = 0;
        }
    }
    if (TiltFeatureMgr.leftMissCount > 30 && TiltFeatureMgr.rightMissCount < 30 && (TiltFeatureMgr.rightBreakPoint != MISS || (edgeLineEnum & 0x04 && edgeLineEnum & 0x02)))
    {
        if (edgeLineEnum & 0x02 && ~edgeLineEnum & 0x10)
        {
            remedyFlag = 1;
        }
        //看顶部是否有大长白条
        uint8_t whiteNumCounter = 0;
        for (uint8_t i = FAR_LINE; i <= 30; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 90)
                {
                    whiteNumCounter++;
                    break;
                }
            }
        }
        printf("whiteNumCounter:%d\n", whiteNumCounter);
        if (whiteNumCounter >= 5)
        {
            remedyFlag = 1;
        }
    }
    //弯道补线,此项比黑尖点优先，弯道不会黑尖点补线
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 12);
    if (blackNum > 30)
    {
        if (edgeLineEnum & 0x01 && ~edgeLineEnum & 0x10)//左转
        {
            remedyFlag = 4;
            printf("remedyFlag:^%d\n", remedyFlag);
            return remedyFlag;
        }
        else if(edgeLineEnum&0x10&&~edgeLineEnum&0x01)//右转
        {
            remedyFlag = 5;
            printf("remedyFlag:^%d\n", remedyFlag);
            return remedyFlag;
        }
    }
    if (blackNum > 10)
    {
        if (TiltFeatureMgr.rightMissCount > 30 && TiltFeatureMgr.leftMissCount < 15)
        {
            remedyFlag = 5;
            printf("remedyFlag:^%d\n", remedyFlag);
            return remedyFlag;
        }
        else if (TiltFeatureMgr.leftMissCount > 30 && TiltFeatureMgr.rightMissCount < 15)
        {
            remedyFlag = 4;
            printf("remedyFlag:^%d\n", remedyFlag);
            return remedyFlag;
        }
    }
    if (TiltFeatureMgr.cuspLine != MISS && TiltFeatureMgr.crossFlag == 0 && remedyFlag == MISS)
    {
        remedyFlag = MISS;
    }
    else if (TiltFeatureMgr.cuspLine != MISS && TiltFeatureMgr.crossFlag == 1)
    {
        if (TiltFeatureMgr.leftMissCount < 30 && TiltFeatureMgr.rightMissCount>35)//右边丢线很多，左边线比较完整，左斜入
        {
            remedyFlag = 2;
        }
        else if (TiltFeatureMgr.leftMissCount > 35 && TiltFeatureMgr.rightMissCount < 30)//右斜入
        {
            remedyFlag = 3;
        }
    }
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04 && edgeLineEnum & 0x20 && edgeLineEnum & 0x02)
    {
        if (~supplyEdgeLineEnum & 0x20 && ~supplyEdgeLineEnum & 0x02)
        {
            remedyFlag = 6;
        }
    }
    /*if (blackNum >= 5)
    {
        if (TiltFeatureMgr.leftMissCount < 8 && TiltFeatureMgr.rightMissCount>12 && TiltFeatureMgr.rightMissCount <= 45)
        {
            remedyFlag = 7;
        }
    }*/
    printf("remedyFlag:%d\n", remedyFlag);
    return remedyFlag;
}

////////////////////////////////////////////
//功能：判断是否为进十字或三叉
//输入：
//输出：
//备注：比较正的情况
///////////////////////////////////////////
void image_TellIfEnterTricross(int16_t* ptrStateEnum)
{
    uint8_t topWhiteRangeNum = 0;
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x20 && edgeLineEnum & 0x04 && edgeLineEnum & 0x02 && abs(jumpPosVar) < 25)//左边线左延申，右边线右延申，且两边都弯
    {
        if (supplyEdgeLineEnum & 0x20 && supplyEdgeLineEnum & 0x02)//两边都不竖直，肯定不是
        {
            uint8_t crossFlag = 0;
            if (edgeLineEnum & 0x80 && leftJumpPos > 25)
            {
                if (leftEdge[leftJumpPos - 15] < leftEdge[leftJumpPos] && leftEdge[leftJumpPos] - leftEdge[leftJumpPos - 15] > 35)
                {
                    crossFlag = 1;
                }
            }
            if (edgeLineEnum & 0x04 && rightJumpPos > 25)
            {
                if (rightEdge[rightJumpPos - 15] > rightEdge[rightJumpPos] && rightEdge[rightJumpPos - 15] - rightEdge[rightJumpPos] > 35)
                {
                    crossFlag = 1;
                }
            }
            if (crossFlag != 1)
            {
                stateCounter = 0;
                return;
            }
        }
        //检查两边弯的方向
        float kLeft = ((float)leftJumpPos - FAR_LINE) / ((float)leftEdge[leftJumpPos] - leftEdge[FAR_LINE]);
        float kRight = ((float)rightJumpPos - FAR_LINE) / ((float)rightEdge[rightJumpPos] - rightEdge[FAR_LINE]);
        printf("kLeft:%f\n", kLeft);
        printf("kRight:%f\n", kRight);
        if (kLeft < 0.4 || kLeft>3 || kRight > -0.4 || kRight < -3)
        {
            stateCounter = 0;
            return;
        }
        //检查图像顶部是否有长白条
        for (uint8_t i = FAR_LINE; i < 25; i++)
        {
            uint8_t jEnd = my_road[i].white_num, topWhiteWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (j == 1)
                {
                    topWhiteWidth += my_road[i].connected[j].width;
                }
                else
                {
                    if (my_road[i].connected[j].left - my_road[i].connected[j - 1].right <= 5)
                    {
                        topWhiteWidth += my_road[i].connected[j].width;
                    }
                }
            }
            if (topWhiteWidth > 110)
            {
                topWhiteRangeNum++;
            }
        }
        if (topWhiteRangeNum >= 15)
        {
            stateCounter += 2;
            printf("进入三叉或十字判定成功\n");
            printf("stateCounter:%d\n", stateCounter);
        }
        else if (topWhiteRangeNum >= 5)
        {
            stateCounter++;
        }
    }
    else if ((leftVaric>20 && rightVaric>50)||(leftVaric>50&&rightVaric>20)||(leftVaric>38&&rightVaric>38))//只有一个跳变，或者没有,但是两边弯的,底部竖直
    {
        if (edgeLineEnum & 0x40 || edgeLineEnum & 0x08)//延申方向不对肯定不是
        {
            stateCounter = 0;
            return;
        }
        uint8_t crossFlag = 0;
        if (leftEdge[75] != leftEdge[FAR_LINE] && rightEdge[75] != rightEdge[FAR_LINE])
        {
            //检查两边弯的方向
            float kLeft = ((float)75 - FAR_LINE) / ((float)leftEdge[75] - leftEdge[FAR_LINE]);
            float kRight = ((float)75 - FAR_LINE) / ((float)rightEdge[75] - rightEdge[FAR_LINE]);
            printf("kLeft:%f\n", kLeft);
            printf("kRight:%f\n", kRight);
            if (kLeft < 0.4 || kLeft>4.5 || kRight > -0.4 || kRight < -4.5)
            {
                if (edgeLineEnum & 0x80 && edgeLineEnum & 0x20 && edgeLineEnum & 0x04 && edgeLineEnum & 0x02)//找十字大跳变
                {
                    if (leftJumpPos < 25 || rightJumpPos < 25)
                    {
                        ;
                    }
                    else
                    {
                        uint8_t leftMaxVar = 0, rightMaxVar = 0;
                        for (uint8_t i = leftJumpPos; i > FAR_LINE; i--)
                        {
                            if (leftEdge[i - 1] < leftEdge[i])
                            {
                                uint8_t curVar = leftEdge[i] - leftEdge[i - 1];
                                if (curVar > leftMaxVar)
                                {
                                    leftMaxVar = curVar;
                                }
                            }
                        }
                        for (uint8_t i = rightJumpPos; i > FAR_LINE; i--)
                        {
                            if (rightEdge[i - 1] > rightEdge[i])
                            {
                                uint8_t curVar = rightEdge[i - 1] - rightEdge[i];
                                if (curVar > rightMaxVar)
                                {
                                    rightMaxVar = curVar;
                                }
                            }
                        }
                        if (leftMaxVar >= 35 && rightMaxVar >= 35)
                        {
                            stateCounter++;
                            crossFlag = 1;
                        }
                    }
                }
            }
            else if(kLeft >= 0.4 && kLeft<=4.5 && kRight <= -0.4 && kRight >= -4.5)
            {
                if (~supplyEdgeLineEnum & 0x20 && ~supplyEdgeLineEnum & 0x02)
                {
                    stateCounter++;
                }
            }
        }
        if (edgeLineEnum & 0x80 && TiltFeatureMgr.rightBreakPoint != MISS&&leftJumpPos>30)
        {
            //向下寻找折点具体位置
            uint8_t specificPos = MISS;
            for (uint8_t i = TiltFeatureMgr.rightBreakPoint; i < TiltFeatureMgr.rightBreakPoint + 40; i++)
            {
                if (rightEdge[i] < rightEdge[i + 6] && rightEdge[i + 6] - rightEdge[i]>1)
                {
                    specificPos = i;
                    break;
                }
            }
            printf("specificPos:%d\n", specificPos);
            if (abs(specificPos - leftJumpPos) <= 25)
            {
                //左边上面丢线，且有长白条
                uint8_t leftMissCount = 0,largeWhiteNum = 0;
                for (uint8_t i = leftJumpPos-5; i > FAR_LINE; i--)
                {
                    if (leftEdge[i] - left_side[i] < 2)
                    {
                        leftMissCount++;
                    }
                    uint8_t jEnd = my_road[i].white_num;
                    for (uint8_t j = 1; j <= jEnd; j++)
                    {
                        if (my_road[i].connected[j].width > 0.45*(right_side[i]-left_side[i]))
                        {
                            largeWhiteNum++;
                        }
                    }
                }
                printf("leftMiss:%d,largeWhite:%d\n", leftMissCount, largeWhiteNum);
                if (leftMissCount > 15 && largeWhiteNum > 15)
                {
                    stateCounter++;
                    crossFlag = 1;
                }
            }
        }
        if (edgeLineEnum & 0x04 && TiltFeatureMgr.leftBreakPoint != MISS && rightJumpPos > 30)
        {
            //向下寻找折点具体位置
            uint8_t specificPos = MISS;
            for (uint8_t i = TiltFeatureMgr.leftBreakPoint; i < TiltFeatureMgr.leftBreakPoint + 40; i++)
            {
                if (leftEdge[i] > leftEdge[i + 6] && leftEdge[i] - leftEdge[i + 6] >1)
                {
                    specificPos = i;
                    break;
                }
            }
            printf("specificPos:%d\n", specificPos);
            if (abs(specificPos - rightJumpPos) <= 25)
            {
                //左边上面丢线，且有长白条
                uint8_t rightMissCount = 0, largeWhiteNum = 0;
                for (uint8_t i = rightJumpPos-5; i > FAR_LINE; i--)
                {
                    if (right_side[i] - rightEdge[i] < 2)
                    {
                        rightMissCount++;
                    }
                    uint8_t jEnd = my_road[i].white_num;
                    for (uint8_t j = 1; j <= jEnd; j++)
                    {
                        if (my_road[i].connected[j].width > 0.45 * (right_side[i] - left_side[i]))
                        {
                            largeWhiteNum++;
                        }
                    }
                }
                printf("rightMiss:%d,largeWhite:%d\n", rightMissCount, largeWhiteNum);
                if (rightMissCount > 15 && largeWhiteNum > 15)
                {
                    stateCounter++;
                    crossFlag = 1;
                }
            }
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0001;
    }
}

////////////////////////////////////////////
//功能：判断是否为进三叉
//输入：
//输出：
//备注：比较正的情况
///////////////////////////////////////////

void image_TellIfLateEnterTrident(int16_t* ptrStateEnum)
{
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04 && TiltFeatureMgr.cuspLine != MISS && TiltFeatureMgr.cuspLine >= 23)
    {
        if (leftJumpPos > rightJumpPos)
        {
            uint8_t leftMissCount = 0;
            for (uint8_t i = leftJumpPos; i > TiltFeatureMgr.cuspLine; i--)
            {
                if (leftEdge[i] - left_side[i]<3)
                {
                    leftMissCount++;
                }
            }
            if (leftMissCount > 25)
            {

                uint8_t jCusp = image_GetWhiteIndex(_right, TiltFeatureMgr.cuspLine),jTop = image_GetWhiteIndex(_right, FAR_LINE);
                if (jCusp && jTop)
                {
                    uint8_t leftFir = my_road[TiltFeatureMgr.cuspLine].connected[jCusp].left;
                    uint8_t leftSec = my_road[FAR_LINE].connected[jTop].left;
                    uint8_t rightFir = rightEdge[rightJumpPos], rightY = rightJumpPos;
                    if (rightJumpPos < 30 && TiltFeatureMgr.rightBreakPoint != MISS)
                    {
                        rightFir = rightEdge[TiltFeatureMgr.rightBreakPoint];
                        rightY = TiltFeatureMgr.rightBreakPoint;
                    }
                    if (leftFir < leftSec && leftSec - leftFir>2 && abs(rightFir - rightEdge[FAR_LINE]) > 2)
                    {
                        float kLeft = (TiltFeatureMgr.cuspLine - FAR_LINE) / ((float)leftFir - leftSec);
                        float kRight = MISS, kRightB = MISS;
                        if (image_LeastSquare(&kRight, &kRightB, FAR_LINE, rightY, rightEdge))
                        {
                            ;
                        }
                        else
                        {
                            kRight = (rightY - FAR_LINE) / ((float)rightEdge[rightY] - rightEdge[FAR_LINE]);
                        }
                        printf("Kcusp:%f,kRight:%f\n", atan(kLeft), atan(kRight));
                        if (abs(atan(kLeft) - atan(kRight)) < 0.18)
                        {
                            *ptrStateEnum |= 0x4000;
                        }
                    }
                }
            }
        }
        else if (rightJumpPos > leftJumpPos)
        {
            uint8_t rightMissCount = 0;
            for (uint8_t i = rightJumpPos; i > TiltFeatureMgr.cuspLine; i--)
            {
                if (right_side[i]-rightEdge[i]< 3)
                {
                    rightMissCount++;
                }
            }
            if (rightMissCount > 25)
            {
                uint8_t jCusp = image_GetWhiteIndex(_left, TiltFeatureMgr.cuspLine), jTop = image_GetWhiteIndex(_left, FAR_LINE);
                if (jCusp && jTop)
                {
                    uint8_t leftFir = my_road[TiltFeatureMgr.cuspLine].connected[jCusp].right;
                    uint8_t leftSec = my_road[FAR_LINE].connected[jTop].right;
                    uint8_t rightFir = leftEdge[leftJumpPos], rightY = leftJumpPos;
                    if (leftJumpPos < 30 && TiltFeatureMgr.leftBreakPoint != MISS)
                    {
                        rightFir = leftEdge[TiltFeatureMgr.leftBreakPoint];
                        rightY = TiltFeatureMgr.leftBreakPoint;
                    }
                    if (leftFir > leftSec && leftFir - leftSec>2 && abs(rightFir - leftEdge[FAR_LINE]) > 2)
                    {
                        float kLeft = (TiltFeatureMgr.cuspLine - FAR_LINE) / ((float)leftFir - leftSec);
                        float kRight = MISS,kRightB = MISS;
                        if (image_LeastSquare(&kRight, &kRightB, FAR_LINE, rightY, leftEdge))
                        {
                            ;
                        }
                        else
                        {
                            kRight = (rightY - FAR_LINE) / ((float)rightFir - leftEdge[FAR_LINE]);
                        }
                        printf("Kcusp:%f,kRight:%f\n", atan(kLeft), atan(kRight));
                        if (abs(atan(kLeft) - atan(kRight)) < 0.18)
                        {
                            *ptrStateEnum |= 0x4000;
                        }
                    }
                }
            }
        }
    }
}

////////////////////////////////////////////
//功能：判断是否为斜入十字
//输入：
//输出：
//备注：
///////////////////////////////////////////

void image_TellIfRightTiltEnterCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //有三叉标志，清空十字状态机
    if (TiltFeatureMgr.tridentFlag == 1)
    {
        stateCounter = 0;
        return;
    }
    //若底部竖直肯定不是
    if (~supplyEdgeLineEnum & 0x20 && ~supplyEdgeLineEnum & 0x02 && TiltFeatureMgr.crossFlag == 0)
    {
        stateCounter = 0;
        return;
    }
    //右边丢线肯定不是
    uint8_t counter = 0;
    for (uint8_t i = 95; i >= 80; i--)
    {
        if (right_side[i] - rightEdge[i] < 4)
        {
            counter++;
        }
    }
    if (counter > 10)
    {
        stateCounter = 0;
        return;
    }
    //顶部黑条，弯道误判
    uint8_t blackCounter = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 25, 25);
    if (blackCounter > 10)
    {
        stateCounter = 0;
        return;
    }
    //看得到底部两个跳变点
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x20 && edgeLineEnum & 0x04 && edgeLineEnum & 0x02 && jumpPosVar > 10 && jumpPosVar < 60)
    {
        //该判据下理应不需出现尖点，若有可能是三叉，看平行情况
        if (TiltFeatureMgr.cuspLine != MISS)
        {
            uint8_t iStart = MISS, cuspLine = TiltFeatureMgr.cuspLine;
            for (uint8_t i = 100; i > 60; i--)
            {
                if (right_side[i] - rightEdge[i] > 3)
                {
                    iStart = i;
                    break;
                }
            }
            if (iStart != MISS)
            {
                float kRightDown = ((float)rightEdge[iStart] - rightEdge[iStart - 12]) / 12.0;
                uint8_t whiteIndexDown = image_GetWIndex(_left, cuspLine),whiteIndexUp = image_GetWIndex(_left, FAR_LINE + 3);
                if (whiteIndexUp && whiteIndexDown)
                {
                    float kTopLeft = ((float)my_road[cuspLine].connected[whiteIndexDown].right - my_road[FAR_LINE + 3].connected[whiteIndexUp].right) / ((float)cuspLine - FAR_LINE - 3);
                    printf("kRightDown:%f\nTopLeft:%f\n", kRightDown, kTopLeft);
                    float interAngle = abs(1 + kRightDown * kTopLeft) / ((sqrt(1 + kRightDown * kRightDown)) * (sqrt(1 + kTopLeft * kTopLeft)));
                    interAngle = acos(interAngle);
                    printf("interAngle:%f\n", interAngle);
                    if (interAngle > 0.52)
                    {
                        stateCounter = 0;
                        return;
                    }
                }
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        //顶部白条靠右，不是十字
        uint8_t triCounter = 0;
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i].connected[j].width > 35)
                {
                    if (my_road[i].connected[j].left > 40)
                    {
                        triCounter++;
                    }
                    break;
                }
            }
        }
        if (triCounter >= 5)
        {
            stateCounter = 0;
            return;
        }
        //统计左右跳变行白条平均长度
        uint16_t rightJumpWhiteWidth = 0, leftJumpWhiteWidth = 0;
        uint8_t counter = 0;
        for (uint8_t i = rightJumpPos; i < rightJumpPos + 5; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)//赛道偏左
            {
                if (my_road[i].connected[j].width > 15)
                {
                    rightJumpWhiteWidth += my_road[i].connected[j].width;
                    counter++;
                    break;
                }
            }
        }
        if (counter > 0)
        {
            rightJumpWhiteWidth /= counter, counter = 0;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        for (uint8_t i = leftJumpPos; i < leftJumpPos + 5; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)//赛道偏左
            {
                if (my_road[i].connected[j].width > 15)
                {
                    leftJumpWhiteWidth += my_road[i].connected[j].width;
                    counter++;
                    break;
                }
            }
        }
        if (counter > 0)
        {
            leftJumpWhiteWidth /= counter;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        if (rightJumpWhiteWidth > leftJumpWhiteWidth && rightJumpWhiteWidth - leftJumpWhiteWidth >= 10 && rightJumpWhiteWidth - leftJumpWhiteWidth < 35)
        {
            printf("底部两角斜入十字\n");
            stateCounter += 2;
        }
    }
    //看的到对角线的跳变点
    else if (edgeLineEnum & 0x40 && leftVaric > 32 && edgeLineEnum & 0x04 && rightVaric > 32 && TiltFeatureMgr.leftMissCount > 35 && TiltFeatureMgr.rightMissCount < 35)
    {
        if (TiltFeatureMgr.notTridentFlag == 1 || TiltFeatureMgr.crossFlag == 1)
        {
            if (rightJumpPos < 20)
            {
                stateCounter = 0;
                return;
            }
        }
        else
        {
            if (rightJumpPos < 30)
            {
                stateCounter = 0;
                return;
            }
        }
        //看顶部是否有大长白条
        uint8_t whiteNumCounter = 0;
        for (uint8_t i = FAR_LINE; i <= 30; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 90)
                {
                    whiteNumCounter++;
                    break;
                }
            }
        }
        if (whiteNumCounter <= 8&& TiltFeatureMgr.crossFlag != 1)
        {
            stateCounter = 0;
            return;
        }
        //对角跳变以上白条左线，和底部白条右线须有赛道宽度左右距离
        //统计左边平均位置
        uint16_t averTopWhiteLeft = 0, counter = 0;
        if (leftJumpPos > 12)
        {
            for (uint8_t i = leftJumpPos - 5; i > FAR_LINE + 5; i--)
            {
                for (uint8_t j = 1; j <= my_road[i].white_num; j++)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        averTopWhiteLeft += my_road[i].connected[j].left;
                        counter++;
                        break;
                    }
                }
            }
        }
        else
        {
            for (uint8_t i = leftJumpPos; i > FAR_LINE; i--)
            {
                for (uint8_t j = 1; j <= my_road[i].white_num; j++)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        averTopWhiteLeft += my_road[i].connected[j].left;
                        counter++;
                        break;
                    }
                }
            }
        }
        if (counter != 0)
        {
            averTopWhiteLeft /= counter;
            printf("averTopWhiteLeft:%d\n", averTopWhiteLeft);
        }
        else
        {
            stateCounter = 0;
            return;
        }
        uint16_t averDownRight = 0;
        if (TiltFeatureMgr.rightBreakPoint != MISS)
        {
            for (uint8_t i = TiltFeatureMgr.rightBreakPoint + 3; i < TiltFeatureMgr.rightBreakPoint + 18; i++)
            {
                averDownRight += rightEdge[i];
            }
            averDownRight /= 15;
            printf("averDownRight:%d\n", averDownRight);
        }
        else if (rightJumpPos <= 100)
        {
            for (uint8_t i = rightJumpPos + 3; i < rightJumpPos + 8; i++)
            {
                averDownRight += rightEdge[i];
            }
            averDownRight /= 5;
            printf("averDownRight:%d\n", averDownRight);
        }
        if (averTopWhiteLeft == 0 || averDownRight == 0)
        {
            stateCounter = 0;
            return;
        }
        if (averDownRight > averTopWhiteLeft && abs(averDownRight - averTopWhiteLeft) > 35 && abs(averDownRight - averTopWhiteLeft) < 105)
        {
            stateCounter++;
            printf("对角斜入十字\n");
        }
        else
        {
            stateCounter = 0;
            return;
        }
        if (TiltFeatureMgr.cuspLine != MISS)
        {
            stateCounter++;
            printf("对角斜入十字\n");
        }
    }
    //黑尖点加顶部赛道平行,补救标志不一样
    if (TiltFeatureMgr.cuspLine != MISS)
    {
        if (TiltFeatureMgr.rightMissCount < 30 && TiltFeatureMgr.leftMissCount>35 && TiltFeatureMgr.crossFlag == 1)
        {
            stateCounter++;
            if (edgeLineEnum & 0x04 && rightJumpPos > 60)
            {
                uint16_t jumpWhiteWidth = 0, cuspWhiteWidth = 0, counter = 0;
                for (uint8_t i = rightJumpPos; i < rightJumpPos + 3; i++)
                {
                    uint8_t jEnd = my_road[i].white_num;
                    for (uint8_t j = 1; j <= jEnd; j++)
                    {
                        uint8_t curWidth = my_road[i].connected[j].width;
                        if (curWidth > 15)
                        {
                            jumpWhiteWidth += curWidth;
                            counter++;
                            break;
                        }
                    }
                }
                if (counter != 0)
                {
                    jumpWhiteWidth /= counter, counter = 0;
                }
                else
                {
                    return;
                }
                for (uint8_t i = TiltFeatureMgr.cuspLine; i > TiltFeatureMgr.cuspLine - 3; i--)
                {
                    uint8_t jEnd = my_road[i].white_num;
                    for (uint8_t j = 1; j <= jEnd; j++)//赛道靠左
                    {
                        uint8_t curWidth = my_road[i].connected[j].width;
                        if (curWidth > 15)
                        {
                            cuspWhiteWidth += curWidth;
                            counter++;
                            break;
                        }
                    }
                }
                if (counter != 0)
                {
                    cuspWhiteWidth /= counter, counter = 0;
                }
                else
                {
                    return;
                }
                if (abs(jumpWhiteWidth - cuspWhiteWidth) < 15)
                {
                    stateCounter++;
                    printf("黑尖点斜入十字\n");
                }
            }
        }
    }
    //对角平行，延长看宽度
    if (TiltFeatureMgr.rightMissCount < 15 && TiltFeatureMgr.leftMissCount>28 && TiltFeatureMgr.notTridentFlag == 1)
    {
        if (edgeLineEnum & 0x80 && leftVaric > 60)
        {
            stateCounter++;
        }
        uint8_t point = MISS;
        if (TiltFeatureMgr.rightBreakPoint != MISS)
        {
            point = TiltFeatureMgr.rightBreakPoint;
        }
        else if (edgeLineEnum & 0x04 && rightJumpPos > 30)
        {
            point = rightJumpPos;
        }
        uint8_t extendiStart = MISS;
        if (point != MISS)
        {
            if (point == TiltFeatureMgr.rightBreakPoint)
            {
                for (uint8_t i = TiltFeatureMgr.rightBreakPoint; i < 90; i++)
                {
                    if (rightEdge[i + 4] > rightEdge[i] && rightEdge[i + 4] - rightEdge[i] > 1)
                    {
                        extendiStart = i;
                        break;
                    }
                }
            }
            else if (point == rightJumpPos)
            {
                extendiStart = point + 8;
            }
            if (extendiStart != MISS)
            {
                //printf("extendiStart:%d\n", extendiStart);
                float rightk = MISS, rightb = MISS;
                if (image_LeastSquare(&rightk, &rightb, extendiStart + 5, extendiStart + 15, rightEdge))
                {
                    //printf("rightk:%f,rightb:%f\n", rightk, rightb);
                    if (rightb == MISS)
                    {
                        rightb = extendiStart - rightk * rightEdge[extendiStart];
                    }
                    /*for (uint8_t i = extendiStart; i > FAR_LINE; i--)
                    {
                        uint8_t x = (i - rightb) / rightk;
                        IMG[i][x] = green;
                    }*/
                    float topWidth = rightEdge[FAR_LINE + 5] - (FAR_LINE + 5 - rightb) / rightk;
                    //printf("topWidth:%f\n", topWidth);
                    if (topWidth > 25)
                    {
                        uint8_t whiteNum = 0;
                        for (uint8_t i = FAR_LINE + 5; i < FAR_LINE + 25; i++)
                        {
                            float rightX = (i - rightb) / rightk;
                            if (rightX - leftEdge[i] > 35)
                            {
                                whiteNum++;
                            }
                        }
                        printf("whiteNum:%d\n", whiteNum);
                        if (whiteNum >= 15)
                        {
                            stateCounter++;
                            printf("延长斜入十字\n");
                        }
                        if (whiteNum < 5 && TiltFeatureMgr.crossFlag != 1)
                        {
                            stateCounter = 0;
                        }
                    }
                }
            }
        }
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0100;
    }
}

void image_TellIfLeftTiltEnterCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //有三叉标志，清空十字状态机
    if (TiltFeatureMgr.tridentFlag == 1)
    {
        stateCounter = 0;
        return;
    }
    //若底部竖直肯定不是
    if (~supplyEdgeLineEnum & 0x20 && ~supplyEdgeLineEnum & 0x02 && TiltFeatureMgr.crossFlag == 0)
    {
        stateCounter = 0;
        return;
    }
    //左边丢线肯定不是
    uint8_t counter = 0;
    for (uint8_t i = 95; i >= 80; i--)
    {
        if (leftEdge[i] - left_side[i] < 4)
        {
            counter++;
        }
    }
    if (counter > 10)
    {
        stateCounter = 0;
        return;
    }
    //顶部黑条，弯道误判
    uint8_t blackCounter = image_FindTopAbsBlackNum(FAR_LINE,FAR_LINE+25,25);
    if (blackCounter > 10)
    {
        stateCounter = 0;
        return;
    }
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x20 && edgeLineEnum & 0x04 && edgeLineEnum & 0x02 && jumpPosVar < -10 && jumpPosVar>-60)
    {
        //该判据下理应不需出现尖点，若有可能是三叉，看平行情况
        if (TiltFeatureMgr.cuspLine != MISS)
        {
            uint8_t iStart = MISS, cuspLine = TiltFeatureMgr.cuspLine;
            for (uint8_t i = 100; i > 60; i--)
            {
                if (leftEdge[i] - left_side[i] > 3)
                {
                    iStart = i;
                    break;
                }
            }
            if (iStart != MISS)
            {
                float kLeftDown = ((float)leftEdge[iStart] - leftEdge[iStart - 12]) / 12.0;
                uint8_t whiteIndexDown = image_GetWIndex(_right, cuspLine), whiteIndexUp = image_GetWIndex(_right, FAR_LINE + 3);
                if (whiteIndexUp && whiteIndexDown)
                {
                    float kTopRight = ((float)my_road[cuspLine].connected[whiteIndexDown].left - my_road[FAR_LINE + 3].connected[whiteIndexUp].left) / ((float)cuspLine - FAR_LINE - 3);
                    printf("kLeftDown:%f\nkTopRight:%f\n", kLeftDown, kTopRight);
                    float interAngle = abs(1 + kLeftDown * kTopRight) / ((sqrt(1 + kLeftDown * kLeftDown)) * (sqrt(1 + kTopRight * kTopRight)));
                    interAngle = acos(interAngle);
                    printf("interAngle:%f\n", interAngle);
                    if (interAngle > 0.52)
                    {
                        stateCounter = 0;
                        return;
                    }
                }
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        //顶部白条靠右，不是十字
        uint8_t triCounter = 0;
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 35)
                {
                    if (187-my_road[i].connected[j].right > 40)
                    {
                        triCounter++;
                    }
                    break;
                }
            }
        }
        if (triCounter >= 5)
        {
            stateCounter = 0;
            return;
        }
        //统计左右跳变行白条平均长度
        uint16_t rightJumpWhiteWidth = 0, leftJumpWhiteWidth = 0;
        uint8_t counter = 0;
        for (uint8_t i = rightJumpPos; i < rightJumpPos + 5; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)//赛道偏右
            {
                if (my_road[i].connected[j].width > 15)
                {
                    rightJumpWhiteWidth += my_road[i].connected[j].width;
                    counter++;
                    break;
                }
            }
        }
        if (counter > 0)
        {
            rightJumpWhiteWidth /= counter, counter = 0;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        for (uint8_t i = leftJumpPos; i < leftJumpPos + 5; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)//赛道偏右
            {
                if (my_road[i].connected[j].width > 15)
                {
                    leftJumpWhiteWidth += my_road[i].connected[j].width;
                    counter++;
                    break;
                }
            }
        }
        if (counter > 0)
        {
            leftJumpWhiteWidth /= counter;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        if (leftJumpWhiteWidth > rightJumpWhiteWidth && leftJumpWhiteWidth - rightJumpWhiteWidth >= 10 && leftJumpWhiteWidth - rightJumpWhiteWidth < 35)
        {
            stateCounter += 2;
        }
    }

    //只看的到对角的两个点
    else if (edgeLineEnum & 0x80 && leftVaric > 32 && edgeLineEnum & 0x08 && rightVaric > 32 && TiltFeatureMgr.rightMissCount > 35 && TiltFeatureMgr.leftMissCount < 35)
    {
        if (TiltFeatureMgr.notTridentFlag == 1 || TiltFeatureMgr.crossFlag == 1)
        {
            if (leftJumpPos < 20)
            {
                stateCounter = 0;
                return;
            }
        }
        else
        {
            if (leftJumpPos < 30)
            {
                stateCounter = 0;
                return;
            }
        }
        //看顶部是否有大长白条
        uint8_t whiteNumCounter = 0;
        for (uint8_t i = FAR_LINE; i <= 30; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 90)
                {
                    whiteNumCounter++;
                    break;
                }
            }
        }
        if (whiteNumCounter <= 8&&TiltFeatureMgr.crossFlag!=1)
        {
            stateCounter = 0;
            return;
        }
        //对角跳变以上白条右线，和底部白条左线须有赛道宽度左右距离
        //统计左边平均位置
        uint16_t averTopWhiteRight = 0, counter = 0;
        if (rightJumpPos > 12)
        {
            for (uint8_t i = rightJumpPos - 5; i > FAR_LINE + 5; i--)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        averTopWhiteRight += my_road[i].connected[j].right;
                        counter++;
                        break;
                    }
                }
            }
        }
        else
        {
            for (uint8_t i = rightJumpPos; i > FAR_LINE; i--)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        averTopWhiteRight += my_road[i].connected[j].right;
                        counter++;
                        break;
                    }
                }
            }
        }
        if (counter != 0)
        {
            averTopWhiteRight /= counter;
            printf("averTopWhiteRight:%d\n", averTopWhiteRight);
        }
        else
        {
            stateCounter = 0;
            return;
        }
        uint16_t averDownLeft = 0;
        if (TiltFeatureMgr.leftBreakPoint != MISS)
        {
            for (uint8_t i = TiltFeatureMgr.leftBreakPoint + 3; i < TiltFeatureMgr.leftBreakPoint + 18; i++)
            {
                averDownLeft += leftEdge[i];
            }
            averDownLeft /= 15;
            printf("averDownLeft:%d\n", averDownLeft);
        }
        else if (leftJumpPos <= 100)
        {
            for (uint8_t i = leftJumpPos + 3; i < leftJumpPos + 8; i++)
            {
                averDownLeft += leftEdge[i];
            }
            averDownLeft /= 5;
            printf("averDownLeft:%d\n", averDownLeft);
        }
        if (averDownLeft == 0 || averTopWhiteRight == 0)
        {
            stateCounter = 0;
            return;
        }
        if (averTopWhiteRight > averDownLeft && abs(averTopWhiteRight - averDownLeft) > 35 && abs(averTopWhiteRight - averDownLeft) < 105)
        {
            stateCounter++;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        if (TiltFeatureMgr.cuspLine != MISS)
        {
            stateCounter++;
        }
    }
    //黑尖点加顶部赛道平行,//统计顶部与下方赛道宽度
    if (TiltFeatureMgr.cuspLine != MISS)
    {
        if (TiltFeatureMgr.leftMissCount < 30 && TiltFeatureMgr.rightMissCount>35 && TiltFeatureMgr.crossFlag == 1)
        {
            stateCounter++;
            if (edgeLineEnum & 0x80 && leftJumpPos > 60)
            {
                uint16_t jumpWhiteWidth = 0, cuspWhiteWidth = 0, counter = 0;
                for (uint8_t i = leftJumpPos; i < leftJumpPos + 3; i++)
                {
                    uint8_t jEnd = my_road[i].white_num;
                    for (uint8_t j = 1; j <= jEnd; j++)
                    {
                        uint8_t curWidth = my_road[i].connected[j].width;
                        if (curWidth > 15)
                        {
                            jumpWhiteWidth += curWidth;
                            counter++;
                            break;
                        }
                    }
                }
                if (counter != 0)
                {
                    jumpWhiteWidth /= counter, counter = 0;
                }
                else
                {
                    return;
                }
                for (uint8_t i = TiltFeatureMgr.cuspLine; i > TiltFeatureMgr.cuspLine - 3; i--)
                {
                    uint8_t jEnd = my_road[i].white_num;
                    for (uint8_t j = jEnd; j >= 1; j--)//赛道靠右
                    {
                        uint8_t curWidth = my_road[i].connected[j].width;
                        if (curWidth > 15)
                        {
                            cuspWhiteWidth += curWidth;
                            counter++;
                            break;
                        }
                    }
                }
                if (counter != 0)
                {
                    cuspWhiteWidth /= counter, counter = 0;
                }
                else
                {
                    return;
                }
                if (abs(jumpWhiteWidth - cuspWhiteWidth) < 15)
                {
                    stateCounter++;
                }
            }
        }
    }
    //对角平行，延长看宽度
    if (TiltFeatureMgr.leftMissCount < 15 && TiltFeatureMgr.rightMissCount>35 && TiltFeatureMgr.notTridentFlag == 1)
    {
        if (edgeLineEnum & 0x04 && rightVaric)
        {
            stateCounter++;
        }
        uint8_t point = MISS;
        if (TiltFeatureMgr.leftBreakPoint != MISS)
        {
            point = TiltFeatureMgr.leftBreakPoint;
        }
        else if (edgeLineEnum & 0x80 && leftJumpPos > 30)
        {
            point = leftJumpPos;
        }
        if (point != MISS)
        {
            uint8_t extendiStart = MISS;
            if (point == TiltFeatureMgr.leftBreakPoint)
            {
                for (uint8_t i = point; i < 90; i++)
                {
                    if (leftEdge[i + 4] < leftEdge[i] && leftEdge[i] - leftEdge[i + 4] > 1)
                    {
                        extendiStart = i;
                        break;
                    }
                }
            }
            else if (point == leftJumpPos)
            {
                extendiStart = point + 8;
            }
            //printf("extendiStart:%d\n", extendiStart);
            if (extendiStart != MISS)
            {
                float leftk = MISS, leftb = MISS;
                if (image_LeastSquare(&leftk, &leftb, extendiStart + 5, extendiStart + 15, leftEdge))
                {
                    //printf("rightk:%f,rightb:%f\n", rightk, rightb);
                    if (leftb == MISS)
                    {
                        leftb = extendiStart - leftk * leftEdge[extendiStart];
                    }
                    /*for (uint8_t i = extendiStart; i > FAR_LINE; i--)
                    {
                        uint8_t x = (i - leftb) / leftk;
                        IMG[i][x] = green;
                    }*/
                    float topWhiteWidth = (FAR_LINE + 5 - leftb) / leftk - leftEdge[FAR_LINE + 5];
                    //printf("topWidth:%f\n", topWhiteWidth);
                    if (topWhiteWidth > 25)
                    {
                        uint8_t whiteNum = 0;
                        for (uint8_t i = FAR_LINE + 5; i < FAR_LINE + 25; i++)
                        {
                            float leftX = (i - leftb) / leftk;
                            if (rightEdge[i] - leftX > 35)
                            {
                                whiteNum++;
                            }
                        }
                        if (whiteNum >= 15)
                        {
                            stateCounter++;
                        }
                        if (whiteNum < 5 && TiltFeatureMgr.crossFlag != 1)
                        {
                            stateCounter = 0;
                        }
                    }
                }
            }
        }
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0100;
    }
}

////////////////////////////////////////////
//功能：判断是否位小角度进十字
//输入：
//输出：
//备注：
///////////////////////////////////////////

void image_TellIfSlightLeftTiltEnterCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE + 3, FAR_LINE + 18, 15);
    if (blackNum >= 5)
    {
        stateCounter = 0;
        return;
    }
    //左边左延申，底部竖直，右边丢失信息，检查有无十字标志
    if (edgeLineEnum & 0x80 && ~supplyEdgeLineEnum & 0x20 && ~edgeLineEnum & 0x01 && leftJumpPos > 40)
    {
        //检查顶部是否有长白条
        uint8_t largeWhiteNum = 0;
        for (uint8_t i = FAR_LINE + 3; i < FAR_LINE + 23; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 110)
                {
                    largeWhiteNum++;
                    break;
                }
            }
        }
        if (largeWhiteNum < 15)
        {
            stateCounter = 0;
            return;
        }
        uint8_t maxJumpVar = 0;
        for (uint8_t i = leftJumpPos; i > FAR_LINE; i--)
        {
            if (leftEdge[i] > leftEdge[i - 1])
            {
                uint8_t curVar = leftEdge[i] - leftEdge[i - 1];
                if (curVar > maxJumpVar)
                {
                    maxJumpVar = curVar;
                }
            }
        }
        printf("maxJumpVar:%d\n", maxJumpVar);
        if (maxJumpVar > 45)
        {
            stateCounter += 2;
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0010;
    }
}


void image_TellIfSlightRightTiltEnterCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE + 3, FAR_LINE + 18, 15);
    if (blackNum >= 5)
    {
        stateCounter = 0;
        return;
    }
    //右边右延申，底部竖直，左边丢失信息，检查有无十字标志
    if (edgeLineEnum & 0x04 && ~supplyEdgeLineEnum & 0x02 && ~edgeLineEnum & 0x10 && rightJumpPos > 40)
    {
        //检查顶部是否有长白条
        uint8_t largeWhiteNum = 0;
        for (uint8_t i = FAR_LINE + 3; i < FAR_LINE + 23; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 110)
                {
                    largeWhiteNum++;
                    break;
                }
            }
        }
        if (largeWhiteNum < 15)
        {
            stateCounter = 0;
            return;
        }
        uint8_t maxJumpVar = 0;
        for (uint8_t i = rightJumpPos; i > FAR_LINE; i--)
        {
            if (rightEdge[i - 1] > rightEdge[i])
            {
                uint8_t curVar = rightEdge[i - 1] - rightEdge[i];
                if (curVar > maxJumpVar)
                {
                    maxJumpVar = curVar;
                }
            }
        }
        printf("maxJumpVar:%d\n", maxJumpVar);
        if (maxJumpVar > 45)
        {
            stateCounter += 2;
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0010;
    }
}

////////////////////////////////////////////
//功能：判断是否为十字误判
//输入：
//输出：
//备注：
///////////////////////////////////////////

void image_TellIfMissJudgeTiltCross(int16_t* ptrStateEnum)
{
    if (TiltFeatureMgr.leftMissCount > 50 && TiltFeatureMgr.rightMissCount > 50 && TiltFeatureMgr.cuspLine != MISS)
    {
        if (~edgeLineEnum & 0x10 && ~edgeLineEnum & 0x01)
        {
            if (TiltFeatureMgr.cuspLine > 25)
            {
                *ptrStateEnum |= 0x0002;
                return;
            }
        }
        uint8_t leftMissCount = 0, rightMissCount = 0;
        for (uint8_t i = FAR_LINE + 10; i < FAR_LINE + 50; i++)
        {
            if (leftEdge[i] - left_side[i] < 4)
            {
                leftMissCount++;
            }
            if (right_side[i] - rightEdge[i] < 4)
            {
                rightMissCount++;
            }
        }
        if (leftMissCount > 32 && rightMissCount > 32)
        {
            if (TiltFeatureMgr.cuspLine > 25)
            {
                *ptrStateEnum |= 0x0002;
                return;
            }
        }
    }
}

////////////////////////////////////////////
//功能：判断是否为进三叉
//输入：
//输出：
//备注：能否正进入三叉1阶段 ,看阶梯效应
///////////////////////////////////////////

void image_TellIfEnterTrident(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (TiltFeatureMgr.leftMissCount > 25 && TiltFeatureMgr.rightMissCount > 25)
    {
        stateCounter = 0;
        return;
    }
    if (TiltFeatureMgr.leftMissCount > 40 || TiltFeatureMgr.rightMissCount > 40)
    {
        stateCounter = 0;
        return;
    }
    //右顶部和左顶部丢线较多也不可能是三叉
    uint8_t topLeftMissCount = 0, topRightMissCount = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 40; i++)
    {
        if (leftEdge[i] - left_side[i] < 4)
        {
            topLeftMissCount++;
        }
        if (right_side[i] - rightEdge[i] < 4)
        {
            topRightMissCount++;
        }
    }
    printf("topLeftMissCount:%d\ntopRightMissCount:%d\n", topLeftMissCount, topRightMissCount);
    if (topLeftMissCount > 30 || topRightMissCount > 30)
    {
        stateCounter = 0;
        return;
    }
    topLeftMissCount = 0,topRightMissCount = 0;
    if (edgeLineEnum & 0x80 && leftJumpPos > 45)
    {
        for (uint8_t i = leftJumpPos; i > leftJumpPos-25; i--)
        {
            if (leftEdge[i] - left_side[i] < 4)
            {
                topLeftMissCount++;
            }
        }
    }
    if (edgeLineEnum & 0x04 && rightJumpPos > 45)
    {
        for (uint8_t i = rightJumpPos; i > rightJumpPos - 25; i--)
        {
            if (right_side[i] - rightEdge[i] < 4)
            {
                topRightMissCount++;
            }
        }
    }
    if (topLeftMissCount > 15 || topRightMissCount > 15)
    {
        stateCounter = 0;
        return;
    }
    uint8_t rightMaxVar = 0, leftMaxVar = 0, antiLeftVar = 0, antiRightVar = 0;
    for (uint8_t i = 95; i > FAR_LINE + 15; i--)
    {
        uint8_t curVar = 0;
        if (rightEdge[i - 3] > rightEdge[i])
        {
            curVar = rightEdge[i - 3] - rightEdge[i];
        }
        else if (i<50&&rightEdge[i] - rightEdge[i - 3] > 2)
        {
            antiRightVar++;
        }
        if (curVar > rightMaxVar)
        {
            rightMaxVar = curVar;
        }
    }
    printf("rightMaxVar:%d,anti:%d\n", rightMaxVar,antiRightVar);
    for (uint8_t i = 95; i > FAR_LINE + 15; i--)
    {
        uint8_t curVar = 0;
        if (leftEdge[i] > leftEdge[i - 3])
        {
            curVar = leftEdge[i] - leftEdge[i - 3];
        }
        else if(i<50&&leftEdge[i-3]-leftEdge[i]>2)
        {
            antiLeftVar++;
        }
        if (curVar > leftMaxVar)
        {
            leftMaxVar = curVar;
        }
    }
    printf("leftMaxVar:%d,anti:%d\n", leftMaxVar,antiLeftVar);
    if (antiLeftVar > 7 || antiRightVar > 7)
    {
        stateCounter = 0;
        return;
    }
    if (leftMaxVar > 30 || rightMaxVar > 30)
    {
        stateCounter = 0;
        return;
    }
    if (leftMaxVar < 25 && rightMaxVar < 25)
    {
        uint8_t averVar = leftMaxVar / 2 + rightMaxVar / 2;
        if (averVar <= 20)
        {
            stateCounter++;
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x4000;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为进三叉
//输入：
//输出：
//备注：能否进入三叉2阶段
///////////////////////////////////////////
uint8_t image_TellIfEnterTridentStage2(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t middleBlackRangeNum = 0, ifGetBlackRange = 0,missCacuPos = MISS;
    uint8_t crossFlag = 0;
    if (leftJumpPos != MISS && rightJumpPos != MISS && (edgeLineEnum & 0x80 || edgeLineEnum & 0x04))
    {
        if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04)
        {
            missCacuPos = leftJumpPos < rightJumpPos ? leftJumpPos : rightJumpPos;
        }
        else if (edgeLineEnum & 0x80)
        {
            missCacuPos = leftJumpPos;
        }
        else if (edgeLineEnum & 0x04)
        {
            missCacuPos = rightJumpPos;
        }
    }
    else if (leftJumpPos != MISS && edgeLineEnum & 0x80)
    {
        missCacuPos = leftJumpPos;
    }
    else if (rightJumpPos != MISS && edgeLineEnum & 0x04)
    {
        missCacuPos = rightJumpPos;
    }
    //计算跳变点以上缺线
    uint8_t leftMissCount = 0, rightMissCount = 0;
    if (missCacuPos > 60 && missCacuPos != MISS)
    {
        for (uint8_t i = missCacuPos; i > missCacuPos - 40; i--)
        {
            if (leftEdge[i] - left_side[i] < 3)
            {
                leftMissCount++;
            }
            if (right_side[i] - rightEdge[i] < 3)
            {
                rightMissCount++;
            }
        }
    }
    if (leftMissCount > 20 && rightMissCount > 20)
    {
        stateCounter = 0;
        return ifGetBlackRange;
    }
    //如果有大跳变，90°可能性更大
    if (edgeLineEnum & 0x80 && leftJumpPos > 40)
    {
        if (leftEdge[leftJumpPos - 10] < leftEdge[leftJumpPos] && leftEdge[leftJumpPos] - leftEdge[leftJumpPos - 10] > 35)
        {
            crossFlag = 1;
        }
    }
    if (edgeLineEnum & 0x04 && rightJumpPos > 40)
    {
        if (rightEdge[rightJumpPos - 10] > rightEdge[rightJumpPos] && rightEdge[rightJumpPos - 10] - rightEdge[rightJumpPos] > 35)
        {
            crossFlag = 1;
        }
    }
    if (crossFlag == 1)
    {
        stateCounter = 0;
        return ifGetBlackRange;
    }
    //统计顶上黑条平均位置
    for (uint8_t i = FAR_LINE; i < 50; i++)
    {
        if (image_TellRealWhiteNum(i) == 2)
        {
            uint8_t whiteIndexLeft = MISS,whiteIndexRight = MISS,jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width >= 20)
                {
                    whiteIndexLeft = j;
                    break;
                }
            }
            for (uint8_t j = jEnd; j >=1; j--)
            {
                if (my_road[i].connected[j].width >= 20)
                {
                    whiteIndexRight = j;
                    break;
                }
            }
            if (whiteIndexLeft && whiteIndexRight&&whiteIndexLeft!=whiteIndexRight)
            {
                uint8_t blackLeft = my_road[i].connected[whiteIndexLeft].right;
                uint8_t blackRight = my_road[i].connected[whiteIndexRight].left;
                uint8_t blackMiddle = blackLeft / 2 + blackRight / 2;
                if (i < 20)
                {
                    if (blackMiddle <= 140 && blackMiddle >= 48 && (blackRight - blackLeft) >= 10)
                    {
                        middleBlackRangeNum++;
                    }
                }
                else
                {
                    if (blackMiddle <= 140 && blackMiddle >= 48 && (blackRight - blackLeft) >= 6)
                    {
                        middleBlackRangeNum++;
                    }
                }
            }
        }
    }
    printf("middleBlackRangeNum:%d\n", middleBlackRangeNum);
    if (middleBlackRangeNum > 0)
    {
        ifGetBlackRange = 1;
    }
    if (middleBlackRangeNum >= 5)
    {
        stateCounter++;
        printf("三叉2阶段判断成功\n");
    }
    else//如不够准确 试试算黑线边线斜率？
    {
        ;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0002;
    }
    return ifGetBlackRange;
}

////////////////////////////////////////////
//功能：判断是否为斜进三叉
//输入：
//输出：
//备注：能否进入三叉2阶段
///////////////////////////////////////////

uint8_t image_TellIfLeftTiltEnterTrident(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t tridentFlag = 0;
    //有十字标志清空状态机参数
    if (TiltFeatureMgr.notTridentFlag == 1 || TiltFeatureMgr.crossFlag == 1)
    {
        stateCounter = 0;
        return tridentFlag;
    }
    //顶部没有赛道肯定不是
    uint8_t blackNum = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            blackNum++;
        }
        else
        {
            //寻找最长白条
            uint8_t maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > maxWidth)
                {
                    maxWidth = curWidth;
                }
            }
            if (maxWidth <= 12)
            {
                blackNum++;
            }
        }
    }
    if (blackNum > 10)
    {
        stateCounter = 0;
        return tridentFlag;
    }
    //尖点与底部竖直
    if (TiltFeatureMgr.rightMissCount >= 25 &&TiltFeatureMgr.rightMissCount<55 &&TiltFeatureMgr.leftMissCount < 10 && TiltFeatureMgr.cuspLine != MISS)
    {
        if (TiltFeatureMgr.leftBreakPoint != MISS && edgeLineEnum & 0x04)
        {
            if (TiltFeatureMgr.leftBreakPoint<rightJumpPos&&abs(TiltFeatureMgr.leftBreakPoint - rightJumpPos) < 20)
            {
                uint8_t rightTopMissCount = 0;
                for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
                {
                    if (right_side[i] - rightEdge[i] < 2)
                    {
                        rightTopMissCount++;
                    }
                }
                if (rightTopMissCount > 20)
                {
                    stateCounter++;
                    printf("斜入三叉成功\n");
                }
            }
        }
    }
    else if (TiltFeatureMgr.rightMissCount > 32 && TiltFeatureMgr.leftMissCount < 10)//左斜入
    {
        uint8_t triRightJumpPos = MISS;
        for (uint8_t i = 85; i > 10; i--)
        {
            if (rightEdge[i] > leftEdge[i - 1] && rightEdge[i] - rightEdge[i - 1] > 15)
            {
                if (rightEdge[i - 2] <= rightEdge[i - 1])
                {
                    triRightJumpPos = i;
                    break;
                }
            }
        }
        printf("triRightJumpPos:%d\n", triRightJumpPos);
        if (triRightJumpPos < 15)
        {
            stateCounter = 0;
            return tridentFlag;
        }
        //左线延长，看有无赛道
        if (TiltFeatureMgr.leftBreakPoint != MISS)
        {
            uint8_t topRightBlackCount = 0, topSmallWidthCount = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
            {
                uint8_t whiteIndex = image_GetWIndex(_right, i);
                if (whiteIndex&&187 - my_road[i].connected[whiteIndex].right > 22)
                {
                    topRightBlackCount++;
                }
            }
            //printf("topRightBlackCount:%d\n", topRightBlackCount);
            if (topRightBlackCount < 5 && TiltFeatureMgr.cuspLine == MISS)//加尖点
            {
                stateCounter = 0;
                return tridentFlag;
            }
            //右线起始太低，中间没丢线，应该是弯道
            uint8_t rightDown = MISS;
            for (uint8_t i = 70; i > FAR_LINE; i--)
            {
                if (right_side[i] - rightEdge[i]>2)
                {
                    rightDown = i;
                    break;
                }
            }
            if (rightDown!=MISS&&rightDown > 60)
            {
                uint8_t rightMissCount = 0;
                for (uint8_t i = rightDown; i > rightDown - 30; i--)
                {
                    if (abs(right_side[i] - rightEdge[i]) < 3)
                    {
                        rightMissCount++;
                    }
                }
                if (rightMissCount < 5)
                {
                    stateCounter = 0;
                    return tridentFlag;
                }
            }
            if (rightDown != MISS&&rightDown>40)
            {
                //右线直，肯定不是
                float rightJudgeVaric = 0;
                image_LineIfStraight(rightEdge, FAR_LINE, rightDown, &rightJudgeVaric);
                printf("rightJudgeVaric:%f\n", rightJudgeVaric);
                if (rightJudgeVaric < 10)
                {
                    stateCounter = 0;
                    return tridentFlag;
                }
            }
            uint8_t extendiStart = MISS;
            for (uint8_t i = TiltFeatureMgr.leftBreakPoint; i < 90; i++)
            {
                if (leftEdge[i] > leftEdge[i + 6] && leftEdge[i] - leftEdge[i + 6] > 2)
                {
                    extendiStart = i;
                    break;
                }
            }
            //printf("extendiStart:%d\n", extendiStart);
            if (rightDown!=MISS&&extendiStart != MISS && extendiStart - TiltFeatureMgr.leftBreakPoint < 35)
            {
                float leftk = MISS, leftb = MISS;
                if (image_LeastSquare(&leftk, &leftb, extendiStart + 5, extendiStart + 15, leftEdge))
                {
                    //printf("leftk:%f,leftb:%f\n", leftk, leftb);
                    if (leftk != MISS && leftb == MISS)
                    {
                        leftb = extendiStart + 5 - leftk * leftEdge[extendiStart + 5];
                    }
                    /*for (uint8_t i = extendiStart; i > FAR_LINE; i--)
                    {
                        uint8_t x = (i - leftb) / leftk;
                        IMG[i][x] = green;
                    }*/
                    float averOverLapWidth = 0;
                    for (uint8_t i = FAR_LINE; i < FAR_LINE + 30; i++)
                    {
                        float leftx = (i - leftb) / leftk;
                        uint8_t whiteIndex = image_GetWIndex(_right, i);
                        if (whiteIndex && 187 - leftx > 20 && 187 - (float)my_road[i].connected[whiteIndex].right > 20)//左斜入，太靠右的信息不行
                        {
                            averOverLapWidth = (float)my_road[i].connected[image_GetWIndex(_right, i)].right - (float)leftx;
                            if (averOverLapWidth <= 5.5)
                            {
                                topSmallWidthCount+=2;
                                printf("%d OveLap:%f\n", i, averOverLapWidth);
                            }
                            else if(averOverLapWidth<=23)
                            {
                                topSmallWidthCount++;
                                printf("%d OveLap:%f\n", i, averOverLapWidth);
                            }
                        }
                    }
                    if (topSmallWidthCount >= 15)
                    {
                        stateCounter += 2;
                        tridentFlag = 1;
                    }
                    else if (topSmallWidthCount >= 8)
                    {
                        stateCounter++;
                        tridentFlag = 1;
                    }
                }
            }
        }
        else//保护
        {
            stateCounter = 0;
            return tridentFlag;
        }
        if (triRightJumpPos != MISS && triRightJumpPos > 15)
        {
            //此判据下顶部有长白条肯定不是
            uint8_t whiteNum = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 105)
                    {
                        whiteNum++;
                    }
                }
            }
            if (whiteNum < 5)
            {
                IMG[triRightJumpPos][rightEdge[triRightJumpPos]] = green;
                if ((float)rightEdge[triRightJumpPos - 8] != rightEdge[FAR_LINE + 2])
                {
                    float rightK = (triRightJumpPos - 8 - FAR_LINE - 2) / ((float)rightEdge[triRightJumpPos - 8] - rightEdge[FAR_LINE + 2]);
                    printf("rightK:%f\n", rightK);
                    if (TiltFeatureMgr.leftBreakPoint == MISS)
                    {
                        stateCounter = 0;
                        return tridentFlag;
                    }
                    uint8_t iTop = FAR_LINE + 10;
                    for (uint8_t i = FAR_LINE + 10; i < FAR_LINE + 50; i++)
                    {
                        if (leftEdge[i] - left_side[i] > 15)
                        {
                            iTop = i;
                            break;
                        }
                    }
                    float leftK = (TiltFeatureMgr.leftBreakPoint - 5 - iTop) / ((float)leftEdge[TiltFeatureMgr.leftBreakPoint - 5] - leftEdge[iTop]);
                    printf("leftK:%f\n", leftK);
                    if (abs(leftK - rightK) < 1.2)
                    {
                        stateCounter++;
                        printf("斜入三叉成功\n");
                        tridentFlag = 1;
                    }
                }
            }
        }
    }
    if (edgeLineEnum & 0x04 && TiltFeatureMgr.leftBreakPoint != MISS && rightJumpPos > 35 && ~edgeLineEnum & 0x80)
    {
        //顶部有长白条不是
        uint8_t largeWhiteNum = 0, cuspBlack = 0;
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i].connected[j].width > 90)
                {
                    largeWhiteNum++;
                    break;
                }
            }
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 25)
                {
                    if (187-my_road[i].connected[j].right > 30)
                    {
                        cuspBlack++;
                        break;
                    }
                }
            }
        }
        if (largeWhiteNum < 5)
        {
            //向下寻找折点具体位置
            uint8_t specificPos = MISS;
            for (uint8_t i = TiltFeatureMgr.leftBreakPoint; i < TiltFeatureMgr.leftBreakPoint + 40; i++)
            {
                if (leftEdge[i] > leftEdge[i + 6] && leftEdge[i] - leftEdge[i + 6] > 1)
                {
                    specificPos = i;
                    break;
                }
            }
            printf("specificPos:%d\n", specificPos);
            if (abs(specificPos - rightJumpPos) <= 32 || specificPos < 15)
            {
                //右边上面丢线，且有长白条
                uint8_t rightMissCount = 0, largeWhiteNum = 0;
                for (uint8_t i = rightJumpPos - 5; i > rightJumpPos - 35; i--)
                {
                    if (right_side[i]-rightEdge[i] < 2)
                    {
                        rightMissCount++;
                    }
                }
                printf("rightMiss:%d,cuspBlack:%d\n", rightMissCount, cuspBlack);
                if (rightMissCount > 15 && cuspBlack > 10)
                {
                    stateCounter+=2;
                    printf("斜入三叉成功\n");
                    tridentFlag = 1;
                }
            }
        }

    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x2000;
        stateCounter = 0;
    }
    return tridentFlag;
}

uint8_t image_TellIfRightTiltEnterTrident(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t tridentFlag = 0;
    //有十字标志清空状态机参数
    if (TiltFeatureMgr.notTridentFlag == 1 || TiltFeatureMgr.crossFlag == 1)
    {
        stateCounter = 0;
        return tridentFlag;
    }
    //顶部没有赛道肯定不是
    uint8_t blackNum = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            blackNum++;
        }
        else
        {
            //寻找最长白条
            uint8_t maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > maxWidth)
                {
                    maxWidth = curWidth;
                }
            }
            if (maxWidth <= 12)
            {
                blackNum++;
            }
        }
    }
    if (blackNum > 10)
    {
        stateCounter = 0;
        return tridentFlag;
    }
    if (TiltFeatureMgr.leftMissCount >= 25 &&TiltFeatureMgr.leftMissCount<55 && TiltFeatureMgr.rightMissCount < 10 && TiltFeatureMgr.cuspLine != MISS)
    {
        //if (~supplyEdgeLineEnum & 0x02)//右底部竖直
        //{
        //	stateCounter++;
        //}
        //else
        //{
        //	stateCounter = 0;
        //}
        if (TiltFeatureMgr.rightBreakPoint != MISS && edgeLineEnum & 0x80)
        {
            if (leftJumpPos>TiltFeatureMgr.rightBreakPoint&&abs(TiltFeatureMgr.rightBreakPoint - leftJumpPos) < 20)
            {
                uint8_t leftTopMissCount = 0;
                for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
                {
                    if (leftEdge[i]-left_side[i] < 2)
                    {
                        leftTopMissCount++;
                    }
                }
                if (leftTopMissCount > 20)
                {
                    stateCounter++;
                    printf("斜入三叉成功\n");
                }
            }
        }
    }
    else if (TiltFeatureMgr.leftMissCount >= 32 && TiltFeatureMgr.rightMissCount < 10)//右斜入
    {
        uint8_t triLeftJumpPos = MISS;
        for (uint8_t i = 85; i > 10; i--)
        {
            if (leftEdge[i - 1] > leftEdge[i] && leftEdge[i - 1] - leftEdge[i] > 15)
            {
                if (leftEdge[i - 2] >= leftEdge[i - 1])
                {
                    triLeftJumpPos = i;
                    break;
                }
            }
        }
        printf("triLeftJumpPos:%d\n", triLeftJumpPos);
        if (triLeftJumpPos < 15)
        {
            stateCounter = 0;
            return tridentFlag;
        }
        //右线延长，看有无赛道
        if (TiltFeatureMgr.rightBreakPoint != MISS)
        {
            uint8_t topLeftBlackCount = 0, topSmallWidthCount = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 25; i++)
            {
                uint8_t whiteIndex = image_GetWIndex(_left, i);
                if (whiteIndex&&my_road[i].connected[whiteIndex].left > 22)
                {
                    topLeftBlackCount++;
                }
            }
            //printf("topLeftBlackCount:%d\n", topLeftBlackCount);
            if (topLeftBlackCount < 5 && TiltFeatureMgr.cuspLine == MISS)//加尖点
            {
                stateCounter = 0;
                return tridentFlag;
            }
            //左线起始太低，中间没丢线，应该是弯道
            uint8_t leftDown = MISS;
            for (uint8_t i = 70; i > FAR_LINE; i--)
            {
                if (leftEdge[i] - left_side[i]>2)
                {
                    leftDown = i;
                    break;
                }
            }
            if (leftDown!=MISS&&leftDown > 60)
            {
                uint8_t leftMissCount = 0;
                for (uint8_t i = leftDown; i > leftDown - 30; i--)
                {
                    if (abs(leftEdge[i] - left_side[i]) < 3)
                    {
                        leftMissCount++;
                    }
                }
                if (leftMissCount < 5)
                {
                    stateCounter = 0;
                    return tridentFlag;
                }
            }
            if (leftDown != MISS&&leftDown>40)
            {
                //左线直，肯定不是
                float leftJudgeVaric = 0;
                image_LineIfStraight(leftEdge, FAR_LINE, leftDown, &leftJudgeVaric);
                printf("leftJudgeVaric:%f\n", leftJudgeVaric);
                if (leftJudgeVaric < 10)
                {
                    stateCounter = 0;
                    return tridentFlag;
                }
            }
            uint8_t extendiStart = MISS;
            for (uint8_t i = TiltFeatureMgr.rightBreakPoint; i < 90; i++)
            {
                if (rightEdge[i + 6] > rightEdge[i] && rightEdge[i + 6] - rightEdge[i] > 2)
                {
                    extendiStart = i;
                    break;
                }
            }
            //printf("extendiStart:%d\n", extendiStart);
            if (leftDown!=MISS&&extendiStart != MISS && extendiStart - TiltFeatureMgr.rightBreakPoint < 35)
            {
                float rightk = MISS, rightb = MISS;
                if (image_LeastSquare(&rightk, &rightb, extendiStart + 5, extendiStart + 15, rightEdge))
                {
                    //printf("rightk:%f,rightb:%f\n", rightk, rightb);
                    if (rightk!=MISS&&rightb == MISS)
                    {
                        rightb = extendiStart + 5 - rightk * rightEdge[extendiStart + 5];
                    }
                for (uint8_t i = extendiStart; i > FAR_LINE; i--)
                {
                    uint8_t x = (i - rightb) / rightk;
                    IMG[i][x] = green;
                }
                    float averOverLapWidth = 0;
                    for (uint8_t i = FAR_LINE; i < FAR_LINE + 30; i++)
                    {
                        float rightx = (i - rightb) / rightk;
                        uint8_t whiteIndex = image_GetWIndex(_left, i);
                        if (whiteIndex&&rightx > 20 && my_road[i].connected[whiteIndex].left > 20)
                        {
                            averOverLapWidth = rightx - (float)my_road[i].connected[image_GetWIndex(_left, i)].left;
                            if (averOverLapWidth <= 5.5)
                            {
                                topSmallWidthCount+=2;
                                printf("%d OveLap:%f\n", i, averOverLapWidth);
                            }
                            else if(averOverLapWidth<=23)
                            {
                                topSmallWidthCount++;
                                printf("%d OveLap:%f\n", i, averOverLapWidth);
                            }
                        }
                    }
                    if (topSmallWidthCount >= 15)
                    {
                        stateCounter += 2;
                        tridentFlag = 1;
                    }
                    else if (topSmallWidthCount >= 8)
                    {
                        stateCounter++;
                        tridentFlag = 1;
                    }
                }
            }
        }
        else//保护
        {
            stateCounter = 0;
            return tridentFlag;
        }
        if (triLeftJumpPos != MISS&&triLeftJumpPos>15)
        {
            //此判据下顶部有长白条肯定不是
            uint8_t whiteNum = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 105)
                    {
                        whiteNum++;
                    }
                }
            }
            if (whiteNum < 5)
            {
                IMG[triLeftJumpPos][leftEdge[triLeftJumpPos]] = green;
                if ((float)leftEdge[triLeftJumpPos - 8] != leftEdge[FAR_LINE + 2])
                {
                    float leftK = (triLeftJumpPos - 8 - FAR_LINE - 2) / ((float)leftEdge[triLeftJumpPos - 8] - leftEdge[FAR_LINE + 2]);
                    printf("leftK:%f\n", leftK);
                    uint8_t iTop = FAR_LINE + 10;
                    for (uint8_t i = FAR_LINE + 10; i < FAR_LINE + 50; i++)
                    {
                        if (right_side[i] - rightEdge[i] > 15)
                        {
                            iTop = i;
                            break;
                        }
                    }
                    float rightK = (TiltFeatureMgr.rightBreakPoint - 5 - iTop) / ((float)rightEdge[TiltFeatureMgr.rightBreakPoint - 5] - rightEdge[iTop]);
                    printf("rightK:%f\n", rightK);
                    if (abs(leftK - rightK) < 1.2)
                    {
                        printf("斜入三叉成功\n");
                        stateCounter++;
                        tridentFlag = 1;
                    }
                }
            }
        }
    }
    if (edgeLineEnum & 0x80 && TiltFeatureMgr.rightBreakPoint != MISS && leftJumpPos > 35&&~edgeLineEnum&0x04)
    {
        //顶部有长白条不是
        uint8_t largeWhiteNum = 0,cuspBlack = 0;
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i].connected[j].width > 90)
                {
                    largeWhiteNum++;
                    break;
                }
            }
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i].connected[j].width > 25)
                {
                    if (my_road[i].connected[j].left > 30)
                    {
                        cuspBlack++;
                        break;
                    }
                }
            }
        }
        if (largeWhiteNum < 5)
        {
            //向下寻找折点具体位置
            uint8_t specificPos = MISS, rightMissCount = 0;
            for (uint8_t i = TiltFeatureMgr.rightBreakPoint; i < TiltFeatureMgr.rightBreakPoint + 40; i++)
            {
                if (rightEdge[i] < rightEdge[i + 6] && rightEdge[i + 6] - rightEdge[i]>1)
                {
                    specificPos = i;
                    break;
                }
            }
            printf("specificPos:%d\n", specificPos);
            if (abs(specificPos - leftJumpPos) <= 32||specificPos<15)
            {
                //左边上面丢线，且有长白条
                uint8_t leftMissCount = 0, largeWhiteNum = 0;
                for (uint8_t i = leftJumpPos - 5; i > leftJumpPos - 35; i--)
                {
                    if (leftEdge[i] - left_side[i] < 2)
                    {
                        leftMissCount++;
                    }
                }
                printf("leftMiss:%d,cuspBlack:%d\n", leftMissCount, cuspBlack);
                if (leftMissCount > 15 && cuspBlack > 10)
                {
                    stateCounter+=2;
                    printf("斜入三叉成功\n");
                    tridentFlag = 1;
                }
            }
        }

    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x1000;
        stateCounter = 0;
    }
    return tridentFlag;
}

////////////////////////////////////////////
//功能：判断能否出三叉
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_TellIfEnterTridentStage3(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;

    //如果还有左右延申，看是否转出了
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04)
    {
        if (circleNum == 0)//若右转，看道路右不右偏
        {
            float leftK = 10.0 / (leftEdge[leftJumpPos + 20] - (float)leftEdge[leftJumpPos + 10]);
            float rightK = 10.0 / (rightEdge[rightJumpPos + 20] - (float)rightEdge[rightJumpPos + 10]);
            printf("leftK:%f\nrightK:%f\n", leftK, rightK);
            if (leftK < -0.6 && rightK < -0.6)
            {
                if (abs(leftK - rightK) < 0.4)
                {
                    stateCounter++;
                }
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        else if (circleNum == 1)
        {
            float leftK = 10.0 / (leftEdge[leftJumpPos + 20] - (float)leftEdge[leftJumpPos + 10]);
            float rightK = 10.0 / (rightEdge[rightJumpPos + 20] - (float)rightEdge[rightJumpPos + 10]);
            printf("leftK:%f\nrightK:%f\n", leftK, rightK);
            if (leftK > 0.6 && rightK > 0.6)
            {
                if (abs(leftK - rightK) < 0.4)
                {
                    stateCounter++;
                }
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }

    }
    //如果已经转了，不看黑尖点
    uint8_t iStart = 0, turnFlag = 0;
    if (circleNum == 0 && edgeLineEnum & 0x10)//右转，左线没丢失信息
    {
        for (uint8_t i = NEAR_LINE; i >= 60; i--)
        {
            if (leftEdge[i] - left_side[i] > 3)
            {
                iStart = i;
                break;
            }
        }
        if (iStart > 85)
        {
            float leftTurnK = 10.0 / ((float)leftEdge[iStart] - leftEdge[iStart - 10]);
            printf("leftTurnK:%f\n", leftTurnK);
            if (leftTurnK > -2 && leftTurnK < -0.8)
            {
                turnFlag = 1;
            }
        }
    }
    else if (circleNum == 1 && edgeLineEnum & 0x01)
    {
        for (uint8_t i = NEAR_LINE; i >= 60; i--)
        {
            if (right_side[i] - rightEdge[i] > 3)
            {
                iStart = i;
                break;
            }
        }
        if (iStart > 85)
        {
            float rightTurnK = 10.0 / ((float)rightEdge[iStart] - rightEdge[iStart - 10]);
            printf("rightTurnK:%f\n", rightTurnK);
            if (rightTurnK < 2 && rightTurnK > 0.8)
            {
                turnFlag = 1;
            }
        }
    }
    uint8_t blackCuspLeft = MISS, blackCuspRight = MISS, iblack = MISS;
    for (uint8_t i = 3; i <= 90; i++)
    {
        if (image_TellRealWhiteNum(i + 1) == 1)
        {
            uint8_t counter = 0;
            for (uint8_t j = i - 3; j <= i; j++)
            {
                if (image_TellRealWhiteNum(j) >= 2)
                {
                    counter++;
                }
            }
            if (counter == 4)
            {
                //blackCuspLeft = my_road[i].connected[image_GetWIndex(_left, i)].right;
                //blackCuspRight = my_road[i].connected[image_GetWIndex(_right, i)].left;
                iblack = i;
            }
        }
    }
    /*if (iblack != MISS)
    {
        for (uint8_t i = blackCuspLeft; i <= blackCuspRight; i++)
        {
            IMG[iblack][i] = green;
        }
    }*/
    printf("iBlack:%d\n", iblack);
    if (iblack == MISS || turnFlag == 1)
    {
        if (circleNum == 1)//若左转,看右边线
        {
            //计算有效行
            uint8_t validNum = 0;
            for (uint8_t i = 90; i > 75; i--)
            {
                if (right_side[i] - rightEdge[i] >= 4)
                {
                    validNum++;
                }
            }
            printf("validNum:%d\n", validNum);
            if (validNum >= 10)
            {
                stateCounter += 2;
            }
            else if (validNum >= 5)
            {
                stateCounter++;
            }
            else
            {
                stateCounter = 0;
            }
        }
        else//若右转，看左边线
        {
            //计算有效行
            uint8_t validNum = 0;
            for (uint8_t i = 90; i > 75; i--)
            {
                if (leftEdge[i] - left_side[i] >= 4)
                {
                    validNum++;
                }
            }
            printf("validNum:%d\n", validNum);
            if (validNum >= 10)
            {
                stateCounter += 2;
            }
            else if (validNum >= 5)
            {
                stateCounter++;
            }
            else
            {
                stateCounter = 0;
            }
        }
    }
    else
    {
        stateCounter = 0;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0004;
        printf("出三叉判断成功\n");
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断能否斜出三叉
//输入：
//输出：
//备注：
///////////////////////////////////////////

void image_TellIfLeftTiltQuitTrident(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //如果中部还有长白条肯定没出
    uint8_t largeWhiteNum = 0;
    for (uint8_t i = FAR_LINE + 10; i < FAR_LINE + 75; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 100)
            {
                largeWhiteNum++;
                break;
            }
        }
    }
    printf("largeWhiteNum:%d\n", largeWhiteNum);
    if (largeWhiteNum > 20)
    {
        stateCounter = 0;
        return;
    }
    if (circleNum == 0)//右转
    {
        if (TiltFeatureMgr.leftMissCount < 30)
        {
            stateCounter = 0;
            return;
        }
        //找尖点
        cuspLine = MISS;
        for (uint8_t i = FAR_LINE; i <= FAR_LINE + 100; i++)
        {
            //找靠右的真正白条编号
            uint8_t jEnd = my_road[i].white_num, jFir = 0, jSec = 0, jDown = 0;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i].connected[j].width > 15)
                {
                    if (jFir == 0)
                    {
                        jFir = j;
                    }
                    else
                    {
                        jSec = j;
                        break;
                    }
                }
            }
            jEnd = my_road[i + 1].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i + 1].connected[j].width > 25)
                {
                    jDown = j;
                    break;
                }
            }
            //三个都找到，记录中值
            if (jFir && jSec && jDown && image_TellRealWhiteNum(i + 1) == 1)
            {
                if (my_road[i + 1].connected[jDown].right > my_road[i].connected[jFir].left && my_road[i + 1].connected[jDown].left < my_road[i].connected[jSec].right)
                {
                    /*for (uint8_t j = my_road[i].connected[jSec].right; j <= my_road[i].connected[jFir].left; j++)
                    {
                        IMG[i][j] = green;
                    }*/
                    cuspLine = i;
                    printf("cuspLine:%d\n", cuspLine);
                    if (TiltFeatureMgr.cuspLine == MISS && cuspLine != MISS)
                    {
                        TiltFeatureMgr.cuspLine = cuspLine;
                    }
                    break;
                }
            }
        }
        if (~edgeLineEnum & 0x10 && ~edgeLineEnum & 0x01&&cuspLine!=MISS)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = TridentStage2;
            return;
        }
        if (cuspLine >= 85)
        {
            stateCounter += 2;
        }
        else if (cuspLine >= 80)
        {
            stateCounter++;
        }
        else if(cuspLine<65)
        {
            stateCounter = 0;
        }
    }
    else if (circleNum == 1) //左转
    {
        //左折点还存在，肯定没转完
        if (TiltFeatureMgr.leftBreakPoint != MISS)
        {
            stateCounter = 0;
            return;
        }
        //统计右边线有效行
        uint8_t validNum = 0;
        for (uint8_t i = 95; i > 80; i--)
        {
            if (right_side[i] - rightEdge[i] >= 4)
            {
                validNum++;
            }
        }
        printf("validNum:%d\n", validNum);
        if (validNum >= 10)
        {
            stateCounter += 2;
        }
        else if (validNum >= 5)
        {
            stateCounter++;
        }
        else
        {
            stateCounter = 0;
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0004;
        printf("出三叉判断成功\n");
        stateCounter = 0;
    }
}

void image_TellIfRightTiltQuitTrident(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //如果中部还有长白条肯定没出
    uint8_t largeWhiteNum = 0;
    for (uint8_t i = FAR_LINE + 10; i < FAR_LINE + 75; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 100)
            {
                largeWhiteNum++;
                break;
            }
        }
    }
    printf("largeWhiteNum:%d\n", largeWhiteNum);
    if (largeWhiteNum > 20)
    {
        stateCounter = 0;
        return;
    }
    if (circleNum == 0)//右转
    {
        //右折点还存在肯定没转完
        if (TiltFeatureMgr.rightBreakPoint != MISS)
        {
            stateCounter = 0;
            return;
        }
        //计算有效行
        uint8_t validNum = 0;
        for (uint8_t i = 95; i > 80; i--)
        {
            if (leftEdge[i] - left_side[i] >= 4)
            {
                validNum++;
            }
        }
        printf("validNum:%d\n", validNum);
        if (validNum >= 10)
        {
            stateCounter += 2;
        }
        else if (validNum >= 5)
        {
            stateCounter++;
        }
        else
        {
            stateCounter = 0;
        }
    }
    else if (circleNum == 1)//若左转
    {
        if (TiltFeatureMgr.rightMissCount < 30)
        {
            stateCounter = 0;
            return;
        }
        cuspLine = MISS;
        for (uint8_t i = FAR_LINE; i <= FAR_LINE + 100; i++)
        {
            //找靠左的真正白条编号
            uint8_t jEnd = my_road[i].white_num, jFir = 0, jSec = 0, jDown = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 15)
                {
                    if (jFir == 0)
                    {
                        jFir = j;
                    }
                    else
                    {
                        jSec = j;
                        break;
                    }
                }
            }
            jEnd = my_road[i + 1].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i + 1].connected[j].width > 25)
                {
                    jDown = j;
                    break;
                }
            }
            //三个都找到，记录中值
            if (jFir && jSec && jDown && image_TellRealWhiteNum(i + 1) == 1)
            {
                if (my_road[i + 1].connected[jDown].left<my_road[i].connected[jFir].right && my_road[i + 1].connected[jDown].right>my_road[i].connected[jSec].left)
                {
                    /*for (uint8_t j = my_road[i].connected[jFir].right; j <= my_road[i].connected[jSec].left; j++)
                    {
                        IMG[i][j] = green;
                    }*/
                    cuspLine = i;
                    printf("cuspLine:%d\n", cuspLine);
                    if (TiltFeatureMgr.cuspLine == MISS && cuspLine != MISS)
                    {
                        TiltFeatureMgr.cuspLine = cuspLine;
                    }
                    break;
                }
            }
        }
        if (~edgeLineEnum & 0x10 && ~edgeLineEnum & 0x01 && cuspLine != MISS)
        {
            stateMgr.lastState = stateMgr.curtState;
            stateMgr.curtState = TridentStage2;
            return;
        }
        if (cuspLine >= 85)
        {
            stateCounter += 2;
        }
        else if (cuspLine >= 80)
        {
            stateCounter++;
        }
        else if(cuspLine<65)
        {
            stateCounter = 0;
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0004;
        printf("出三叉判断成功\n");
        stateCounter = 0;
    }
}


////////////////////////////////////////////
//功能：判断是否进十字2阶段
//输入：
//输出：
//备注：比较正情况
///////////////////////////////////////////
void image_TellIfEnterCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t counter = 0;
    uint8_t crossWidth = MISS, crossWhiteMid = MISS;
    uint8_t caculatePos = MISS,missCacuPos = MISS;
    if (stateMgr.curtState == rightTiltEnterCross)
    {
        if (TiltFeatureMgr.rightMissCount < 10)
        {
            stateCounter = 0;
            return;
        }
    }
    if (stateMgr.curtState == leftTiltEnterCross)
    {
        if (TiltFeatureMgr.leftMissCount < 10)
        {
            stateCounter = 0;
            return;
        }
    }
    //看底部与顶部赛道宽度
    if (abs(jumpPosVar) > 35 && leftJumpPos != MISS && rightJumpPos != MISS)
    {
        if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04)
        {
            stateCounter = 0;
            return;
        }
    }
    if (leftJumpPos != MISS && rightJumpPos != MISS&&(edgeLineEnum&0x80||edgeLineEnum&0x04))
    {
        caculatePos = leftJumpPos > rightJumpPos ? leftJumpPos : rightJumpPos;
        if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04)
        {
            missCacuPos = leftJumpPos < rightJumpPos ? leftJumpPos : rightJumpPos;
        }
        else if(edgeLineEnum&0x80)
        {
            missCacuPos = leftJumpPos;
        }
        else if(edgeLineEnum&0x04)
        {
            missCacuPos = rightJumpPos;
        }
    }
    else if (leftJumpPos != MISS&&edgeLineEnum&0x80)
    {
        caculatePos = leftJumpPos;
        missCacuPos = leftJumpPos;
    }
    else if (rightJumpPos != MISS&&edgeLineEnum&0x04)
    {
        caculatePos = rightJumpPos;
        missCacuPos = rightJumpPos;
    }
    else
    {
        stateCounter = 0;
        return;
    }
    //计算跳变点以上缺线
    uint8_t leftMissCount = 0, rightMissCount = 0;
    if (missCacuPos > 60&&missCacuPos!=MISS)
    {
        for (uint8_t i = missCacuPos; i > missCacuPos - 40; i--)
        {
            if (leftEdge[i] - left_side[i] < 3)
            {
                leftMissCount++;
            }
            if (right_side[i] - rightEdge[i] < 3)
            {
                rightMissCount++;
            }
        }
    }
    if (leftMissCount > 20 && rightMissCount > 20)
    {
        for (uint8_t i = 1; i <= my_road[caculatePos + 3].white_num; i++)
        {
            uint8_t curWidth = my_road[caculatePos + 3].connected[i].width;
            if (curWidth > 10 && curWidth < 75)
            {
                crossWidth = curWidth;
                crossWhiteMid = my_road[caculatePos + 3].connected[i].left / 2 + my_road[caculatePos + 3].connected[i].right / 2;
                break;
            }
        }
        if (crossWidth == MISS && ((edgeLineEnum & 0x80 && edgeLineEnum & 0x08) || (edgeLineEnum & 0x40 && edgeLineEnum & 0x04)))
        {
            crossWidth = 52;
            crossWhiteMid = 94;
        }
        printf("crossWidth:%d\n", crossWidth);
        if (crossWidth != MISS && crossWidth >= 10 && crossWidth <= 85)
        {
            for (uint8_t i = FAR_LINE; i < 10; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    uint8_t width = my_road[i].connected[j].width;
                    if (width<crossWidth + 20 && width>crossWidth - 20)
                    {
                        uint8_t whiteMiddlePos = my_road[i].connected[j].left / 2 + my_road[i].connected[j].right / 2;
                        if (abs(whiteMiddlePos - crossWhiteMid) <= 28)
                        {
                            counter++;
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            stateCounter = 0;
            return;
        }
        if (counter >= 4)
        {
            stateCounter++;
            printf("进十字判断成功\n");
        }

    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0010;
        stateCounter = 0;
    }
}

void image_TellIfEnterCrossWeak(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t counter = 0;
    uint8_t crossWidth = MISS;
    if (leftJumpPos != MISS && rightJumpPos != MISS)
    {
        if (my_road[leftJumpPos].white_num == 1 && my_road[rightJumpPos].white_num == 1)
        {
            crossWidth = (my_road[leftJumpPos].connected[1].width + my_road[rightJumpPos].connected[1].width) / 2;
            printf("crossWidth:%d\n", crossWidth);
        }
    }
    if (crossWidth != MISS)
    {
        for (uint8_t i = FAR_LINE; i < 11; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width<crossWidth + 10 && my_road[i].connected[j].width>crossWidth - 10)
                {
                    counter++;
                    break;
                }
            }
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    printf("Counter:%d\n", counter);
    if (counter > 6)
    {
        stateCounter++;
    }
    else
    {
        stateCounter = 0;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0010;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否出十字
//输入：
//输出：
//备注：进出不匹配
///////////////////////////////////////////
void image_TellIfSpecialQuitCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //跳变点离得太远肯定不是
    if (jumpPosVar >= 20)
    {
        stateCounter = 0;
        return;
    }
    //寻找顶上的白条，条件每行只有一条
    for (uint8_t i = FAR_LINE; i < 6; i++)
    {
        if (my_road[i].white_num != 1)
        {
            stateCounter = 0;
            return;
        }
    }
    stateCounter++;
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0080;
    }
}

////////////////////////////////////////////
//功能：判断是否出十字
//输入：
//输出：
//备注：进出匹配
///////////////////////////////////////////
void image_TellIfQuitCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //找左右丢线，看地下尖角消失没
    uint8_t leftMissCounter = 0, rightMissCounter = 0;
    for (uint8_t i = 100; i >= 65; i--)
    {
        if (leftEdge[i] - left_side[i] < 4)
        {
            leftMissCounter++;
        }
        if (right_side[i] - rightEdge[i] < 4)
        {
            rightMissCounter++;
        }
    }
    if (leftMissCounter >= 22 && rightMissCounter >= 22)
    {
        stateCounter += 2;
    }
    else if (leftMissCounter > 18 && rightMissCounter > 18)
    {
        stateCounter++;
    }
    if (edgeLineEnum & 0x40 && edgeLineEnum & 0x08 && fabs(jumpPosVar) <= 30)
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0020;
    }
}

////////////////////////////////////////////
//功能：判断是否斜出十字
//输入：
//输出：
//备注：
///////////////////////////////////////////

void image_TellIfTiltQuitCross(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //如果左右延申还是入十字，退出
    if (edgeLineEnum & 0x80 && edgeLineEnum & 0x04)
    {
        stateCounter = 0;
        return;
    }
    //左右延申太高肯定不是
    if (edgeLineEnum & 0x80 && leftJumpPos < 35)
    {
        stateCounter = 0;
        return;
    }
    if (edgeLineEnum & 0x04 && rightJumpPos < 35)
    {
        stateCounter = 0;
        return;
    }
    //如果顶部有长白条肯定不是
    uint8_t whiteNumCounter = 0;
    for (uint8_t i = FAR_LINE; i <= FAR_LINE + 30; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 120)
            {
                whiteNumCounter++;
            }
        }
    }
    printf("whiteNumCounter:%d\n", whiteNumCounter);
    if (whiteNumCounter > 20)
    {
        stateCounter = 0;
        return;
    }
    //找黑尖点
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i <= 75; i++)
    {
        //防止阈值问题
        uint8_t upLineWhiteNum = 0;
        uint8_t downLineWhiteNum = 0;
        uint8_t jEnd = my_road[i].white_num;
        //计算当前行实际白条数
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 20)
            {
                upLineWhiteNum++;
            }
        }
        //计算下一行实际白条数
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i + 1].connected[j].width > 20)
            {
                downLineWhiteNum++;
            }
        }
        if (upLineWhiteNum == 2 && downLineWhiteNum == 1)
        {
            cuspLine = i;
            printf("cuspline:%d\n", cuspLine);
            break;
        }
    }
    //顶部只有一根道了,且宽度小
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE + 10; i <= FAR_LINE + 50; i++)
    {
        if (image_TellRealWhiteNum(i) == 1)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 25 && my_road[i].connected[j].width < 70)
                {
                    counter++;
                }
            }
        }
    }
    printf("counter:%d\n", counter);
    //尖点现在很准，不见了++
    if (cuspLine <= 70)
    {
        stateCounter = 0;
    }
    else if (cuspLine != MISS)
    {
        stateCounter++;
    }
    if (stateMgr.curtState == leftTiltEnterCross)
    {
        if (edgeLineEnum & 0x40)
        {
            stateCounter++;
        }
    }
    else if (stateMgr.curtState == rightTiltEnterCross)
    {
        if (edgeLineEnum & 0x08)
        {
            stateCounter++;
        }
    }

    if (counter >= 20)
    {
        stateCounter += 2;
    }
    else if (counter > 10)
    {
        stateCounter++;
    }
    if (stateCounter >= 3)
    {
        *ptrStateEnum |= 0x1000;
        stateCounter = 0;
    }
}

void image_TellIfCrossComplete(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 10);
    if (blackNum >= 5)
    {
        *ptrStateEnum |= 0x0040;
        stateCounter = 0;
        return;
    }
    //如果还看的到对角两个跳变点，肯定不是
    if (stateMgr.curtState == rightTiltEnterCross)
    {
        if (edgeLineEnum & 0x40 && edgeLineEnum & 0x04 && jumpPosVar < -20)
        {
            stateCounter = 0;
            return;
        }
    }
    else if (stateMgr.curtState == leftTiltEnterCross)
    {
        if (edgeLineEnum & 0x80 && edgeLineEnum & 0x08 && jumpPosVar > 20)
        {
            stateCounter = 0;
            return;
        }
    }
    //如果某一跳变点位置较高，也不是
    if ((edgeLineEnum & 0x40 && leftJumpPos < 60) || (edgeLineEnum & 0x08 && rightJumpPos < 60))
    {
        stateCounter = 0;
        return;
    }
    //如果有黑尖点,且位置较高，也不是
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i <= 85; i++)
    {
        //防止阈值问题
        uint8_t upLineWhiteNum = 0;
        uint8_t downLineWhiteNum = 0;
        uint8_t jEnd = my_road[i].white_num;
        //计算当前行实际白条数
        uint8_t jUpLeft = MISS, jUpRight = MISS, jDown = MISS;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 20)
            {
                upLineWhiteNum++;
                if (jUpLeft == MISS)
                {
                    jUpLeft = j;
                }
                else if (jUpRight == MISS)
                {
                    jUpRight = j;
                }
            }
        }
        //计算下一行实际白条数
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i + 1].connected[j].width > 20)
            {
                downLineWhiteNum++;
                if (jDown == MISS)
                {
                    jDown = j;
                }
            }
        }
        if (upLineWhiteNum == 2 && downLineWhiteNum == 1)
        {
            if (my_road[i + 1].connected[jDown].right > my_road[i].connected[jUpLeft].right && my_road[i + 1].connected[jDown].left < my_road[i].connected[jUpRight].left)
            {
                cuspLine = i;
                printf("cuspline:%d\n", cuspLine);
                break;
            }
        }
    }
    if (cuspLine <= 65)
    {
        stateCounter = 0;
        return;
    }
    if (rightJumpPos >= 75 || leftJumpPos >= 75)
    {
        stateCounter++;
    }
    if (~supplyEdgeLineEnum & 0x20 || ~supplyEdgeLineEnum & 0x02)
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0040;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为进环岛
//输入：
//输出：
//备注：能否进环岛1阶段
///////////////////////////////////////////

void image_TellIfEnterRightRoundabout(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //看左标准线斜率
    if (leftEdge[FAR_LINE + 5] > leftEdge[80])
    {
        if (leftVaric > 5)
        {
            stateCounter = 0;
            return;
        }
        //看右顶部有没有丢线
        uint8_t rightMissCounter = 0;
        for (uint8_t i = FAR_LINE; i <= FAR_LINE + 35; i++)
        {
            if (187 - rightEdge[i] < 4)
            {
                rightMissCounter++;
            }
        }
        if (rightMissCounter <= 15)
        {
            stateCounter = 0;
        }
    }
    else
    {
        if (leftVaric > 20)
        {
            stateCounter = 0;
            return;
        }
    }
    //跳变点太高，不用急着给状态
    if (rightJumpPos < 15)
    {
        stateCounter = 0;
        return;
    }
    //看右部有没有十字跳变
    uint8_t maxJumpVar = 0;
    for (uint8_t i = rightJumpPos; i > FAR_LINE + 5; i--)
    {
        if (rightEdge[i - 1] > rightEdge[i])
        {
            uint8_t curVar = rightEdge[i - 1] - rightEdge[i];
            if (curVar > maxJumpVar)
            {
                maxJumpVar = curVar;
            }
        }
    }
    printf("maxJumpVar:%d\n", maxJumpVar);
    if (maxJumpVar >= 40)
    {
        stateCounter++;
        printf("大跳变环岛\n");
    }
    //顶上有长白条，进入时间靠前
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE; i < 30; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 95 /*&& my_road[i].connected[j].left < 88 && my_road[i].connected[j].right>172*/)
            {
                counter++;
                break;
            }
        }
    }
    if (counter >= 20)
    {
        stateCounter += 2;
        printf("长白条环岛\n");
    }
    else if (counter >= 10)
    {
        stateCounter++;
        printf("长白条环岛\n");
        if (leftVaric < 2)
        {
            stateCounter++;
            printf("长白条环岛\n");
        }
    }
    //进入时间靠后,跳变点位置也需靠下
    if (rightJumpPos > 50)
    {
        uint16_t jumpWhiteWidth = 0, topWhiteWidth = 0;
        for (uint8_t i = rightJumpPos; i < rightJumpPos + 3; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)//右环岛找偏左赛道
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > 20)
                {
                    jumpWhiteWidth += (curWidth / 3);
                    break;
                }
            }
        }
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 3; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > 20)
                {
                    topWhiteWidth += (curWidth / 3);
                    break;
                }
            }
        }
        printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
        printf("topWhiteWidth:%d\n", topWhiteWidth);
        if (abs(topWhiteWidth - jumpWhiteWidth) <= 20)
        {
            stateCounter++;
            printf("后环岛\n");
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0400;
        stateCounter = 0;
        return;
    }
}

void image_TellIfEnterLeftRoundabout(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //看右标准线斜率
    if (rightEdge[FAR_LINE + 5] < rightEdge[80])
    {
        if (rightVaric > 5)
        {
            stateCounter = 0;
            return;
        }
        //看左顶部有没有丢线
        uint8_t leftMissCounter = 0;
        for (uint8_t i = FAR_LINE; i <= FAR_LINE + 35; i++)
        {
            if (leftEdge[i] < 4)
            {
                leftMissCounter++;
            }
        }
        if (leftMissCounter <= 15)
        {
            stateCounter = 0;
        }
    }
    else
    {
        if (rightVaric > 20)
        {
            stateCounter = 0;
            return;
        }
    }
    //跳变点太高，不用急着给状态
    if (leftJumpPos < 15)
    {
        stateCounter = 0;
        return;
    }
    //看左部有没有十字跳变
    uint8_t maxJumpVar = 0;
    for (uint8_t i = leftJumpPos; i > FAR_LINE + 5; i--)
    {
        if (leftEdge[i - 1] < leftEdge[i])
        {
            uint8_t curVar = leftEdge[i] - leftEdge[i - 1];
            if (curVar > maxJumpVar)
            {
                maxJumpVar = curVar;
            }
        }
    }
    printf("maxJumpVar:%d\n", maxJumpVar);
    if (maxJumpVar >= 40)
    {
        stateCounter++;
        printf("大跳变环岛\n");
    }
    //寻找顶上长白条，进环岛时间靠前
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE; i < 30; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 95 /*&& my_road[i].connected[j].left < 15 && my_road[i].connected[j].right>100*/)
            {
                counter++;
                break;
            }
        }
    }
    if (counter >= 20)
    {
        stateCounter += 2;
        printf("长白条环岛\n");
    }
    else if (counter >= 10)
    {
        stateCounter++;
        printf("长白条环岛\n");
        if (rightVaric < 2)
        {
            stateCounter++;
            printf("长白条环岛\n");
        }
    }
    //进环岛时间靠后,跳变点也需靠下
    if (leftJumpPos > 50)
    {
        uint16_t jumpWhiteWidth = 0, topWhiteWidth = 0;
        for (uint8_t i = leftJumpPos; i < leftJumpPos + 3; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)//左环岛找偏右赛道
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > 20)
                {
                    jumpWhiteWidth += (curWidth / 3);
                    break;
                }
            }
        }
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 3; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > 20)
                {
                    topWhiteWidth += (curWidth / 3);
                    break;
                }
            }
        }
        printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
        printf("topWhiteWidth:%d\n", topWhiteWidth);
        //比较
        if (abs(topWhiteWidth - jumpWhiteWidth) <= 20)
        {
            stateCounter++;
            printf("后环岛\n");
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0200;
        stateCounter = 0;
        return;
    }
}

////////////////////////////////////////////
//功能：判断是否为进环岛
//输入：
//输出：
//备注：能否进环岛2阶段
///////////////////////////////////////////

void image_TellIfTiltEnterRightRoundabout(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 25, 12);
    if (blackNum >= 8)
    {
        stateCounter = 0;
        return;
    }
    //左边笔直，右边递减趋势在上方
    if (TiltFeatureMgr.rightMissCount >= 25 && leftVaric < 10)
    {
        uint8_t circleStart = MISS;
        if (edgeLineEnum & 0x08)//圆圈位置
        {
            circleStart = rightJumpPos;
        }
        else if(~edgeLineEnum&0x04&&stateMgr.curtState==enterRightRoundabout)
        {
            for (uint8_t i = 75; i > FAR_LINE + 15; i--)
            {
                if (right_side[i] - rightEdge[i] > 2)
                {
                    uint8_t counter = 0;
                    for (uint8_t j = i - 1; j > i - 6; j--)
                    {
                        if (right_side[j] - rightEdge[j] > 3)
                        {
                            counter++;
                        }
                    }
                    if (counter > 3)
                    {
                        circleStart = i;
                        break;
                    }
                }
            }
            printf("circleStart:%d\n", circleStart);

        }
        if (circleStart != MISS)
        {
            //寻找递减趋势
            uint8_t counter = 0;
            for (uint8_t i = circleStart; i > FAR_LINE + 3; i--)
            {
                uint8_t upWidth = 0, downWidth = 0, jEnd = my_road[i].white_num;
                //寻找下部最长白条
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    uint8_t jWidth = my_road[i].connected[j].width;
                    if (jWidth > downWidth)
                    {
                        downWidth = jWidth;
                    }
                }
                //寻找上部最长白条
                jEnd = my_road[i - 3].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    uint8_t jWidth = my_road[i - 3].connected[j].width;
                    if (jWidth > upWidth)
                    {
                        upWidth = jWidth;
                    }
                }
                if (downWidth > upWidth && downWidth - upWidth >= 2)
                {
                    counter++;
                }
            }
            printf("counter:%d\n", counter);
            if (counter >= 3)
            {
                stateCounter++;
                printf("环岛二阶段\n");
            }
            else
            {
                stateCounter = 0;
            }
        }
    }
    ////左边直线，右边丢线
    //if (~edgeLineEnum & 0x20)
    //{
    //	//寻找右下角是否丢线
    //	uint8_t rightMissCounter = 0,iStart = MISS;
    //	for (uint8_t i = 100; i > 75; i--)
    //	{
    //		if (right_side[i] - rightEdge[i] <= 3)
    //		{
    //			rightMissCounter++;
    //		}
    //		else if (iStart != MISS)
    //		{
    //			iStart = i;
    //		}
    //	}
    //	if (rightMissCounter >= 20)
    //	{
    //		if (iStart == MISS)
    //		{
    //			for (uint8_t i = 75; i > 35; i--)
    //			{
    //				if (right_side[i] - rightEdge[i] > 3)
    //				{
    //					iStart = i;
    //					break;
    //				}
    //			}
    //		}
    //		if (iStart != MISS)
    //		{
    //			//寻找递减趋势
    //			uint8_t counter = 0;
    //			for (uint8_t i = iStart; i > iStart - 20; i--)
    //			{
    //				uint8_t upWidth = 0, downWidth = 0,jEnd = my_road[i].white_num;
    //				//寻找下部最长白条
    //				for (uint8_t j = 1; j <= jEnd; j++)
    //				{
    //					uint8_t jWidth = my_road[i].connected[j].width;
    //					if (jWidth > downWidth)
    //					{
    //						downWidth = jWidth;
    //					}
    //				}
    //				//寻找上部最长白条
    //				jEnd = my_road[i - 3].white_num;
    //				for (uint8_t j = 1; j <= jEnd; j++)
    //				{
    //					uint8_t jWidth = my_road[i-3].connected[j].width;
    //					if (jWidth > upWidth)
    //					{
    //						upWidth = jWidth;
    //					}
    //				}
    //				if (downWidth > upWidth && downWidth - upWidth >= 2)
    //				{
    //					counter++;
    //				}
    //			}
    //			printf("counter:%d\n", counter);
    //			if (counter > 8)
    //			{
    //				stateCounter++;
    //			}
    //			else
    //			{
    //				stateCounter = 0;
    //			}
    //		}
    //	}
    //	else
    //	{
    //		stateCounter = 0;
    //		return;
    //	}
    //}
    //else
    //{
    //	stateCounter = 0;
    //	return;
    //}
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0800;
        stateCounter = 0;
    }
}

void image_TellIfTiltEnterLeftRoundabout(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 25, 12);
    if (blackNum >= 8)
    {
        stateCounter = 0;
        return;
    }
    //右边笔直，左边递减趋势在上方
    if (TiltFeatureMgr.leftMissCount >= 25 && rightVaric < 10)
    {
        uint8_t circleStart = MISS;
        if (edgeLineEnum & 0x40)//圆圈位置
        {
            circleStart = leftJumpPos;
        }
        else if (~edgeLineEnum & 0x80&&stateMgr.curtState==enterLeftRoundabout)
        {
            for (uint8_t i = 75; i > FAR_LINE + 15; i--)
            {
                if (leftEdge[i]-left_side[i] > 2)
                {
                    uint8_t counter = 0;
                    for (uint8_t j = i - 1; j > i - 6; j--)
                    {
                        if (leftEdge[i] - left_side[i] > 3)
                        {
                            counter++;
                        }
                    }
                    if (counter > 3)
                    {
                        circleStart = i;
                        break;
                    }
                }
            }
            printf("circleStart:%d\n", circleStart);
        }
        if (circleStart != MISS)
        {
            //寻找递减趋势
            uint8_t counter = 0;
            for (uint8_t i = circleStart; i > FAR_LINE + 3; i--)
            {
                uint8_t upWidth = 0, downWidth = 0, jEnd = my_road[i].white_num;
                //寻找下部最长白条
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    uint8_t jWidth = my_road[i].connected[j].width;
                    if (jWidth > downWidth)
                    {
                        downWidth = jWidth;
                    }
                }
                //寻找上部最长白条
                jEnd = my_road[i - 3].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    uint8_t jWidth = my_road[i - 3].connected[j].width;
                    if (jWidth > upWidth)
                    {
                        upWidth = jWidth;
                    }
                }
                if (downWidth > upWidth && downWidth - upWidth >= 2)
                {
                    counter++;
                }
            }
            printf("counter:%d\n", counter);
            if (counter >= 3)
            {
                stateCounter++;
                printf("环岛二阶段\n");
            }
            else
            {
                stateCounter = 0;
            }
        }
    }
    ////右边直线，左边丢线
    //if (~edgeLineEnum & 0x20)
    //{
    //	//寻找左下角是否丢线
    //	uint8_t leftMissCounter = 0, iStart = MISS;
    //	for (uint8_t i = 100; i > 75; i--)
    //	{
    //		if (leftEdge[i] - left_side[i] <= 3)
    //		{
    //			leftMissCounter++;
    //		}
    //		else if (iStart != MISS)
    //		{
    //			iStart = i;
    //		}
    //	}
    //	if (leftMissCounter >= 20)
    //	{
    //		if (iStart == MISS)
    //		{
    //			for (uint8_t i = 75; i > 35; i--)
    //			{
    //				if (leftEdge[i] - left_side[i] > 3)
    //				{
    //					iStart = i;
    //					break;
    //				}
    //			}
    //		}
    //		if (iStart != MISS)
    //		{
    //			//寻找递减趋势
    //			uint8_t counter = 0;
    //			for (uint8_t i = iStart; i > iStart - 20; i--)
    //			{
    //				uint8_t upWidth = 0, downWidth = 0, jEnd = my_road[i].white_num;
    //				//寻找下部最长白条
    //				for (uint8_t j = 1; j <= jEnd; j++)
    //				{
    //					uint8_t jWidth = my_road[i].connected[j].width;
    //					if (jWidth > downWidth)
    //					{
    //						downWidth = jWidth;
    //					}
    //				}
    //				//寻找上部最长白条
    //				jEnd = my_road[i - 3].white_num;
    //				for (uint8_t j = 1; j <= jEnd; j++)
    //				{
    //					uint8_t jWidth = my_road[i - 3].connected[j].width;
    //					if (jWidth > upWidth)
    //					{
    //						upWidth = jWidth;
    //					}
    //				}
    //				if (downWidth > upWidth && downWidth - upWidth >= 2)
    //				{
    //					counter++;
    //				}
    //			}
    //			printf("counter:%d\n", counter);
    //			if (counter > 8)
    //			{
    //				stateCounter++;
    //			}
    //			else
    //			{
    //				stateCounter = 0;
    //			}
    //		}
    //	}
    //	else
    //	{
    //		stateCounter = 0;
    //		return;
    //	}
    //}
    //else
    //{
    //	stateCounter = 0;
    //	return;
    //}
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x1000;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛2阶段
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_TellIfRightRoundStage2(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //如果右上顶部有长白条，肯定还没出现圆环
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE + 1; i <= FAR_LINE + 8; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 120)
            {
                counter++;
                break;
            }
        }
    }
    printf("counter:%d\n", counter);
    if (counter >= 3)
    {
        stateCounter = 0;
        return;
    }
    if (edgeLineEnum & 0x08 && rightJumpPos > 20)//右边线出线左延申了，置信度最高
    {
        stateCounter = 0;
        //*ptrStateEnum |= 0x0800;
        printf("跳变二阶段\n");
        return;
    }
    else if (edgeLineEnum & 0x08 && rightJumpPos > 15)
    {
        stateCounter++;
    }
    if (edgeLineEnum & 0x04)//右边线跳变位置还在
    {
        if (rightJumpPos > 65)
        {
            //若顶上左赛道白条右边线离187太近也不是
            uint8_t nearWhiteNum = 0;
            for (uint8_t i = FAR_LINE; i <= FAR_LINE + 4; i++)
            {
                uint8_t jEnd = my_road[i].white_num, j = 1;
                for (; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        break;
                    }
                }
                if (my_road[i].connected[j].right > 170)
                {
                    nearWhiteNum++;
                }
            }
            if (nearWhiteNum >= 3)
            {
                stateCounter = 0;
                return;
            }
            uint16_t jumpWhiteWidth = 0, topWhiteWidth = 0;
            for (uint8_t i = rightJumpPos; i < rightJumpPos + 3; i++)
            {
                uint8_t maxWidth = 0, jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > maxWidth)
                    {
                        maxWidth = my_road[i].connected[j].width;
                    }
                }
                jumpWhiteWidth += maxWidth;
            }
            jumpWhiteWidth /= 3.0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 3; i++)
            {
                uint8_t maxWidth = 0, jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > maxWidth)
                    {
                        maxWidth = my_road[i].connected[j].width;
                    }
                }
                topWhiteWidth += maxWidth;
            }
            topWhiteWidth /= 3.0;
            printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
            printf("topWhiteWidth:%d\n", topWhiteWidth);
            if (abs(topWhiteWidth - jumpWhiteWidth) <= 25)
            {
                stateCounter++;
                printf("上下二阶段\n");
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        else
        {
            stateCounter = 0;
            return;
        }
    }
    else if (edgeLineEnum & 0x08)
    {
        ;
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0800;
        stateCounter = 0;
        return;
    }

}

void image_TellIfLeftRoundStage2(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //如果左上顶部有长白条，肯定还没出现圆环
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE + 1; i <= FAR_LINE + 8; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 120)
            {
                counter++;
                break;
            }
        }
    }
    printf("counter:%d\n", counter);
    if (counter >= 3)
    {
        stateCounter = 0;
        return;
    }
    if (edgeLineEnum & 0x40 && leftJumpPos > 20)//左边线变右延申
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x1000;
        return;
    }
    else if (edgeLineEnum & 0x40 && leftJumpPos > 15)
    {
        stateCounter++;
    }
    if (edgeLineEnum & 0x80)
    {
        if (leftJumpPos > 65)
        {
            //若顶上右赛道白条左边线离0太近也不是
            uint8_t nearWhiteNum = 0;
            for (uint8_t i = FAR_LINE; i <= FAR_LINE + 4; i++)
            {
                uint8_t jEnd = my_road[i].white_num, j = jEnd;
                for (; j >= 1; j--)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        break;
                    }
                }
                if (my_road[i].connected[j].left < 18)
                {
                    nearWhiteNum++;
                }
            }
            if (nearWhiteNum >= 3)
            {
                stateCounter = 0;
                return;
            }
            uint16_t jumpWhiteWidth = 0, topWhiteWidth = 0;
            for (uint8_t i = leftJumpPos; i < leftJumpPos + 3; i++)
            {
                //寻找每行最长的白条
                uint8_t maxWidth = 0, jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > maxWidth)
                    {
                        maxWidth = my_road[i].connected[j].width;
                    }
                }
                jumpWhiteWidth += maxWidth;
            }
            jumpWhiteWidth /= 3.0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 3; i++)
            {
                //寻找每行最长的白条
                uint8_t maxWidth = 0, jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > maxWidth)
                    {
                        maxWidth = my_road[i].connected[j].width;
                    }
                }
                topWhiteWidth += maxWidth;
            }
            topWhiteWidth /= 3.0;
            printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
            printf("topWhiteWidth:%d\n", topWhiteWidth);
            //比较
            if (abs(topWhiteWidth - jumpWhiteWidth) <= 25)
            {
                stateCounter++;
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        else
        {
            stateCounter = 0;
            return;
        }
    }
    else if (edgeLineEnum & 0x40)
    {
        ;
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x1000;
        stateCounter = 0;
        return;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛3阶段
//输入：
//输出：
//备注：黑圆看完进入3阶段
///////////////////////////////////////////
void image_TellIfLeftRoundStage3(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //没有递减趋势
    if (TiltFeatureMgr.leftMissCount > 20)
    {
        stateCounter = 0;
    }
    if (edgeLineEnum & 0x80 && leftJumpPos > 60)
    {
        uint8_t missCount = 0;
        for (uint8_t i = leftJumpPos; i > leftJumpPos - 35; i--)
        {
            if (leftEdge[i] - left_side[i] < 3)
            {
                missCount++;
            }
        }
        if (missCount > 20)
        {
            stateCounter = 0;
            return;
        }
    }
    float kLeft = MISS;
    if (abs(leftEdge[FAR_LINE + 3] - leftEdge[75]) > 2)
    {
        kLeft = (75 - FAR_LINE - 3) / ((float)leftEdge[75]-leftEdge[FAR_LINE+3]);
    }
    if (edgeLineEnum & 0x80)
    {
        uint8_t iStart = MISS;
        for (uint8_t i = NEAR_LINE - 5; i > NEAR_LINE - 50; i--)
        {
            if (leftEdge[i] - left_side[i] > 1)
            {
                iStart = i;
                break;
            }
        }
        if (iStart != MISS&&iStart>leftJumpPos)
        {
            uint8_t decreCount = 0;
            for(uint8_t i = iStart; i > leftJumpPos; i-=2)
            {
                if (leftEdge[i] < leftEdge[i - 4]&&leftEdge[i-4]-leftEdge[i]>1)
                {
                    decreCount++;
                }
            }
            if (decreCount < 5)
            {
                stateCounter++;
            }
            printf("decreCount:%d\n", decreCount);
        }
    }
    else if (kLeft != MISS && kLeft > 0 && kLeft < 5)
    {
            uint8_t iStart = MISS;
            for (uint8_t i = NEAR_LINE - 5; i > NEAR_LINE - 50; i--)
            {
                if (leftEdge[i] - left_side[i] > 1)
                {
                    iStart = i;
                    break;
                }
            }
            if (iStart != MISS)
            {
                uint8_t decreCount = 0;
                for (uint8_t i = iStart; i > FAR_LINE; i -= 2)
                {
                    if (leftEdge[i] < leftEdge[i - 4] && leftEdge[i - 4] - leftEdge[i]>1)
                    {
                        decreCount++;
                    }
                }
                if (decreCount < 5)
                {
                    stateCounter++;
                }
                printf("decreCount:%d\n", decreCount);
            }
    }
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].left <= 20 && my_road[i].connected[j].right>100)
            {
                counter++;
                break;
            }
        }
    }
    printf("Stage3 counter:%d\n", counter);
    if (counter >= 5 && edgeLineEnum & 0x80)//左边线左延申
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x4000;
    }
}

void image_TellIfRightRoundStage3(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //没有递减趋势
    if (TiltFeatureMgr.rightMissCount > 20)
    {
        stateCounter = 0;
    }
    if (edgeLineEnum & 0x04&&rightJumpPos>60)
    {
        uint8_t missCount = 0;
        for (uint8_t i = rightJumpPos; i > rightJumpPos - 35; i--)
        {
            if (right_side[i] - rightEdge[i] < 3)
            {
                missCount++;
            }
        }
        if (missCount > 20)
        {
            stateCounter = 0;
            return;
        }
    }
    float kRight = MISS;
    if (abs(rightEdge[FAR_LINE + 3] - rightEdge[75]) > 2)
    {
        kRight = (75 - FAR_LINE - 3) / ((float)rightEdge[75] - rightEdge[FAR_LINE + 3]);
    }
    if (edgeLineEnum & 0x04)
    {
        uint8_t iStart = MISS;
        for (uint8_t i = NEAR_LINE - 5; i > NEAR_LINE - 50; i--)
        {
            if (right_side[i]-rightEdge[i] > 1)
            {
                iStart = i;
                break;
            }
        }
        if (iStart != MISS && iStart > rightJumpPos)
        {
            uint8_t decreCount = 0;
            for (uint8_t i = iStart; i > rightJumpPos; i -= 2)
            {
                if (rightEdge[i] > rightEdge[i - 4] && rightEdge[i] - rightEdge[i-4]>1)
                {
                    decreCount++;
                }
            }
            if (decreCount < 5)
            {
                stateCounter++;
            }
            printf("decreCount:%d\n", decreCount);
        }
    }
    else if (kRight != MISS && kRight<0 && kRight>-5)
    {
            uint8_t iStart = MISS;
            for (uint8_t i = NEAR_LINE - 5; i > NEAR_LINE - 50; i--)
            {
                if (right_side[i] - rightEdge[i] > 1)
                {
                    iStart = i;
                    break;
                }
            }
            if (iStart != MISS)
            {
                uint8_t decreCount = 0;
                for (uint8_t i = iStart; i > FAR_LINE; i -= 2)
                {
                    if (rightEdge[i] > rightEdge[i - 4] && rightEdge[i] - rightEdge[i - 4] > 1)
                    {
                        decreCount++;
                    }
                }
                if (decreCount < 5)
                {
                    stateCounter++;
                }
                printf("decreCount:%d\n", decreCount);
            }
    }
    uint8_t counter = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].left < 88 && my_road[i].connected[j].right>=168)
            {
                counter++;
                break;
            }
        }
    }
    if (counter >= 5 && edgeLineEnum & 0x04)//右边线右延申
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x2000;
    }
    printf("Stage3 counter:%d\n", counter);
}

////////////////////////////////////////////
//功能：判断是否为环岛4阶段
//输入：
//输出：
//备注：顶部出现尖点进入4阶段
///////////////////////////////////////////
void image_TellIfLeftRoundStage4(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    /*cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 100; i++)
    {
        uint8_t upWidth = my_road[i].connected[my_road[i].white_num].width;
        uint8_t downWidth = my_road[i + 1].connected[my_road[i + 1].white_num].width;
        if (downWidth > upWidth && downWidth - upWidth > 25)
        {
            cuspLine = i;
            break;
        }
    }*/
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 100; i++)
    {
        //寻右边白条
        uint8_t upWidth = MISS, downWidth = MISS;
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[i].connected[j].width > 20)
            {
                uint8_t whiteMiddle = my_road[i].connected[j].left / 2 + my_road[i].connected[j].right / 2;
                if (whiteMiddle > 60)
                {
                    upWidth = my_road[i].connected[j].width;
                    break;
                }
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[i + 1].connected[j].width > 20)
            {
                downWidth = my_road[i + 1].connected[j].width;
                break;
            }
        }
        if (upWidth != MISS && downWidth != MISS && downWidth > upWidth && downWidth - upWidth > 25)
        {
            cuspLine = i;
            break;
        }
    }
    if (cuspLine != MISS)
    {
        stateCounter++;
        printf("find cusoLine:%d\n", cuspLine);
    }
    else
    {
        stateCounter = 0;
        return;
    }
    //IMG[cuspLine][my_road[cuspLine].connected[my_road[cuspLine].white_num].left] = green;
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x8000;
    }
}

void image_TellIfRightRoundStage4(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    /*cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 100; i++)
    {
        uint8_t upWidth = my_road[i].connected[1].width;
        uint8_t downWidth = my_road[i + 1].connected[1].width;
        if (downWidth > upWidth && downWidth - upWidth > 25)
        {
            cuspLine = i;
            break;
        }
    }*/
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 118; i++)
    {
        //寻左边白条
        uint8_t upWidth = MISS, downWidth = MISS;
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 20)
            {
                uint8_t whiteMiddle = my_road[i].connected[j].left / 2 + my_road[i].connected[j].right / 2;
                if (whiteMiddle < 110)
                {
                    upWidth = my_road[i].connected[j].width;
                    break;
                }
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i + 1].connected[j].width > 20)
            {
                downWidth = my_road[i + 1].connected[j].width;
                break;
            }
        }
        if (upWidth != MISS && downWidth != MISS && downWidth > upWidth && downWidth - upWidth > 25)
        {
            cuspLine = i;
            break;
        }
    }
    if (cuspLine != MISS)
    {
        stateCounter++;
        printf("find cusLine:%d\n", cuspLine);
    }
    else
    {
        stateCounter = 0;
    }
    //IMG[cuspLine][my_road[cuspLine].connected[1].right] = green;
    if (stateCounter >= 2)
    {
        stateCounter = 0;
        *ptrStateEnum |= 0x0001;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛5阶段
//输入：
//输出：
//备注：尖点位置靠下,进入弯道
///////////////////////////////////////////
void image_TellIfLeftRoundStage5(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //避免重复工作，还是找出尖点
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 105; i++)
    {
        //寻右边白条
        uint8_t upWidth = MISS, downWidth = MISS, upLeft = MISS, downRight = MISS;
        uint8_t jEnd = my_road[i].white_num;
        uint8_t validWidth = 20;
        if (validWidth != 10 && i >= 85)
        {
            validWidth = 10;
        }
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[i].connected[j].width > 20)
            {
                uint8_t whiteMiddle = my_road[i].connected[j].left / 2 + my_road[i].connected[j].right / 2;
                if (whiteMiddle > 50)
                {
                    upWidth = my_road[i].connected[j].width;
                    upLeft = my_road[i].connected[j].left;
                    break;
                }
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[i + 1].connected[j].width > validWidth)
            {
                downWidth = my_road[i + 1].connected[j].width;
                downRight = my_road[i + 1].connected[j].right;
                break;
            }
        }
        if (upWidth != MISS && downWidth != MISS && downRight > upLeft && downWidth > upWidth && downWidth - upWidth > 25)
        {
            cuspLine = i;
            break;
        }
    }
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 20, 18);
    printf("TopBlackNum:%d\n", blackNum);
    if (cuspLine <= 40)
    {
        stateCounter = 0;
        return;
    }
    if (cuspLine >= 90)//尖点位置大于100
    {
        stateCounter++;
        if (blackNum >= 5)
        {
            stateCounter++;
        }
    }
    else
    {
        stateCounter = 0;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0002;
        stateCounter = 0;
    }
}
//看实际白条个数不太好，右边白条会变短
void image_TellIfRightRoundStage5(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    //避免重复工作，还是找出尖点
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 105; i++)
    {
        //寻左边白条
        uint8_t upWidth = MISS, downWidth = MISS, upRight = MISS, downLeft = MISS;
        uint8_t jEnd = my_road[i].white_num;
        uint8_t validWidth = 20;
        if (validWidth != 10 && i >= 85)
        {
            validWidth = 10;
        }
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width >= validWidth)
            {
                uint8_t whiteMiddle = my_road[i].connected[j].left / 2 + my_road[i].connected[j].right / 2;
                if (whiteMiddle < 120)
                {
                    upWidth = my_road[i].connected[j].width;
                    upRight = my_road[i].connected[j].right;
                    break;
                }
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i + 1].connected[j].width > validWidth)
            {
                downWidth = my_road[i + 1].connected[j].width;
                downLeft = my_road[i + 1].connected[j].left;
                break;
            }
        }
        if (upWidth != MISS && downWidth != MISS && downLeft<upRight && downWidth > upWidth && downWidth - upWidth > 25)
        {
            cuspLine = i;
            break;
        }
    }
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 20, 18);
    printf("TopBlackNum:%d\n", blackNum);
    if (cuspLine <= 40)
    {
        stateCounter = 0;
        return;
    }
    if (cuspLine >= 90)
    {
        stateCounter++;
        if (blackNum >= 5)
        {
            stateCounter++;
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0004;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛6阶段
//输入：
//输出：
//备注：是否从圆环出来，根据尖点
///////////////////////////////////////////

void image_TellIfLeftRoundStage6(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t counter = 0;
    uint16_t topWhiteWidth = 0, jumpWhiteWidth = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 10; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            //若顶部没有白条，肯定还在圆环
            stateCounter = 0;
            return;
        }
        else
        {
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t iWidth = my_road[i].connected[j].width;
                if (iWidth >= 20)
                {
                    topWhiteWidth += iWidth;
                    counter++;
                    break;
                }
            }
        }
    }
    //顶部有长白条太少
    if (counter <= 3)
    {
        stateCounter = 0;
        return;
    }
    else
    {
        //出现右边线右延申，即尖点，且左边线右延申，此时上边线倾斜角度才够
        if (edgeLineEnum & 0x04)
        {
            topWhiteWidth /= counter;
            counter = 0;
            //统计跳变处白条长度
            for (uint8_t i = rightJumpPos; i < rightJumpPos + 3; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        jumpWhiteWidth += my_road[i].connected[j].width;
                        counter++;
                    }
                }
            }
            if (counter == 0)
            {
                stateCounter = 0;
                return;
            }
            jumpWhiteWidth /= counter;
            printf("topwhiteWidth:%d\n", topWhiteWidth);
            printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
            if (abs(jumpWhiteWidth - topWhiteWidth) <= 25)
            {
                stateCounter++;
            }
            else if (topWhiteWidth >= 85 || jumpWhiteWidth >= 85)
            {
                stateCounter++;
            }
            else
            {
                stateCounter = 0;
            }
        }
        if (edgeLineEnum & 0x40 && leftJumpPos > 11&&leftVaric<1500)
        {
            uint8_t leftMaxVar = 0;
            for (uint8_t i = leftJumpPos; i > FAR_LINE + 4; i--)
            {
                if (leftEdge[i] != MISS && leftEdge[i - 1] != MISS)
                {
                    uint8_t curVar = abs(leftEdge[i] - leftEdge[i - 1]);
                    if (curVar > leftMaxVar)
                    {
                        leftMaxVar = curVar;
                    }
                }
            }
            if (leftMaxVar < 40)
            {
                uint8_t leftX1 = 0, leftX2 = 0;
                for (uint8_t i = FAR_LINE + 3; i < FAR_LINE + 6; i++)
                {
                    leftX1 += (leftEdge[i] / 3);
                }
                for (uint8_t i = leftJumpPos - 8; i > leftJumpPos - 11; i--)
                {
                    leftX2 += (leftEdge[i] / 3);
                }
                float leftK = ((float)FAR_LINE + 4 - rightJumpPos + 9) / ((float)leftX1 - leftX2);
                printf("leftK:%f\n", leftK);
                if (leftK > -3.0)
                {
                    stateCounter++;
                }
                else
                {
                    stateCounter = 0;
                }
            }
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0008;
        stateCounter = 0;
    }
}

void image_TellIfRightRoundStage6(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t counter = 0;
    uint16_t topWhiteWidth = 0, jumpWhiteWidth = 0;
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 10; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            //若顶部没有白条，肯定还在圆环
            stateCounter = 0;
            return;
        }
        else
        {
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t iWidth = my_road[i].connected[j].width;
                if (iWidth >= 20)
                {
                    topWhiteWidth += iWidth;
                    counter++;
                    break;
                }
            }
        }
    }
    //顶部有长白条太少
    if (counter <= 3)
    {
        stateCounter = 0;
        return;
    }
    else
    {
        //出现左边线左延申，即尖点
        if (edgeLineEnum & 0x80)
        {
            topWhiteWidth /= counter;
            counter = 0;
            //统计跳变处白条长度
            for (uint8_t i = leftJumpPos; i < leftJumpPos + 3; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        jumpWhiteWidth += my_road[i].connected[j].width;
                        counter++;
                    }
                }
            }
            if (counter == 0)
            {
                stateCounter = 0;
                return;
            }
            jumpWhiteWidth /= counter;
            printf("jumpWhiteWidth:%d\ntopWhiteWidth:%d\n", jumpWhiteWidth, topWhiteWidth);
            if (abs(jumpWhiteWidth - topWhiteWidth) <= 25)
            {
                stateCounter++;
            }
            else if (topWhiteWidth >= 85 || jumpWhiteWidth >= 85)
            {
                stateCounter++;
            }
            else
            {
                stateCounter = 0;
            }
        }
        if (edgeLineEnum & 0x08 && rightJumpPos > 11)//现在角度可能判断不出尖点,看顶上线斜率
        {
            uint8_t rightMaxVar = 0;
            for (uint8_t i = rightJumpPos; i > FAR_LINE + 4; i--)
            {
                if (rightEdge[i] != MISS && rightEdge[i - 1] != MISS)
                {
                    uint8_t curVar = abs(rightEdge[i] - rightEdge[i - 1]);
                    if (curVar > rightMaxVar)
                    {
                        rightMaxVar = curVar;
                    }
                }
            }
            //printf("rightMaxVar:%d\n", rightMaxVar);
            if (rightMaxVar < 40)
            {
                uint8_t rightX1 = 0, rightX2 = 0;
                for (uint8_t i = FAR_LINE + 3; i < FAR_LINE + 6; i++)
                {
                    rightX1 += (rightEdge[i] / 3);
                }
                for (uint8_t i = rightJumpPos - 8; i > rightJumpPos - 11; i--)
                {
                    rightX2 += (rightEdge[i] / 3);
                }
                float rightK = ((float)FAR_LINE + 4 - rightJumpPos + 9) / ((float)rightX1 - rightX2);
                printf("rightK:%f\n", rightK);
                if (rightK < 3.0)
                {
                    stateCounter++;
                }
                else
                {
                    stateCounter = 0;
                }
            }
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0010;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛7阶段
//输入：
//输出：
//备注：中间部分完全白条或者顶部完全黑条 左环岛：右跳变存在 右环岛：左跳变存在
///////////////////////////////////////////

void image_TellIfLeftRoundStage7(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x02 && edgeLineEnum & 0x04)
    {
        uint8_t whiteNumCounter = 0;
        //寻找中部完全白条
        for (uint8_t i = 20; i < 45; i++)
        {
            //寻找最长的白条
            uint8_t jEnd = my_road[i].white_num, maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > maxWidth)
                {
                    maxWidth = curWidth;
                }
            }
            if (maxWidth > 140)
            {
                whiteNumCounter++;
            }
        }
        for (uint8_t i = 45; i < 80; i++)
        {
            uint8_t sideWidth = right_side[i] - left_side[i];
            //寻找最长的白条
            uint8_t jEnd = my_road[i].white_num, maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > maxWidth)
                {
                    maxWidth = curWidth;
                }
            }
            if (maxWidth / (float)sideWidth > 0.80)
            {
                whiteNumCounter++;
            }
        }
        if (whiteNumCounter >= 12)
        {
            stateCounter += 2;
        }
    }
    else if (~edgeLineEnum & 0x10 || ~edgeLineEnum & 0x01)//若左右任意丢线
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 20, 5);
        if (blackNum > 15)
        {
            uint8_t whiteNumCounter = 0;
            for (uint8_t i = 45; i < 80; i++)
            {
                uint8_t sideWidth = right_side[i] - left_side[i];
                if (my_road[i].white_num == 1)
                {
                    if (my_road[i].connected[1].width / (float)sideWidth > 0.80)
                    {
                        whiteNumCounter++;
                    }
                }
            }
            if (whiteNumCounter >= 12)
            {
                stateCounter += 2;
            }
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0020;
        stateCounter = 0;
    }
}

void image_TellIfRightRoundStage7(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x20 && edgeLineEnum & 0x80)
    {
        uint8_t whiteNumCounter = 0;
        //寻找中部完全白条
        for (uint8_t i = 20; i < 45; i++)
        {
            //寻找最长的白条
            uint8_t jEnd = my_road[i].white_num, maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > maxWidth)
                {
                    maxWidth = curWidth;
                }
            }
            if (maxWidth > 140)
            {
                whiteNumCounter++;
            }
        }
        for (uint8_t i = 45; i < 80; i++)
        {
            uint8_t sideWidth = right_side[i] - left_side[i];
            //寻找最长的白条
            uint8_t jEnd = my_road[i].white_num, maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWidth = my_road[i].connected[j].width;
                if (curWidth > maxWidth)
                {
                    maxWidth = curWidth;
                }
            }
            if (maxWidth / (float)sideWidth > 0.80)
            {
                whiteNumCounter++;
            }
        }
        if (whiteNumCounter >= 12)
        {
            stateCounter += 2;
        }
    }
    else if (~edgeLineEnum & 0x10 || ~edgeLineEnum & 0x01)//若左右任意丢线
    {
        uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 20, 5);
        if (blackNum > 15)
        {
            uint8_t whiteNumCounter = 0;
            for (uint8_t i = 45; i < 80; i++)
            {
                uint8_t sideWidth = right_side[i] - left_side[i];
                if (my_road[i].white_num == 1)
                {
                    if (my_road[i].connected[1].width / (float)sideWidth > 0.80)
                    {
                        whiteNumCounter++;
                    }
                }
            }
            if (whiteNumCounter >= 12)
            {
                stateCounter += 2;
            }
        }
    }
    else
    {
        stateCounter = 0;
        return;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0040;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛8阶段
//输入：
//输出：
//备注：是否重回直道 平不平行
///////////////////////////////////////////
void image_TellIfLeftRoundStage8(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x02)//右边线还是弯的
    {
        stateCounter = 0;
        return;
    }
    //计算右边线斜率
    uint8_t iStart = MISS;
    float rightK = 0;
    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
    {
        if (rightEdge[i] != MISS)
        {
            iStart = i;
            break;
        }
    }
    if (iStart < 75)
    {
        rightK = ((float)rightEdge[iStart + 2] - (float)rightEdge[75]) / (iStart + 2 - 75);
        printf("rightK:%f\n", rightK);
    }
    else//边线太低
    {
        stateCounter = 0;
        return;
    }
    //中部还有长白条
    uint8_t whiteNumCounter = 0;
    for (uint8_t i = 45; i < 80; i++)
    {
        uint8_t sideWidth = right_side[i] - left_side[i];
        if (my_road[i].white_num == 1)
        {
            if (my_road[i].connected[1].width / (float)sideWidth > 0.70)
            {
                whiteNumCounter++;
            }
        }
    }
    if (whiteNumCounter <= 12)
    {
        stateCounter++;
    }
    if (rightK < 1.4 && rightK>0)
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0080;
        stateCounter = 0;
    }
}

void image_TellIfRightRoundStage8(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x20)//左边线还是弯的
    {
        stateCounter = 0;
        return;
    }
    //计算左边线斜率
    uint8_t iStart = MISS;
    float leftK = 0;
    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
    {
        if (leftEdge[i] != MISS)
        {
            iStart = i;
            break;
        }
    }
    if (iStart < 75)
    {
        leftK = ((float)leftEdge[iStart + 2] - (float)leftEdge[75]) / (iStart + 2 - 75);
        printf("leftK:%f\n", leftK);
    }
    else//边线太低
    {
        stateCounter = 0;
        return;
    }
    //中部还有长白条，肯定还没转完
    uint8_t whiteNumCounter = 0;
    for (uint8_t i = 45; i < 80; i++)
    {
        uint8_t sideWidth = right_side[i] - left_side[i];
        if (my_road[i].white_num == 1)
        {
            if (my_road[i].connected[1].width / (float)sideWidth > 0.70)
            {
                whiteNumCounter++;
            }
        }
    }
    if (whiteNumCounter < 12)
    {
        stateCounter++;
    }
    if (leftK<0 && leftK>-1.40)
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0100;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否为环岛9阶段
//输入：
//输出：
//备注：转完圈，车身摆正 跳变+直+中部顶上白条
///////////////////////////////////////////
void image_TellIfLeftRoundStage9(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x40 && ~edgeLineEnum & 0x02)
    {
        //寻找顶上白条与跳变白条比较
        //统计顶上白条均值
        uint16_t topWhiteWidth = 0;
        uint8_t	counter = 0;
        for (uint8_t i = FAR_LINE + 8; i < FAR_LINE + 18; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                uint8_t jWidth = my_road[i].connected[j].width;
                if (jWidth >= 25)
                {
                    topWhiteWidth += jWidth;
                    counter++;
                    break;
                }
            }
        }
        if (counter > 0)
        {
            topWhiteWidth /= counter, counter = 0;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        //统计跳变处白条均值
        uint16_t jumpWhiteWidth = 0;
        if (leftJumpPos > 20)
        {
            for (uint8_t i = leftJumpPos - 5; i > leftJumpPos - 15; i--)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    uint8_t jWidth = my_road[i].connected[j].width;
                    if (jWidth >= 25)
                    {
                        jumpWhiteWidth += jWidth;
                        counter++;
                        break;
                    }
                }
            }
            if (counter > 0)
            {
                jumpWhiteWidth /= counter;
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        printf("topWhitewidth:%d\n", topWhiteWidth);
        printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
        if (abs(topWhiteWidth - jumpWhiteWidth) <= 12)
        {
            stateCounter++;
        }
        if (rightVaric < 5 && TiltFeatureMgr.cuspLine != MISS)
        {
            if (TiltFeatureMgr.cuspLine > 20)
            {
                stateCounter += 2;
            }
        }
    }
    else
    {
        if (rightVaric < 5 && TiltFeatureMgr.cuspLine != MISS)
        {
            if (TiltFeatureMgr.cuspLine > 20)
            {
                stateCounter += 2;
            }
        }
        else
        {
            stateCounter = 0;
            return;
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0200;
        stateCounter = 0;
    }
}

void image_TellIfRightRoundStage9(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    if (edgeLineEnum & 0x08 && ~edgeLineEnum & 0x20)
    {
        //寻找顶上白条与跳变白条比较
        //统计顶上白条均值
        uint16_t topWhiteWidth = 0;
        uint8_t	counter = 0;
        for (uint8_t i = FAR_LINE + 8; i < FAR_LINE + 18; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t jWidth = my_road[i].connected[j].width;
                if (jWidth >= 25)
                {
                    topWhiteWidth += jWidth;
                    counter++;
                    break;
                }
            }
        }
        if (counter > 0)
        {
            topWhiteWidth /= counter, counter = 0;
        }
        else
        {
            stateCounter = 0;
            return;
        }
        //统计跳变处白条均值
        uint16_t jumpWhiteWidth = 0;
        if (rightJumpPos > 20)
        {
            for (uint8_t i = rightJumpPos - 5; i > rightJumpPos - 15; i--)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    uint8_t jWidth = my_road[i].connected[j].width;
                    if (jWidth >= 25)
                    {
                        jumpWhiteWidth += jWidth;
                        counter++;
                        break;
                    }
                }
            }
            if (counter > 0)
            {
                jumpWhiteWidth /= counter;
            }
            else
            {
                stateCounter = 0;
                return;
            }
        }
        printf("topWhitewidth:%d\n", topWhiteWidth);
        printf("jumpWhiteWidth:%d\n", jumpWhiteWidth);
        if (abs(topWhiteWidth - jumpWhiteWidth) <= 12)
        {
            stateCounter++;
        }
        if (leftVaric < 5 && TiltFeatureMgr.cuspLine != MISS)
        {
            if (TiltFeatureMgr.cuspLine > 20)
            {
                stateCounter += 2;
            }
        }
    }
    else
    {
        if (leftVaric < 5 && TiltFeatureMgr.cuspLine != MISS)
        {
            if (TiltFeatureMgr.cuspLine > 20)
            {
                stateCounter += 2;
            }
        }
        else
        {
            stateCounter = 0;
            return;
        }
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0400;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否出环岛
//输入：
//输出：
//备注：跳变点和尖点位置
///////////////////////////////////////////

void image_TellIfQuitLeftRound(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 10);
    if (blackNum >= 5)
    {
        *ptrStateEnum |= 0x0800;
        stateCounter = 0;
        return;
    }
    //若左下角还看的到圆环，应该是转向内切提前摆正
    uint8_t leftMissCounter = 0;
    for (uint8_t i = NEAR_LINE - 1; i > NEAR_LINE - 21; i--)
    {
        if (leftEdge[i] - left_side[i] < 3)
        {
            leftMissCounter++;
        }
    }
    printf("leftMissCounter:%d\n", leftMissCounter);
    if (leftMissCounter < 15)
    {
        stateCounter = 0;
    }
    //寻找尖点位置
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 100; i++)
    {
        //寻右边白条
        uint8_t upWidth = MISS, downWidth = MISS;
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[i].connected[j].width > 20)
            {
                upWidth = my_road[i].connected[j].width;
                break;
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[i + 1].connected[j].width > 20)
            {
                downWidth = my_road[i + 1].connected[j].width;
                break;
            }
        }
        if (upWidth != MISS && downWidth != MISS && downWidth > upWidth && downWidth - upWidth > 22)
        {
            cuspLine = i;
            break;
        }
    }
    if (edgeLineEnum & 0x40 && leftJumpPos >= 75)//必须是左边线右延申
    {
        stateCounter+=2;
    }
    else if (edgeLineEnum & 0x40 && leftJumpPos >= 70)
    {
        stateCounter++;
    }
    else if(edgeLineEnum & 0x40 && leftJumpPos >= 50)
    {
        ;
    }
    else
    {
        if (cuspLine<30)
        {
            stateCounter = 0;
        }
    }
    if (cuspLine!=MISS&&cuspLine >= 68)
    {
        stateCounter++;
    }
    if ((edgeLineEnum&0x10&&~supplyEdgeLineEnum & 0x20) && (edgeLineEnum&0x01&&~supplyEdgeLineEnum & 0x02))//底部竖直
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0800;
        stateCounter = 0;
    }
}

void image_TellIfQuitRightRound(int16_t* ptrStateEnum)
{
    static uint8_t stateCounter = 0;
    uint8_t blackNum = image_FindTopAbsBlackNum(FAR_LINE, FAR_LINE + 15, 10);
    if (blackNum >= 5)
    {
        *ptrStateEnum |= 0x0800;
        stateCounter = 0;
        return;
    }
    //若右下角还看的到圆环，应该是转向内切提前摆正
    uint8_t rightMissCounter = 0;
    for (uint8_t i = NEAR_LINE - 1; i > NEAR_LINE - 21; i--)
    {
        if (right_side[i] - rightEdge[i] < 3)
        {
            rightMissCounter++;
        }
    }
    printf("leftMissCounter:%d\n", rightMissCounter);
    if (rightMissCounter < 15)
    {
        stateCounter = 0;
    }
    //寻找尖点位置
    cuspLine = MISS;
    for (uint8_t i = FAR_LINE; i < 105; i++)
    {
        //寻左边白条
        uint8_t upWidth = MISS, downWidth = MISS;
        uint8_t jEnd = my_road[i].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width >= 20)
            {
                upWidth = my_road[i].connected[j].width;
                break;
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i + 1].connected[j].width > 20)
            {
                downWidth = my_road[i + 1].connected[j].width;
                break;
            }
        }
        if (upWidth != MISS && downWidth != MISS && downWidth > upWidth && downWidth - upWidth > 22)
        {
            cuspLine = i;
            break;
        }
    }
    printf("cuspline:%d\n", cuspLine);
    if (edgeLineEnum & 0x08 && rightJumpPos >= 75)//必须是右边线左延申
    {
        stateCounter+=2;
    }
    else if(edgeLineEnum & 0x08 && rightJumpPos >= 70)
    {
        stateCounter++;
    }
    else if(edgeLineEnum & 0x08 && rightJumpPos >= 50)
    {
        ;
    }
    else
    {
        if (cuspLine < 30)
        {
            stateCounter = 0;
        }
    }
    if (cuspLine != MISS&&cuspLine >= 68)
    {
        stateCounter++;
    }
    if ((edgeLineEnum&0x10&&~supplyEdgeLineEnum & 0x20) && (edgeLineEnum&0x01&&~supplyEdgeLineEnum & 0x02))//底部竖直
    {
        stateCounter++;
    }
    if (stateCounter >= 2)
    {
        *ptrStateEnum |= 0x0800;
        stateCounter = 0;
    }
}

////////////////////////////////////////////
//功能：判断是否误判成环岛
//输入：
//输出：
//备注：跳变点和尖点位置
///////////////////////////////////////////

void image_TellIfMissJudgeLeftRound(int16_t* ptrStateEnum)
{

    if (rightVaric > 20)
    {
        *ptrStateEnum |= 0x0001;
        return;
    }
    //若顶上黑了，为弯道误识别
    uint8_t blackCounter = 0;
    for (uint8_t i = FAR_LINE; i <= FAR_LINE + 10; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            blackCounter++;
        }
        else
        {
            uint8_t maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > maxWidth)
                {
                    maxWidth = my_road[i].connected[j].width;
                }
            }
            if (maxWidth <= 32)
            {
                blackCounter++;
            }
        }
    }
    if (blackCounter >= 4)
    {
        *ptrStateEnum |= 0x0001;
        return;
    }
    //能看到右边线车身稍微正一些
    if (edgeLineEnum & 0x02 || edgeLineEnum & 0x08 || edgeLineEnum & 0x04)//右边线变弯,或有跳变，或左边线丢失有问题
    {
        //寻找黑尖点
        cuspLine = MISS;
        for (uint8_t i = FAR_LINE; i <= 65; i++)
        {
            //防止阈值问题
            uint8_t upLineWhiteNum = 0;
            uint8_t downLineWhiteNum = 0;
            uint8_t jEnd = my_road[i].white_num;
            //计算当前行实际白条数
            uint8_t jUpLeft = MISS, jUpRight = MISS, jDown = MISS;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 20)
                {
                    upLineWhiteNum++;
                    if (jUpLeft == MISS)
                    {
                        jUpLeft = j;
                    }
                    else if (jUpRight == MISS)
                    {
                        jUpRight = j;
                    }
                }
            }
            //计算下一行实际白条数
            jEnd = my_road[i + 1].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i + 1].connected[j].width > 20)
                {
                    downLineWhiteNum++;
                    if (jDown == MISS)
                    {
                        jDown = j;
                    }
                }
            }
            if (upLineWhiteNum == 2 && downLineWhiteNum == 1)
            {
                if (my_road[i + 1].connected[jDown].right > my_road[i].connected[jUpLeft].right && my_road[i + 1].connected[jDown].left < my_road[i].connected[jUpRight].left)
                {
                    cuspLine = i;
                    printf("cuspline:%d\n", cuspLine);
                    break;
                }
            }
        }
        if (cuspLine != MISS)
        {
            *ptrStateEnum |= 0x0100;
        }
        else
        {
            *ptrStateEnum |= 0x0001;
        }
    }
    else
    {
        //看看右下角丢线没有
        uint8_t rightMissCont = 0, iStart = MISS;
        for (uint8_t i = NEAR_LINE; i > 40; i--)
        {
            if (right_side[i] - rightEdge[i] <= 3)
            {
                rightMissCont++;
            }
            else if (right_side[i] - rightEdge[i] > 3 && iStart == MISS)
            {
                iStart = i;
            }
        }
        //看顶上赛道边斜率
        if (rightMissCont >= 30 && iStart != MISS)
        {
            iStart -= 25;
            if (rightEdge[FAR_LINE] != rightEdge[iStart])//一是保护，而是竖直咋可能斜入
            {
                float rightK = (FAR_LINE - (float)iStart) / ((float)rightEdge[FAR_LINE] - rightEdge[iStart]);
                printf("rightk:%f\n", rightK);
                //找尖点位置
                for (uint8_t i = FAR_LINE; i <= FAR_LINE + 65; i++)
                {
                    //找靠右的真正白条编号
                    uint8_t jEnd = my_road[i].white_num, jFir = 0, jSec = 0, jDown = 0;
                    for (uint8_t j = jEnd; j >= 1; j--)
                    {
                        if (my_road[i].connected[j].width > 15)
                        {
                            if (jFir == 0)
                            {
                                jFir = j;
                            }
                            else
                            {
                                jSec = j;
                                break;
                            }
                        }
                    }
                    jEnd = my_road[i + 1].white_num;
                    for (uint8_t j = jEnd; j >= 1; j--)
                    {
                        if (my_road[i + 1].connected[j].width > 25)
                        {
                            jDown = j;
                            break;
                        }
                    }
                    //三个都找到，记录中值
                    if (jFir && jSec && jDown)
                    {
                        uint8_t upMiddlePos = my_road[i].connected[jFir].left / 4 + my_road[i].connected[jFir].right / 4 + my_road[i].connected[jSec].left / 4 + my_road[i].connected[jSec].right / 4;
                        uint8_t downMiddle = my_road[i + 1].connected[jDown].left / 2 + my_road[i + 1].connected[jDown].right / 2;
                        if (abs(upMiddlePos - downMiddle) <= 15)
                        {
                            cuspLine = i;
                            /*for (uint8_t j = my_road[i].connected[jSec].right; j <= my_road[i].connected[jFir].left; j++)
                            {
                                IMG[i][j] = green;
                            }*/
                            break;
                        }
                    }

                }
                if (cuspLine != MISS)
                {
                    uint8_t whiteIndexUp = image_GetWIndex(_right, FAR_LINE), whiteIndexDown = image_GetWIndex(_right, cuspLine);
                    if (whiteIndexUp && whiteIndexDown)
                    {
                        float leftK = (FAR_LINE - (float)cuspLine) / (my_road[FAR_LINE].connected[whiteIndexUp].left - (float)my_road[cuspLine].connected[whiteIndexDown].left);
                        printf("leftK:%f\n", leftK);
                        if (abs(leftK - rightK) < 0.3)
                        {
                            *ptrStateEnum |= 0x0100;
                            return;
                        }
                    }
                }
            }
            else
            {
                return;
            }

        }
    }
}

void image_TellIfMissJudgeRightRound(int16_t* ptrStateEnum)
{
    if (leftVaric > 20)
    {
        *ptrStateEnum |= 0x0001;
        return;
    }
    //若顶上黑了，为弯道误识别
    uint8_t blackCounter = 0;
    for (uint8_t i = FAR_LINE; i <= FAR_LINE + 10; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            blackCounter++;
        }
        else
        {
            uint8_t maxWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > maxWidth)
                {
                    maxWidth = my_road[i].connected[j].width;
                }
            }
            if (maxWidth <= 32)
            {
                blackCounter++;
            }
        }
    }
    if (blackCounter >= 4)
    {
        *ptrStateEnum |= 0x0001;
        return;
    }
    //能看到左边线车身稍微正一些
    if (edgeLineEnum & 0x20 || edgeLineEnum & 0x80 || edgeLineEnum & 0x40)//左边线变弯,或有跳变，或右边线丢失有问题
    {
        //寻找黑尖点
        cuspLine = MISS;
        for (uint8_t i = FAR_LINE; i <= 65; i++)
        {
            //防止阈值问题
            uint8_t upLineWhiteNum = 0;
            uint8_t downLineWhiteNum = 0;
            uint8_t jEnd = my_road[i].white_num;
            //计算当前行实际白条数
            uint8_t jUpLeft = MISS, jUpRight = MISS, jDown = MISS;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 20)
                {
                    upLineWhiteNum++;
                    if (jUpLeft == MISS)
                    {
                        jUpLeft = j;
                    }
                    else if (jUpRight == MISS)
                    {
                        jUpRight = j;
                    }
                }
            }
            //计算下一行实际白条数
            jEnd = my_road[i + 1].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i + 1].connected[j].width > 20)
                {
                    downLineWhiteNum++;
                    if (jDown == MISS)
                    {
                        jDown = j;
                    }
                }
            }
            if (upLineWhiteNum == 2 && downLineWhiteNum == 1)
            {
                if (my_road[i + 1].connected[jDown].right > my_road[i].connected[jUpLeft].right && my_road[i + 1].connected[jDown].left < my_road[i].connected[jUpRight].left)
                {
                    cuspLine = i;
                    printf("cuspline:%d\n", cuspLine);
                    break;
                }
            }
        }
        if (cuspLine != MISS)
        {
            *ptrStateEnum |= 0x0100;
        }
        else
        {
            *ptrStateEnum |= 0x0001;
        }
    }
    else
    {
        //看看左下角丢线没有
        uint8_t leftMissCont = 0, iStart = MISS;
        for (uint8_t i = NEAR_LINE; i > 40; i--)
        {
            if (leftEdge[i] - left_side[i] <= 3)
            {
                leftMissCont++;
            }
            else if (leftEdge[i] - left_side[i] > 3 && iStart == MISS)
            {
                iStart = i;
            }
        }
        //看顶上赛道边斜率
        if (leftMissCont >= 30 && iStart != MISS)
        {

            iStart -= 25;
            if (leftEdge[FAR_LINE] != leftEdge[iStart])
            {
                float leftK = (FAR_LINE - (float)iStart) / ((float)leftEdge[FAR_LINE] - leftEdge[iStart]);
                printf("leftk:%f\n", leftK);
                //找尖点位置
                for (uint8_t i = FAR_LINE; i <= FAR_LINE + 65; i++)
                {
                    //找靠左的真正白条编号
                    uint8_t jEnd = my_road[i].white_num, jFir = 0, jSec = 0, jDown = 0;
                    for (uint8_t j = 1; j <= jEnd; j++)
                    {
                        if (my_road[i].connected[j].width > 15)
                        {
                            if (jFir == 0)
                            {
                                jFir = j;
                            }
                            else
                            {
                                jSec = j;
                                break;
                            }
                        }
                    }
                    jEnd = my_road[i + 1].white_num;
                    for (uint8_t j = 1; j <= 1; j++)
                    {
                        if (my_road[i + 1].connected[j].width > 25)
                        {
                            jDown = j;
                            break;
                        }
                    }
                    //三个都找到，记录中值
                    if (jFir && jSec && jDown)
                    {
                        uint8_t upMiddlePos = my_road[i].connected[jFir].left / 4 + my_road[i].connected[jFir].right / 4 + my_road[i].connected[jSec].left / 4 + my_road[i].connected[jSec].right / 4;
                        uint8_t downMiddle = my_road[i + 1].connected[jDown].left / 2 + my_road[i + 1].connected[jDown].right / 2;
                        if (abs(upMiddlePos - downMiddle) <= 15)
                        {
                            cuspLine = i;
                            /*for (uint8_t j = my_road[i].connected[jFir].right; j <= my_road[i].connected[jSec].left; j++)
                            {
                                IMG[i][j] = green;
                            }*/
                            break;
                        }
                    }

                }
                if (cuspLine != MISS)
                {
                    uint8_t whiteIndexUp = image_GetWIndex(_left, FAR_LINE), whiteIndexDown = image_GetWIndex(_left, cuspLine);
                    if (whiteIndexUp && whiteIndexDown)
                    {
                        float rightK = (FAR_LINE - (float)cuspLine) / (my_road[FAR_LINE].connected[whiteIndexUp].right - (float)my_road[cuspLine].connected[whiteIndexDown].right);
                        printf("rightK:%f\n", rightK);
                        if (abs(leftK - rightK) < 0.3)
                        {
                            *ptrStateEnum |= 0x0100;
                            return;
                        }
                    }
                }
            }
        }
    }
}

////////////////////////////////////////////
//功能：边线弯曲程度判断
//输入：
//输出：
//备注：标志位：1为弯道 0为直道
///////////////////////////////////////////
uint8_t image_LineIfStraight(uint8_t* ptrLine, uint8_t startLine, uint8_t endLine, float* ptrVaric)
{
    uint8_t lineEnum = 0;
    uint8_t iStart = MISS;
    float k, b;
    int output, sumVaric = 0;
    float Varic;
    for (uint8_t i = 0; i < 20; i++)
    {
        if (*(ptrLine + i) != MISS)
        {
            printf("istart:%d\n", i);
            iStart = i;
            break;
        }
    }
    if (iStart == MISS)
    {
        return 0x02;//在逆透视情况下弯道处赛道如此近，很可能要跑出赛道了
    }
    k = ((float)(ptrLine[endLine]) - (float)(ptrLine[iStart])) / (endLine - iStart);
    b = (float)(ptrLine[endLine]) - k * endLine;
    for (uint8_t i = iStart; i <= endLine; i++)
    {
        output = k * i + b;
        IMG[i][output] = purple;
        output = output - ptrLine[i];
        output *= output;
        sumVaric += output;
    }
    Varic = (float)sumVaric / (endLine - iStart);
    *ptrVaric = Varic;
    printf("Varic:%f\n", Varic);
    //是否为弯道
    if (Varic > 50)
    {
        lineEnum |= 0x02;
    }
    return lineEnum;

}

////////////////////////////////////////////
//功能：边线底部是否竖直
//输入：direct:0为左线 1为右线
//输出：
//备注：标志位：1为弯道 0为竖直
///////////////////////////////////////////

uint8_t image_RootLineIfAbsStraight(uint8_t* ptrLine, uint8_t direct)
{
    uint8_t lineEnum = 0, iStart = MISS;
    int outPut = 0, Varic = 0;
    if (direct == 0)//左线
    {
        //寻找巡线起始行
        for (uint8_t i = NEAR_LINE - 8; i >= NEAR_LINE - 50; i--)
        {
            if (ptrLine[i] != MISS && abs(ptrLine[i] - left_side[i]) >= 4)
            {
                iStart = i;
                break;
            }
        }
        if (iStart <= 90 || iStart == 255)
        {
            return 0x02;
        }
        //统计均值
        int averPos = 0;
        for (uint8_t i = iStart; i > iStart - 5; i--)
        {
            averPos += ptrLine[i];
        }
        averPos /= 5;
        //计算方差
        for (uint8_t i = iStart; i > iStart - 20; i--)
        {
            outPut = averPos - ptrLine[i];
            outPut *= outPut;
            Varic += outPut;
        }
        Varic /= 20;
        printf("left Root Varic:%d\n", Varic);
        if (Varic > 10)
        {
            return 0x02;
        }
        else
        {
            return 0;
        }
    }
    else if (direct == 1)//右边线
    {
        //寻找巡线起始行
        for (uint8_t i = NEAR_LINE - 8; i >= NEAR_LINE - 50; i--)
        {
            if (ptrLine[i] != MISS && abs(ptrLine[i] - right_side[i]) >= 4)
            {
                iStart = i;
                break;
            }
        }
        if (iStart <= 90 || iStart == 255)
        {
            return 0x02;
        }
        //统计均值
        int averPos = 0;
        for (uint8_t i = iStart; i > iStart - 5; i--)
        {
            averPos += ptrLine[i];
        }
        averPos /= 5;
        //计算方差
        for (uint8_t i = iStart; i > iStart - 20; i--)
        {
            outPut = averPos - ptrLine[i];
            outPut *= outPut;
            Varic += outPut;
        }
        Varic /= 20;
        printf("right Root Varic:%d\n", Varic);
        if (Varic > 10)
        {
            return 0x02;
        }
        else
        {
            return 0;
        }
    }

}

void image_TiltEnterTriCrossGetFeature(TiltEnterTriCross_t* ptrTiltMgr)
{
    uint8_t* ptrLeftEdge = &leftEdge[NEAR_LINE - 10], * ptrRightEdge = &rightEdge[NEAR_LINE - 10], * ptrLeftSide = &left_side[NEAR_LINE - 10], * ptrRightSide = &right_side[NEAR_LINE - 10];
    //初始化特征结构体
    ptrTiltMgr->rightMissCount = 0, ptrTiltMgr->leftMissCount = 0, ptrTiltMgr->leftBreakPoint = MISS, ptrTiltMgr->rightBreakPoint = MISS, ptrTiltMgr->cuspLine = MISS, ptrTiltMgr->crossFlag = 0, ptrTiltMgr->notTridentFlag = 0, ptrTiltMgr->tridentFlag = 0;
    printf("-----------------------------\nTiltMgr:\n");
    //丢线个数
    uint8_t iLeftDown = MISS, iRightDown = MISS;
    for (uint8_t i = NEAR_LINE - 10; i > 43; i--)
    {
        if (*ptrLeftEdge - *ptrLeftSide < 4)
        {
            ptrTiltMgr->leftMissCount++;
        }
        else if (iLeftDown == MISS)
        {
            iLeftDown = i;
        }
        if (*ptrRightSide - *ptrRightEdge < 4)
        {
            ptrTiltMgr->rightMissCount++;
        }
        else if (iRightDown == MISS)
        {
            iRightDown = i;
        }
        ptrLeftEdge--, ptrRightEdge--, ptrLeftSide--, ptrRightSide--;
    }
    printf("leftMissCount:%d\nrightMissCount:%d\n", ptrTiltMgr->leftMissCount, ptrTiltMgr->rightMissCount);
    //寻找左边线小折点
    float kLeftLast = MISS;
    for (uint8_t i = 105; i > 10; i--)
    {
        if (abs(leftEdge[i] - leftEdge[i - 9]) > 2)
        {
            float kCur = (9) / ((float)leftEdge[i] - leftEdge[i - 9]);
            //printf("K:%f,i:%d\n", kCur, i);
            if (kCur < 0)
            {
                kLeftLast = kCur;
            }
            else if (kCur > 0 && kLeftLast != MISS && kLeftLast < 0)
            {
                ptrTiltMgr->leftBreakPoint = i;
                break;
            }
        }
    }
    printf("leftBreakPoint:%d\n", ptrTiltMgr->leftBreakPoint);
    //修正斜率
    if (ptrTiltMgr->leftBreakPoint != MISS)
    {
        for (uint8_t i = ptrTiltMgr->leftBreakPoint; i < ptrTiltMgr->leftBreakPoint + 25; i++)
        {
            if (leftEdge[i] > leftEdge[i + 4] && leftEdge[i] - leftEdge[i + 4] > 1)
            {
                if (leftEdge[i] > leftEdge[i + 8] && leftEdge[i] - leftEdge[i + 8] > 2)
                {
                    kLeftLast = 8 / ((float)leftEdge[i + 8] - (float)leftEdge[i]);
                    printf("i:%d\n", i);
                    break;
                }
            }
        }
    }
    //寻找右边线小折点
    float kRightLast = MISS;
    for (uint8_t i = 105; i > 10; i--)
    {
        if (abs(rightEdge[i] - rightEdge[i - 9]) > 2)
        {
            float kCur = (9) / ((float)rightEdge[i] - rightEdge[i - 9]);
            //printf("K:%f,i:%d\n", kCur, i);
            if (kCur > 0)
            {
                kRightLast = kCur;
            }
            else if (kCur < 0 && kRightLast != MISS && kRightLast > 0)
            {
                ptrTiltMgr->rightBreakPoint = i;
                break;
            }
        }
    }
    printf("rightBreakPoint:%d\n", ptrTiltMgr->rightBreakPoint);
    //修正斜率
    if (ptrTiltMgr->rightBreakPoint != MISS)
    {
        for (uint8_t i = ptrTiltMgr->rightBreakPoint; i < ptrTiltMgr->rightBreakPoint + 25; i++)
        {
            if (rightEdge[i] < rightEdge[i + 4] && rightEdge[i + 4] - rightEdge[i]>1)
            {
                if (rightEdge[i] < rightEdge[i + 8] && rightEdge[i + 8] - rightEdge[i]>2)
                {
                    kRightLast = 8 / ((float)rightEdge[i + 8] - (float)rightEdge[i]);
                    //printf("i:%d\n", i);
                    break;
                }
            }
        }
    }
    //寻找黑尖点
    for (uint8_t i = FAR_LINE + 3; i < FAR_LINE + 60; i++)
    {
        uint8_t jEnd = my_road[i].white_num, jFir = 0, jSec = 0, jDown = 0;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i].connected[j].width > 20)
            {
                if (jFir == 0)
                {
                    jFir = j;
                }
                else if (jSec == 0)
                {
                    jSec = j;
                    break;
                }
            }
        }
        jEnd = my_road[i + 1].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[i + 1].connected[j].width > 25)
            {
                jDown = j;
                break;
            }
        }
        if (jFir && jSec && jDown)
        {
            if (my_road[i].connected[jFir].right > my_road[i + 1].connected[jDown].left && my_road[i].connected[jSec].left < my_road[i + 1].connected[jDown].right)
            {
                ptrTiltMgr->cuspLine = i;
                break;
            }
        }
    }
    printf("cuspLine:%d\n", ptrTiltMgr->cuspLine);
    //若对角线平行，也不可能是三叉,但可能环岛
    if (ptrTiltMgr->leftMissCount >28  && ptrTiltMgr->rightMissCount < 30)//右斜入
    {
        if (edgeLineEnum & 0x10)//左边未丢失信息
        {
            iLeftDown = MISS;
            for (uint8_t i = 70; i > 15; i--)
            {
                if (leftEdge[i] - left_side[i] > 20)
                {
                    iLeftDown = i;
                    break;
                }
            }
            printf("ileftDown:%d\n", iLeftDown);
            uint8_t iLeftTop = MISS;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 30; i++)
            {
                if (leftEdge[i] - left_side[i] > 2)
                {
                    iLeftTop = i;
                    break;
                }
            }
            if (iLeftDown <80 && iLeftTop != MISS)
            {
                uint8_t judgeFlag = 1;
                if (iLeftDown > 30)
                {
                    uint8_t leftTopMissCount = 0;
                    for (uint8_t i = iLeftDown; i > iLeftDown-25; i--)
                    {
                        if (leftEdge[i] - left_side[i] < 2)
                        {
                            leftTopMissCount++;
                        }
                    }
                    printf("leftTopMissCount:%d\n", leftTopMissCount);
                    if (leftTopMissCount > 10)
                    {
                        judgeFlag = 0;
                    }
                    uint8_t leftValidCount = 0;
                    for (uint8_t i = iLeftDown; i < iLeftDown + 25; i++)
                    {
                        if (leftEdge[i] - left_side[i] > 10)
                        {
                            leftValidCount++;
                        }
                    }
                    if (leftValidCount >= 10)
                    {
                        judgeFlag = 0;
                    }
                }
                if (abs(leftEdge[iLeftTop] - leftEdge[iLeftDown - 8]) >= 2&&judgeFlag)
                {
                    float topK = ((float)iLeftTop - iLeftDown + 8) / ((float)leftEdge[iLeftTop] - leftEdge[iLeftDown - 8]);
                    if (ptrTiltMgr->rightBreakPoint != MISS)
                    {
                        printf("topK:%f\ndownK:%f\n", atan(topK), atan(kRightLast));
                        if (topK > 0 && kRightLast > 0 && abs(atan(topK) - atan(kRightLast)) < 0.30)
                        {
                            printf("Not Trident Flag Get\n");
                            ptrTiltMgr->notTridentFlag = 1;
                        }
                    }
                    else
                    {
                        uint8_t rightXFir = rightEdge[NEAR_LINE - 3] / 3 + rightEdge[NEAR_LINE - 4] / 3 + rightEdge[NEAR_LINE - 5] / 3;
                        uint8_t rightXSec = rightEdge[NEAR_LINE - 15] / 3 + rightEdge[NEAR_LINE - 16] / 3 + rightEdge[NEAR_LINE - 17] / 3;
                        if (abs(rightXFir - rightXSec) >= 2)
                        {
                            float kDown = (12) / ((float)rightXFir - rightXSec);
                            printf("topK:%f\ndownK:%f\n", atan(topK), atan(kDown));
                            if (topK > 0 && kDown > 0 && abs(atan(topK) - atan(kDown)) < 0.30)
                            {
                                printf("Not Trident Flag Get\n");
                                ptrTiltMgr->notTridentFlag = 1;
                            }
                        }
                    }
                }
            }
        }
    }
    if (ptrTiltMgr->leftMissCount < 30 && ptrTiltMgr->rightMissCount>28)//右边丢线很多，左边线比较完整，左斜入
    {
        if (edgeLineEnum & 0x01)//右边未丢失信息
        {
            iRightDown = MISS;
            for (uint8_t i = 70; i > 15; i--)
            {
                if (right_side[i] - rightEdge[i] > 20)
                {
                    iRightDown = i;
                    break;
                }
            }
            //printf("iRightDown:%d\n", iRightDown);
            uint8_t iRightTop = MISS;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 30; i++)
            {
                if (right_side[i] - rightEdge[i] > 2)
                {
                    iRightTop = i;
                    break;
                }
            }
            if (iRightDown <80 && iRightTop != MISS)
            {
                uint8_t judgeFlag = 1;
                if (iRightDown > 30)
                {
                    uint8_t rightTopMissCount = 0;
                    for (uint8_t i = iRightDown; i > iRightDown - 25; i--)
                    {
                        if (right_side[i]-rightEdge[i] < 2)
                        {
                            rightTopMissCount++;
                        }
                    }
                    printf("leftTopMissCount:%d\n", rightTopMissCount);
                    if (rightTopMissCount > 10)
                    {
                        judgeFlag = 0;
                    }
                    uint8_t rightValidCount = 0;
                    for (uint8_t i = iRightDown; i < iRightDown + 25; i++)
                    {
                        if (right_side[i] - rightEdge[i] > 10)
                        {
                            rightValidCount++;
                        }
                    }
                    if (rightValidCount >= 10)
                    {
                        judgeFlag = 0;
                    }
                    //printf("rightValidCount:%d\n", rightValidCount);
                }
                if (abs((float)rightEdge[iRightTop] - rightEdge[iRightDown - 8]) >= 2&&judgeFlag)
                {
                    float topK = ((float)iRightTop - iRightDown + 8) / ((float)rightEdge[iRightTop] - rightEdge[iRightDown - 8]);
                    if (ptrTiltMgr->leftBreakPoint != MISS)
                    {
                        printf("topK:%f\ndownK:%f\n", atan(topK), atan(kLeftLast));
                        if (topK < 0 && kLeftLast < 0 && abs(atan(topK) - atan(kLeftLast)) < 0.30)
                        {
                            printf("Not Trident Flag Get\n");
                            ptrTiltMgr->notTridentFlag = 1;
                        }
                    }
                    else
                    {
                        uint8_t leftXFir = leftEdge[NEAR_LINE - 3] / 3 + leftEdge[NEAR_LINE - 4] / 3 + leftEdge[NEAR_LINE - 5] / 3;
                        uint8_t leftXSec = leftEdge[NEAR_LINE - 15] / 3 + leftEdge[NEAR_LINE - 16] / 3 + leftEdge[NEAR_LINE - 17] / 3;
                        if (abs(leftXFir - leftXSec) >= 2)
                        {
                            float kDown = (12) / ((float)leftXFir - leftXSec);
                            printf("topK:%f\ndownK:%f\n", atan(topK), atan(kDown));
                            if (topK < 0 && kDown < 0 && abs(atan(topK) - atan(kDown)) < 0.30)
                            {
                                printf("Not Trident Flag Get\n");
                                ptrTiltMgr->notTridentFlag = 1;
                            }
                        }
                    }
                }
            }
        }
    }
    //若有黑尖点，寻找十字平行标志
    if (ptrTiltMgr->cuspLine != MISS)
    {
        if (ptrTiltMgr->leftMissCount < 30 && ptrTiltMgr->rightMissCount>35)//右边丢线很多，左边线比较完整，左斜入
        {
            //底部与尖点平行，十字误判
            uint8_t whiteIndexUp = image_GetWIndex(_right, FAR_LINE), whiteIndexDown = image_GetWIndex(_right, ptrTiltMgr->cuspLine);
            if (whiteIndexUp && whiteIndexDown)
            {
                uint8_t topXFir = my_road[FAR_LINE].connected[whiteIndexUp].left;
                uint8_t topXSec = my_road[ptrTiltMgr->cuspLine].connected[whiteIndexDown].left;
                if (abs(topXFir - topXSec) >= 2)
                {
                    float topK = ((float)FAR_LINE - ptrTiltMgr->cuspLine) / ((float)topXFir - topXSec);
                    if (ptrTiltMgr->leftBreakPoint != MISS)
                    {
                        printf("topK:%f\ndownK:%f\n", topK, kLeftLast);
                        printf("topK:%f\ndownK:%f\n", atan(topK), atan(kLeftLast));
                        if (topK < 0 && kLeftLast < 0 && abs(atan(topK) - atan(kLeftLast)) < 0.17)
                        {
                            printf("crossFlag Get\n");
                            ptrTiltMgr->crossFlag = 1;
                        }
                    }
                    else
                    {
                        uint8_t leftXFir = leftEdge[NEAR_LINE - 3] / 3 + leftEdge[NEAR_LINE - 4] / 3 + leftEdge[NEAR_LINE - 5] / 3;
                        uint8_t leftXSec = leftEdge[NEAR_LINE - 11] / 3 + leftEdge[NEAR_LINE - 12] / 3 + leftEdge[NEAR_LINE - 13] / 3;
                        if (abs(leftXFir - leftXSec) >= 2)
                        {
                            float kDown = (8) / ((float)leftXFir - leftXSec);
                            printf("topK:%f\ndownK:%f\n", atan(topK), atan(kDown));
                            if (topK < 0 && kDown < 0 && abs(atan(topK) - atan(kDown)) < 0.17)
                            {
                                printf("crossFlag Get\n");
                                ptrTiltMgr->crossFlag = 1;
                            }
                        }
                    }
                }
            }
        }
        else if (ptrTiltMgr->leftMissCount > 35 && ptrTiltMgr->rightMissCount < 30)
        {
            //底部与尖点平行，十字误判
            uint8_t whiteIndexUp = image_GetWIndex(_left, FAR_LINE), whiteIndexDown = image_GetWIndex(_left, ptrTiltMgr->cuspLine);
            if (whiteIndexUp && whiteIndexDown)
            {
                uint8_t topXFir = my_road[FAR_LINE].connected[whiteIndexUp].right;
                uint8_t topXSec = my_road[ptrTiltMgr->cuspLine].connected[whiteIndexDown].right;
                if (abs(topXFir - topXSec) >= 2)
                {
                    float topK = ((float)FAR_LINE - ptrTiltMgr->cuspLine) / ((float)topXFir - topXSec);
                    if (ptrTiltMgr->rightBreakPoint != MISS)
                    {
                        printf("topK:%f\ndownK:%f\n", atan(topK), atan(kRightLast));
                        printf("topK:%f\ndownK:%f\n", topK, kRightLast);
                        if (topK > 0 && kRightLast > 0 && abs(atan(topK) - atan(kRightLast)) < 0.17)
                        {
                            printf("crossFlag Get\n");
                            ptrTiltMgr->crossFlag = 1;
                        }
                    }
                    else
                    {
                        uint8_t rightXFir = rightEdge[NEAR_LINE - 3] / 3 + rightEdge[NEAR_LINE - 4] / 3 + rightEdge[NEAR_LINE - 5] / 3;
                        uint8_t rightXSec = rightEdge[NEAR_LINE - 11] / 3 + rightEdge[NEAR_LINE - 12] / 3 + rightEdge[NEAR_LINE - 13] / 3;
                        if (abs(rightXFir - rightXSec) >= 2)
                        {
                            float kDown = (8) / ((float)rightXFir - rightXSec);
                            printf("topK:%f\ndownK:%f\n", atan(topK), atan(kDown));
                            if (topK > 0 && kDown > 0 && abs(atan(topK) - atan(kDown)) < 0.17)
                            {
                                printf("crossFlag Get\n");
                                ptrTiltMgr->crossFlag = 1;
                            }
                        }

                    }
                }
            }
        }
    }
    printf("--------------------------------\n");
}

////////////////////////////////////////////
//功能：最小二乘法
//输入：
//输出：k为无穷大做保护
//备注：
///////////////////////////////////////////

uint8_t image_LeastSquare(float* ptrK, float* ptrB, uint8_t iStart, uint8_t iEnd, uint8_t* ptrLine)
{
    float averX = 0, averY = 0, averMultiXY = 0, averSquareX = 0, count = iEnd - iStart, RelationParam = 0, sumVarXY = 0, sumVarSquareX = 0, sumVarSquareY = 0;
    for (uint8_t i = iStart; i < iEnd; i++)
    {
        float x = ptrLine[i], y = i;
        averX += x;
        averY += y;
        averSquareX += (x * x);
        averMultiXY += (x * y);
    }
    averX /= count, averY /= count, averSquareX /= count, averMultiXY /= count;
    for (uint8_t i = iStart; i < iEnd; i++)
    {
        float varX = ptrLine[i] - averX, varY = i - averY;
        sumVarXY += (varX * varY);
        sumVarSquareX += (varX * varX);
        sumVarSquareY += (varY * varY);
    }
    if (abs(sumVarSquareX) < 1e-7 || abs(sumVarSquareY) < 1e-7)
    {
        RelationParam = 1;
    }
    else
    {
        RelationParam = (sumVarXY) / sqrt(sumVarSquareX * sumVarSquareY);
    }
    printf("RelationParam:%f\n", RelationParam);
    if (abs(averSquareX - averX * averX) < 1e-3)
    {
        return 0;
    }
    else
    {
        if (abs(RelationParam) > 0.87)
        {
            *ptrK = (averMultiXY - averX * averY) / (averSquareX - averX * averX);
            *ptrB = averY - *ptrK * averX;
        }
        else
        {
            if (ptrLine[iEnd] - ptrLine[iStart] != 0)
            {
                *ptrK = ((float)iEnd - iStart) / ((float)ptrLine[iEnd] - ptrLine[iStart]);
            }
            else
            {
                return 0;
            }
        }
        return 1;
    }
}

////////////////////////////////////////////
//功能：提取白条边缘线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_InitEdgeLine(void)
{
    uint8_t iStart = 120;
    uint8_t* ptrLedge = &leftEdge[0], * ptrRiedge = &rightEdge[0]/**ptrLeside = &left_side[0], *ptrRiside = &right_side[0]*/;
    road* ptrMyRoad = &my_road[0];
    for (uint8_t i = 0; i < CAMERA_H; i++)
    {
        *ptrLedge = MISS;
        *ptrRiedge = MISS;
        ptrLedge++, ptrRiedge++;
        /*ptrLeside++,ptrRiside++;*/
    }
    for (uint8_t i = 0; i <= NEAR_LINE; i++)//寻找最低有白条的行
    {
        if (ptrMyRoad->white_num)
        {
            iStart = i;
            break;
        }
        ptrMyRoad++;
    }
    ptrLedge = &leftEdge[iStart], ptrRiedge = &rightEdge[iStart], ptrMyRoad = &my_road[iStart];
    for (uint8_t i = iStart; i <= NEAR_LINE; i++)
    {
        uint8_t jEnd = my_road[i].white_num, maxWhiteWidth = 0;
        //寻找最长的白条
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            uint8_t curWhiteWidth = ptrMyRoad->connected[j].width;
            if (curWhiteWidth > maxWhiteWidth)
            {
                maxWhiteWidth = curWhiteWidth;
            }
        }
        if (maxWhiteWidth > 5)
        {
            *ptrLedge = (ptrMyRoad->connected[1]).left;
            *ptrRiedge = (ptrMyRoad->connected[ptrMyRoad->white_num]).right;
        }
        ptrMyRoad++;
        ptrLedge++, ptrRiedge++;
        if (leftEdge[i] != MISS)
        {
            IMG[i][leftEdge[i]] = blue;
        }
        if (rightEdge[i] != MISS)
        {
            IMG[i][rightEdge[i]] = red;
        }
    }

}

void image_InitRoadLine(void)
{
    uint8_t allRoadNum[120] = { 0 };//白条编号
    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
    {
        uint8_t jEnd = my_road[i].white_num, maxWidth = 0, maxj = MISS;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            uint8_t curWidth = my_road[i].connected[j].width;
            if (curWidth > maxWidth)
            {
                maxWidth = curWidth;
                maxj = j;
            }
            if (curWidth > 20 && abs((my_road[i].connected[j].left / 2 + my_road[i].connected[j].right / 2) - 94) < 25)
            {
                allRoadNum[i] = j;
                break;
            }
        }
        if (allRoadNum[i] == 0)
        {
            allRoadNum[i] = maxj;
        }
    }
    uint8_t iStart = 120;
    uint8_t* ptrLedge = &leftEdge[0], * ptrRiedge = &rightEdge[0]/**ptrLeside = &left_side[0], *ptrRiside = &right_side[0]*/;
    road* ptrMyRoad = &my_road[0];
    for (uint8_t i = 0; i < CAMERA_H; i++)
    {
        *ptrLedge = MISS;
        *ptrRiedge = MISS;
        ptrLedge++, ptrRiedge++;
        /*ptrLeside++,ptrRiside++;*/
    }
    for (uint8_t i = 0; i < NEAR_LINE; i++)//寻找最低有白条的行
    {
        if (ptrMyRoad->white_num)
        {
            iStart = i;
            break;
        }
        ptrMyRoad++;
    }
    ptrLedge = &leftEdge[iStart], ptrRiedge = &rightEdge[iStart], ptrMyRoad = &my_road[iStart];
    for (uint8_t i = iStart; i < NEAR_LINE; i++)
    {
        *ptrLedge = (ptrMyRoad->connected[allRoadNum[i]]).left;
        *ptrRiedge = (ptrMyRoad->connected[allRoadNum[i]]).right;
        ptrMyRoad++;
        ptrLedge++, ptrRiedge++;
        IMG[i][leftEdge[i]] = blue;
        IMG[i][rightEdge[i]] = red;
    }
}

////////////////////////////////////////////
//功能：判断左右边缘是否丢失
//输入：
//输出：
//备注：需根据自己需要修改ValidWidth 1为未丢失 0为丢失
///////////////////////////////////////////
void image_IfEdgeLineLose(uint8_t* ptrEnum)
{
    uint8_t* ptrLedge = &leftEdge[0], * ptrRiedge = &rightEdge[0], * ptrLeside = &left_side[0], * ptrRiside = &right_side[0];
    uint8_t iStart = 120;
    uint8_t leftValidWidth = 0, rightValidWidth = 0;
    //判断左白条边缘线信息是否丢失
    for (uint8_t i = 0; i < NEAR_LINE; i++)
    {
        if ((*ptrLedge) != MISS)
        {
            iStart = i;
            break;
        }
        ptrLedge++;
    }
    ptrLedge = &leftEdge[iStart], ptrLeside = &left_side[iStart];
    for (uint8_t i = iStart; i < NEAR_LINE; i++)
    {
        if ((*ptrLedge) - (*ptrLeside) > 3)
        {
            leftValidWidth++;
        }
        if (leftValidWidth > 15)
        {
            (*ptrEnum) |= 0x10;
            break;
        }
        ptrLedge++, ptrLeside++;
    }
    //判断右白条边缘线信息是否丢失
    iStart = 120;//全MISS不扫描
    for (uint8_t i = 0; i < NEAR_LINE; i++)
    {
        if ((*ptrRiedge) != MISS)
        {
            iStart = i;
            break;
        }
        ptrRiedge++;
    }
    ptrRiedge = &rightEdge[iStart], ptrRiside = &right_side[iStart];
    for (uint8_t i = iStart; i < NEAR_LINE; i++)
    {
        if ((*ptrRiside) - (*ptrRiedge) > 3)
        {
            rightValidWidth++;
        }
        if (rightValidWidth > 15)
        {
            (*ptrEnum) |= 0x01;
            break;
        }
        ptrRiedge++, ptrRiside++;
    }
    if ((*ptrEnum) & 0x10)
    {
        printf("left not lose information\n");
    }
    else
    {
        printf("left lose information\n");
    }
    if ((*ptrEnum) & 0x01)
    {
        printf("right not lose information\n");
    }
    else
    {
        printf("right lose  information\n");
    }
}



////////////////////////////////////////////
//功能：寻找左右边缘线的跳变点
//输入：
//输出：
//备注：跳变位置差值，左减右
///////////////////////////////////////////

int32_t image_FindJumpos(uint8_t* ptrEnum, uint8_t startLine, uint8_t endLine)
{
    uint8_t* ptrLedge = &leftEdge[startLine], * ptrRiedge = &rightEdge[startLine], lineEnum = 0;
    uint8_t iLeftEnd = 120, iRightEnd = 120;
    int32_t jumpPosVar = MISS;
    uint8_t ifLeEnd = 0, ifRiEnd = 0;
    float varLeft, varRight;
    leftJumpPos = MISS, rightJumpPos = MISS;
    //寻找左右边缘线的起始位置
    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
    {
        if (ifLeEnd != 1 && leftEdge[i] != MISS)
        {
            iLeftEnd = i;
            ifLeEnd = 1;
        }
        if (ifRiEnd != 1 && rightEdge[i] != MISS)
        {
            iRightEnd = i;
            ifRiEnd = 1;
        }
        if (ifLeEnd == 1 && ifRiEnd == 1)
        {
            break;
        }
    }
    //决定endline
    if (iLeftEnd >= endLine)
    {
        iLeftEnd += 3;//采用扫描到的
    }
    else if ((endLine - iLeftEnd) >= 3)
    {
        iLeftEnd = endLine;
    }
    else
    {
        iLeftEnd += 3;
    }
    if (iRightEnd >= endLine)
    {
        iRightEnd += 3;
    }
    else if ((endLine - ifRiEnd) >= 3)
    {
        iRightEnd = endLine;
    }
    else
    {
        iRightEnd += 3;
    }
    for (uint8_t i = startLine; i > endLine; i--, ptrLedge--, ptrRiedge--)
    {
        //判断左边线
        if (i >= iLeftEnd)
        {
            varLeft = (float)(*ptrLedge) - (float)(*(ptrLedge - 3));
            if (varLeft > 7 && (~lineEnum) & 0x40 && (~lineEnum) & 0x80)//左边线左右延申标志都为0时
            {
                uint8_t* ptrLedgeCy = &leftEdge[i - 1];
                for (uint8_t j = i - 1; j > i - 3; j--, ptrLedgeCy--)
                {
                    if ((float)(*ptrLedgeCy) - (float)(*(ptrLedgeCy - 1)) >= 3)
                    {
                        lineEnum |= 0x80;//左边缘线左延申
                        leftJumpPos = i;
                        break;
                    }
                }
            }
            /*else if (*ptrLedge != 0 && *(ptrLedge - 3) == 0 && *(ptrLedge - 4) == 0 && *(ptrLedge - 5) == 0 && (~lineEnum) & 0x40 && (~lineEnum) & 0x80)
            {
                lineEnum |= 0x80;
                leftJumpPos = i;
            }*/
            if (varLeft < -7 && (~lineEnum) & 0x40 && (~lineEnum) & 0x80)
            {
                uint8_t* ptrLedgeCy = &leftEdge[i - 1];
                for (uint8_t j = i - 1; j > i - 3; j--, ptrLedgeCy--)
                {
                    if ((float)(*ptrLedgeCy) - (float)(*(ptrLedgeCy - 1)) <= -3)
                    {
                        lineEnum |= 0x40;//左边线右延申
                        leftJumpPos = i;
                    }
                }
            }
        }
        //判断右边缘线
        if (i > iRightEnd)
        {
            varRight = (float)(*ptrRiedge) - (float)(*(ptrRiedge - 3));
            if (varRight < -7 && (~lineEnum) & 0x04 && (~lineEnum) & 0x08)//右边缘线左右延申标志都为0时
            {
                uint8_t* ptrRiedgeCy = &rightEdge[i - 1];
                for (uint8_t j = i - 1; j > i - 3; j--, ptrRiedgeCy--)
                {
                    if ((float)(*ptrRiedgeCy) - (float)(*(ptrRiedgeCy - 1)) <= -3)
                    {
                        lineEnum |= 0x04;//右边线右延申
                        rightJumpPos = i;
                    }
                }
            }
            /*else if (*ptrRiedge != 187 && *(ptrRiedge - 3) == 187 && *(ptrRiedge - 4) == 187 && *(ptrRiedge - 5) == 187 && (~lineEnum) & 0x04 && (~lineEnum) & 0x08)
            {
                lineEnum |= 0x04;
                rightJumpPos = i;
            }*/
            if (varRight > 7 && (~lineEnum) & 0x04 && (~lineEnum) & 0x08)
            {
                uint8_t* ptrRiedgeCy = &rightEdge[i - 1];
                for (uint8_t j = i - 1; j > i - 3; j--, ptrRiedgeCy--)
                {
                    if ((float)(*ptrRiedgeCy) - (float)(*(ptrRiedgeCy - 1)) >= 3)
                    {
                        lineEnum |= 0x08;//右边线左延申
                        rightJumpPos = i;
                    }
                }
            }
        }
    }
    jumpPosVar = (float)leftJumpPos - (float)rightJumpPos;
    //识别结果打印
    if (lineEnum & 0x40)
    {
        printf("左边线右延申\n");
    }
    if (lineEnum & 0x80)
    {
        printf("左边线左延申\n");
    }
    if (lineEnum & 0x04)
    {
        printf("右边线右延申\n");
    }
    if (lineEnum & 0x08)
    {
        printf("右边线左延申\n");
    }
    printf("left jump pos:%d\n", leftJumpPos);
    printf("right jump pos:%d\n", rightJumpPos);
    if (leftJumpPos != MISS)
    {
        IMG[leftJumpPos][leftEdge[leftJumpPos]] = green;
    }
    if (rightJumpPos != MISS)
    {
        IMG[rightJumpPos][rightEdge[rightJumpPos]] = green;
    }
    if (leftJumpPos != MISS && rightJumpPos != MISS)
    {
        jumpPosVar = (float)leftJumpPos - (float)rightJumpPos;
    }
    *ptrEnum |= lineEnum;
    return jumpPosVar;
}

uint8_t image_FindTopAbsBlackNum(uint8_t iStart, uint8_t iEnd, uint8_t minWhiteWidth)
{
    uint8_t blackNum = 0;
    for (uint8_t i = iStart; i < iEnd; i++)
    {
        uint8_t jEnd = my_road[i].white_num;
        if (jEnd == 0)
        {
            blackNum++;
        }
        else
        {
            uint8_t maxWhiteWidth = 0;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                uint8_t curWhiteWidth = my_road[i].connected[j].width;
                if (curWhiteWidth > maxWhiteWidth)
                {
                    maxWhiteWidth = curWhiteWidth;
                }
            }
            if (maxWhiteWidth < minWhiteWidth)
            {
                blackNum++;
            }
        }
    }
    return blackNum;
}

////////////////////////////////////////////
//功能：根据状态机决定补线策略
//输入：
//输出：
//备注：
///////////////////////////////////////////
uint8_t roadWidth = 26;
uint8_t roundPatchFlag = 0;
#define up 0
#define down 1
#define _left 0
#define _right 1
#define _default 2
#define _mid 3
#define carForeheadCol 106
#define carForeheadLeft 66
#define carForefeadRight 122
void image_EdgePatching(void)
{
    ////ordinary_two_line();
    roundPatchFlag = 0;
    for (uint8_t i = 1; i < 119; i++)
    {
        left_line[i] = my_road[i].connected[image_GetWIndex(_default, i)].left;
        right_line[i] = my_road[i].connected[image_GetWIndex(_default, i)].right;
    }
    if (downRampFlag == 1)
    {
        get_mid_line();
        return;
    }
    switch (stateMgr.curtState)
    {
    case leftTiltEnterTrident:
    {
        if (circleNum == 1)
        {
            uint8_t pos = MISS;
            for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
            {
                uint8_t indx = image_GetWIndex(_left, i);
                if (my_road[i].connected[indx].width != 0 && my_road[i].connected[indx].right < 110)
                {
                    pos = i;
                    break;
                }
            }
            if (pos != MISS)
            {
                image_Line2Points(my_road[pos].connected[image_GetWIndex(_left, pos)].right, pos, carForefeadRight, carForeheadCol, right_line);
            }
            else
            {
                uint8_t downPoint = MISS;
                for (uint8_t i = NEAR_LINE; i > 60; i--)
                {
                    if (left_line[i] != left_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS)
                {
                    float k, b;
                    image_LeastSquare(&k, &b, TiltFeatureMgr.leftBreakPoint + 10, downPoint, left_line);
                    uint8_t width = abs(roadWidth * cos(atan(k)));
                    if (width > 18)width = 18;
                    //printf("width:%d", width);
                    image_GetMidSgl(left_line, _left, 1, 106, my_road[106].connected[image_GetWIndex(_mid, 106)].width / 2);

                    for (uint8_t i = downPoint - width; i > FAR_LINE; i--)
                    {
                        mid_line[i + width] = mid_line[i];
                    }
                    image_MidLineCorrector(15);
                    image_MidLineFilter();
                }
                break;
            }
        }
        else
        {
            if (TiltFeatureMgr.cuspLine != MISS)
            {
                image_Line2Points(my_road[TiltFeatureMgr.cuspLine].connected[image_GetWIndex(_left, TiltFeatureMgr.cuspLine)].right, TiltFeatureMgr.cuspLine, carForeheadLeft, carForeheadCol, left_line);
            }
            else
            {
                uint8_t point = MISS;
                image_FindPatchPos(down, &point, 100, 60);
                if (point != MISS)
                {
                    if (point < 10)
                    {
                        uint8_t leftPoint = TiltFeatureMgr.leftBreakPoint;
                        //image_FindBreakPoint(left_line, 0, &leftPoint);
                        if (leftPoint != MISS)
                        {
                            for (uint8_t i = leftPoint; i < 106; i++)
                            {
                                if (left_line[i] > left_line[i + 1] && left_line[i] - left_line[i + 1] >= 1)
                                {
                                    leftPoint = i;
                                    break;
                                }
                            }
                        }
                        uint8_t rightPoint = MISS;
                        for (uint8_t i = FAR_LINE; i < 60; i++)
                        {
                            if (right_line[i] < right_line[i + 1] && right_line[i + 1] - right_line[i]>20)
                            {
                                rightPoint = i;
                                break;
                            }
                        }
                        //float k = image_LineRange(left_line[leftPoint], leftPoint, 10, 1, left_line, left_line, up);
                        if (rightPoint != MISS && leftPoint != MISS)
                        {
                            float k = image_Line2Points(my_road[rightPoint].connected[image_GetWIndex(_left, rightPoint)].right, rightPoint, left_line[leftPoint], leftPoint, left_line);
                            image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
                        }
                    }
                    else
                    {
                        image_Line2Points(my_road[point - 5].connected[image_GetWIndex(_left, point - 5)].right, point - 5, carForeheadLeft, carForeheadCol, left_line);
                    }
                }
            }
        }
        get_mid_line();
        image_MidLineCorrector(10);
        //image_MidLineFilter();
        break;
    }
    case rightTiltEnterTrident:
    {
        if (circleNum == 1)
        {
            if (TiltFeatureMgr.cuspLine != MISS)
            {
                image_Line2Points(my_road[TiltFeatureMgr.cuspLine].connected[image_GetWIndex(_right, TiltFeatureMgr.cuspLine)].left, TiltFeatureMgr.cuspLine, carForefeadRight, carForeheadCol, right_line);
            }
            else
            {
                uint8_t point = MISS;
                image_FindPatchPos(down, &point, 100, 60);
                //image_Line2Points(my_road[60].connected[image_GetWIndex(_left, 60)].right, 60, carForefeadRight, carForeheadCol, right_line);
                if (point != MISS)
                {
                    if (point < 10)
                    {
                        uint8_t leftPoint = MISS;
                        for (uint8_t i = FAR_LINE; i < 60; i++)
                        {
                            if (left_line[i] > left_line[i + 1] && left_line[i] - left_line[i+1]>20)
                            {
                                leftPoint = i;
                                break;
                            }
                        }
                        uint8_t rightPoint = TiltFeatureMgr.rightBreakPoint;
                        for (uint8_t i = rightPoint; i < 106; i++)
                        {
                            if (right_line[i] < right_line[i + 1] && right_line[i + 1] - right_line[i] >= 1)
                            {
                                rightPoint = i;
                                break;
                            }
                        }
                        if (rightPoint != MISS && leftPoint != MISS)
                        {
                            float k = image_Line2Points(my_road[leftPoint].connected[image_GetWIndex(_right, leftPoint)].right, leftPoint, right_line[rightPoint], rightPoint, right_line);
                            image_GetMidSgl(right_line, _right, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
                        }
                    }
                    else
                    {
                        image_Line2Points(my_road[point - 5].connected[image_GetWIndex(_right, point - 5)].left, point - 5, carForefeadRight, carForeheadCol, right_line);
                    }
                }
            }
        }
        else
        {
            uint8_t pos = MISS;
            for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
            {
                uint8_t indx = image_GetWIndex(_right, i);
                if (my_road[i].connected[indx].width != 0 && my_road[i].connected[indx].left > 78)
                {
                    pos = i;
                    break;
                }
            }
            if (pos != MISS)
            {
                image_Line2Points(my_road[pos].connected[image_GetWIndex(_right, pos)].left, pos, carForeheadLeft, carForeheadCol, left_line);
            }
            else
            {
                uint8_t downPoint = MISS;
                for (uint8_t i = NEAR_LINE; i > 60; i--)
                {
                    if (right_line[i] != right_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS)
                {
                    float k, b;
                    image_LeastSquare(&k, &b, TiltFeatureMgr.rightBreakPoint + 10, downPoint, right_line);
                    uint8_t width = abs(roadWidth * cos(atan(k)));
                    if (width > 18)width = 18;
                    //printf("width:%d", width);
                    image_GetMidSgl(right_line, _right, 1, 106, my_road[106].connected[image_GetWIndex(_mid, 106)].width / 2);
                    for (uint8_t i = downPoint - width; i > FAR_LINE; i--)
                    {
                        mid_line[i + width] = mid_line[i];
                    }
                    image_MidLineCorrector(10);
                    image_MidLineFilter();
                }
                break;
            }
        }
        //if (cuspLine != MISS)
        //{
        //	if (circleNum == 1)//左转
        //	{
        //		image_Line2Points(my_road[cuspLine].connected[image_GetWIndex(_right, cuspLine)].left, cuspLine, carForeheadLeft, carForeheadCol, left_line);
        //	}
        //	else//右转
        //	{
        //		image_Line2Points(my_road[cuspLine].connected[image_GetWIndex(_right, cuspLine)].left, cuspLine, carForefeadRight, carForeheadCol, right_line);
        //	}
        //}
        get_mid_line();
        image_MidLineCorrector(15);
        image_MidLineFilter();
        break;
    }
    case enterTrident:
    {
        if (circleNum == 0)
        {
            image_GetMidSgl(right_line, _right, 1, 106, 30);
        }
        else if (circleNum == 1)
        {
            image_GetMidSgl(left_line, _left, 1, 106, 30);
        }
        image_MidLineCorrector(20);
        break;
    }
    case enterTriCross:
    {
        uint8_t point_right = 0, point_left = 0, breakPointFix = 255;
        //image_FindPatchPointEX(up, _right, &point, right_line);
        image_FindBreakPoint(right_line, 1, &point_right);
        if (point_right != 255)
        {
            for (breakPointFix = point_right; breakPointFix < point_right + 20; breakPointFix++)
            {
                if (right_line[breakPointFix] < right_line[breakPointFix + 1] && right_line[breakPointFix + 1] - right_line[breakPointFix] >= 1)
                {
                    point_right = breakPointFix;
                    break;
                }
            }
        }
        /*if (point < 90)
        {
            uint8_t downPoint = MISS;
            for (uint8_t i = point + 10; i > point + 5; i--)
            {
                if (right_line[i] != right_side[i])
                {
                    downPoint = i;
                    break;
                }
            }
            if (downPoint != MISS)
            {
                image_LineRange(right_line[point], point, downPoint - point, 1, right_line, right_line, up);
            }
        }*/
        //image_FindPatchPointEX(up, _left, &point, left_line);
        image_FindBreakPoint(left_line, 0, &point_left);
        if (point_left != 255)
        {
            for (breakPointFix = point_left; breakPointFix < point_left + 20; breakPointFix++)
            {
                if (left_line[breakPointFix] > left_line[breakPointFix + 1] && left_line[breakPointFix] - left_line[breakPointFix + 1] >= 1)
                {
                    point_left = breakPointFix;
                    break;
                }
            }
        }
        if (point_right < 90 && point_left < 90)
        {
            uint8_t point = point_right > point_left ? point_right : point_left;
            uint8_t downPoint_left = MISS, downPoint_right = MISS;
            for (uint8_t i = NEAR_LINE; i > point + 5; i--)
            {
                if (left_line[i] - left_side[i] > 2)
                {
                    downPoint_left = i;
                    break;
                }
            }
            for (uint8_t i = NEAR_LINE; i > point + 5; i--)
            {
                if (right_side[i] - right_line[i] > 2)
                {
                    downPoint_right = i;
                    break;
                }
            }
            if (downPoint_left != MISS && downPoint_right != MISS)
            {
                image_LineRange(left_line[point + 5], point + 5, downPoint_left - point - 5, 1, left_line, left_line, up);
                image_LineRange(right_line[point + 5], point + 5, downPoint_right - point - 5, 1, right_line, right_line, up);
                get_mid_line();
            }
            else if (downPoint_left == MISS && downPoint_right != MISS)
            {
                get_mid_line();
                float k = image_LineRange(right_line[point + 5], point + 5, downPoint_right - point - 5, 1, right_line, right_line, up);
                if (abs(k) < 1e-5)	k = 1e-5;
                image_GetMidSgl(right_line, _right, 1, downPoint_right, abs(roadWidth / (sin(atan(1 / k)))));
            }
            else if (downPoint_left != MISS && downPoint_right == MISS)
            {
                get_mid_line();
                float k = image_LineRange(left_line[point + 5], point + 5, downPoint_left - point - 5, 1, left_line, left_line, up);
                if (abs(k) < 1e-5)	k = 1e-5;
                image_GetMidSgl(left_line, _left, 1, downPoint_left, abs(roadWidth / (sin(atan(1 / k)))));
            }
            else
            {
                my_memset(mid_line, 94, 120);
            }
        }
        //get_mid_line();
        break;
    }
    case TridentStage2:
    case TridentStage3:
    {
        uint8_t indxup = 0, indxdn = carForeheadCol;
        image_FindPatchPos(down, &indxup, 100, 60);
        for (uint8_t i = 10; i < 95; i++)
        {
            if (image_GetWIndex(_left, i) != image_GetWIndex(_right, i))
            {
                indxup = i;
                //break;
            }
        }
        if (circleNum)					//TODO:转向条件
        {
            for (uint8_t i = 1; i < 119; i++)
            {
                left_line[i] = my_road[i].connected[image_GetWIndex(_left, i)].left;
                right_line[i] = my_road[i].connected[image_GetWIndex(_left, i)].right;
            }
            uint8_t validNum = 0;
            for (uint8_t i = 100; i > 90; i--)
            {
                if (leftEdge[i] - left_side[i] >= 4)
                {
                    validNum++;
                }
            }
            printf("validNum:%d", validNum);
            image_FindBreakPoint(right_line, 1, &indxdn);
            if (indxdn != MISS)
            {
                for (uint8_t i = indxdn; i < 106; i++)
                {
                    if (right_line[i] <= right_line[i + 3])
                    {
                        indxdn = i;
                        break;
                    }
                }
            }
            if (indxdn > 90 || validNum < 5)
            {
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].left, indxup, left_line[indxdn], indxdn, left_line);
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, right_line[indxdn], indxdn, right_line);
                if (indxup > 10)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
                else if (indxdn == MISS)
                {
                    image_GetMidSgl(left_line, _left, 1, 106, 30);
                    break;
                }
                else if (indxdn <= 90 && indxdn > 60)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
                else if (indxdn > 90)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[indxdn].connected[image_GetWIndex(_left, indxdn)].right, indxdn, carForefeadRight, carForeheadCol, right_line);
                }
            }
            else
            {
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].left, indxup, 65, 106, left_line);
                image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, right_line[indxdn + 5], indxdn + 5, right_line);
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, 123, 106, right_line);
            }
        }
        else
        {
            for (uint8_t i = 1; i < 119; i++)
            {
                left_line[i] = my_road[i].connected[image_GetWIndex(_right, i)].left;
                right_line[i] = my_road[i].connected[image_GetWIndex(_right, i)].right;
            }
            uint8_t validNum = 0;
            for (uint8_t i = 100; i > 90; i--)
            {
                if (right_side[i] - rightEdge[i] >= 4)
                {
                    validNum++;
                }
            }
            printf("validNum:%d", validNum);
            image_FindBreakPoint(left_line, 0, &indxdn);
            for (uint8_t i = indxdn; i < 106; i++)
            {
                if (left_line[i] >= left_line[i + 3])
                {
                    indxdn = i;
                    break;
                }
            }
            if (indxdn > 90 || validNum < 5)
            {
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, left_line[indxdn], indxdn, left_line);

                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].right, indxup, right_line[indxdn], indxdn, right_line);
                if (indxup > 10)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                }
                else if (indxdn==MISS)
                {
                    image_GetMidSgl(right_line, _right, 1, 106, 30);
                    break;
                }
                else if (indxdn <= 90&& indxdn>60)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                }
                else if (indxdn > 90)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                }
                else
                {
                    image_Line2Points(my_road[indxdn].connected[image_GetWIndex(_left, indxdn)].left, indxdn, carForeheadLeft, carForeheadCol, left_line);
                }
            }
            else
            {
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, 65, 106, left_line);
                image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, left_line[indxdn], indxdn, left_line);
                //image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, 65, 106, left_line);
            }
        }
        get_mid_line();
        image_MidLineCorrector(15);
        break;
    }
    case quitTrident:break;
    case rightTiltEnterCross:
    {
        uint8_t breakPoint = 255, breakPointFix = 255;
        image_FindBreakPoint(right_line, 1, &breakPoint);
        if (breakPoint != 255)
        {
            for (breakPointFix = breakPoint; breakPointFix < 80; breakPointFix++)
            {
                if (right_line[breakPointFix] < right_line[breakPointFix + 1] && right_line[breakPointFix + 1] - right_line[breakPointFix] >= 1)
                {
                    breakPoint = breakPointFix;
                    break;
                }
            }
        }
        uint8_t cuspPoint = TiltFeatureMgr.cuspLine;

        if (breakPoint > 95)breakPoint = 255;
        printf("breakpoint:%d\n", breakPoint);
        printf("cuspPoint:%d\n", cuspPoint);
        if (breakPoint != 255 && cuspPoint != 255)
        {
            get_mid_line();
            float k = image_Line2Points(my_road[cuspPoint].connected[image_GetWIndex(_left, cuspPoint)].right, cuspPoint, right_line[breakPoint + 10], breakPoint + 10, right_line);
            uint8_t transWidth = abs((roadWidth / (sin(atan(k)))));
            if (edgeLineEnum & 0x80 && leftJumpPos > 60)
            {
                image_GetMidSgl(right_line, _right, 1, /*leftJumpPos + 5*/106, transWidth);
            }
            else
            {
                image_GetMidSgl(right_line, _right, 1, /*breakPoint + 15*/106, transWidth);
            }
            image_LineRange(mid_line[cuspPoint], cuspPoint, 10, 1, mid_line, mid_line, up);
        }
        else if (breakPoint != 255 && cuspPoint == 255)
        {
            get_mid_line();
            float k = image_LineRange(right_line[breakPoint + 5], breakPoint + 5, 10, 5, right_line, right_line, up);
            uint8_t transWidth = abs((roadWidth / (sin(atan(1/k)))));
            if (edgeLineEnum & 0x80)
            {
                image_GetMidSgl(right_line, _right, 1, /*leftJumpPos + 5*/106, transWidth);
            }
            else
            {
                image_GetMidSgl(right_line, _right, 1, /*breakPoint + 15*/106, transWidth);
            }
        }
        else if (breakPoint == 255 && cuspPoint != 255)
        {
            get_mid_line();
            float k = image_Line2Points(my_road[cuspPoint].connected[image_GetWIndex(_left, cuspPoint)].right, cuspPoint, carForefeadRight, carForeheadCol, right_line);
            uint8_t transWidth = abs((roadWidth / (sin(atan(k)))));
            image_GetMidSgl(right_line, _right, 1, carForeheadCol, transWidth);
            image_LineRange(mid_line[cuspPoint], cuspPoint, 10, 1, mid_line, mid_line, up);
        }
        else
        {
            uint8_t patchp = MISS;
            for (uint8_t i = 1; i < 10; i++)
            {
                if (my_road[i].connected[image_GetWIndex(_default, 1)].width != 0)
                {
                    patchp = i;
                    break;
                }
            }
            if (patchp != MISS)
            {
                uint8_t leftpoint = my_road[1].connected[image_GetWIndex(_default, 1)].left, rightpoint = my_road[1].connected[image_GetWIndex(_default, 1)].right;
                uint8_t leftwid = leftpoint - left_side[1], rightwid = right_side[1] - rightpoint;
                if (leftwid >= rightwid)
                {
                    float k = image_Line2Points(leftpoint, 1, carForeheadLeft, carForeheadCol, left_line);
                    image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(k)))));
                }
                else
                {
                    float k = image_Line2Points(rightpoint, 1, carForefeadRight, carForeheadCol, right_line);
                    image_GetMidSgl(right_line, _right, 1, 106, abs(roadWidth / (sin(atan(k)))));
                }
                break;
            }
            get_mid_line();
        }
        image_MidLineCorrector(15);
        break;
    }
    case leftTiltEnterCross:
    {
        uint8_t breakPoint = 255, breakPointFix = 255;
        image_FindBreakPoint(left_line, 0, &breakPoint);
        if (breakPoint != 255)
        {
            for (breakPointFix = breakPoint; breakPointFix < 80; breakPointFix++)
            {
                if (left_line[breakPointFix] > left_line[breakPointFix + 1] && left_line[breakPointFix] - left_line[breakPointFix + 1] >= 1)
                {
                    breakPoint = breakPointFix;
                    break;
                }
            }
        }
        uint8_t cuspPoint = TiltFeatureMgr.cuspLine;

        if (breakPoint > 95)breakPoint = 255;
        printf("breakpoint:%d\n", breakPoint);
        printf("cuspPoint:%d\n", cuspPoint);
        if (breakPoint != 255 && cuspPoint != 255)
        {
            get_mid_line();
            float k = image_Line2Points(my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left, cuspPoint, left_line[breakPoint + 10], breakPoint + 10, left_line);
            uint8_t transWidth = abs((roadWidth / (sin(atan(k)))));
            if (edgeLineEnum & 0x04 && rightJumpPos > 60)
            {
                image_GetMidSgl(left_line, _left, 1, /*rightJumpPos + 5*/106, transWidth);
            }
            else
            {
                image_GetMidSgl(left_line, _left, 1, /*breakPoint + 15*/106, transWidth);
            }
            image_LineRange(mid_line[cuspPoint], cuspPoint, 10, 1, mid_line, mid_line, up);
        }
        else if (breakPoint != 255 && cuspPoint == 255)
        {
            get_mid_line();
            uint8_t downpoint = 106;
            for (uint8_t i = NEAR_LINE; i > breakPoint + 5; i--)
            {
                if (left_line[i] - left_side[i] > 2)
                {
                    downpoint = i;
                    break;
                }
            }
            float k = image_LineRange(left_line[breakPoint + 5], breakPoint + 5, downpoint - breakPoint - 5, 5, left_line, left_line, up);
            uint8_t transWidth = abs((roadWidth / (sin(atan(1 / k)))));
            if (edgeLineEnum & 0x04)
            {
                image_GetMidSgl(left_line, _left, 1, /*rightJumpPos + 5*/106, transWidth);
            }
            else
            {
                image_GetMidSgl(left_line, _left, 1, /*breakPoint + 15*/106, transWidth);
            }
            //image_LineRange(mid_line[breakPoint + 15], breakPoint + 15, 10, 1, mid_line, mid_line, up);
        }
        else if (breakPoint == 255 && cuspPoint != 255)
        {
            get_mid_line();
            float k = image_Line2Points(my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left, cuspPoint, carForeheadLeft, carForeheadCol, left_line);
            uint8_t transWidth = abs((roadWidth / (sin(atan(k)))));
            image_GetMidSgl(left_line, _left, 1, carForeheadCol, transWidth);
            image_LineRange(mid_line[cuspPoint], cuspPoint, 10, 1, mid_line, mid_line, up);
        }
        else
        {
            uint8_t patchp = MISS;
            for (uint8_t i = 1; i < 10; i++)
            {
                if (my_road[i].connected[image_GetWIndex(_default, 1)].width != 0)
                {
                    patchp = i;
                    break;
                }
            }
            if (patchp != MISS)
            {
                uint8_t leftpoint = my_road[1].connected[image_GetWIndex(_default, 1)].left, rightpoint = my_road[1].connected[image_GetWIndex(_default, 1)].right;
                uint8_t leftwid = leftpoint - left_side[1], rightwid = right_side[1] - rightpoint;
                if (leftwid >= rightwid)
                {
                    float k = image_Line2Points(leftpoint, 1, carForeheadLeft, carForeheadCol, left_line);
                    image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(k)))));
                }
                else
                {
                    float k = image_Line2Points(rightpoint, 1, carForefeadRight, carForeheadCol, right_line);
                    image_GetMidSgl(right_line, _right, 1, 106, abs(roadWidth / (sin(atan(k)))));
                }
                break;
            }
            get_mid_line();
        }
        image_MidLineCorrector(15);
        break;
    }
    case enterCrossStage2:
    {
        /*uint8_t indxup = 0, indxdn = carForeheadCol;
        image_FindPatchPos(down, &indxup,100,60);
        image_FindPatchPos(up, &indxdn,100,60);
        image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
        image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);*/


        uint8_t leftIsValid = 0, rightIsValid = 0;
        uint8_t leftPointX = MISS, rightPointX = MISS, leftPointY = MISS, rightPointY = MISS;
        if (edgeLineEnum & 0x80)
        {
            uint8_t cont = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 10; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 20 && abs(my_road[i].connected[j].left - leftEdge[leftJumpPos + 3]) < 15)
                    {
                        cont++;
                        if (leftPointX == MISS && leftPointY == MISS)
                        {
                            leftPointX = j;
                            leftPointY = i;
                        }
                        break;
                    }
                }
            }
            printf("left cont:%d\n", cont);
            if (cont >= 5)
            {
                leftIsValid = 1;
            }
        }
        if (edgeLineEnum & 0x04)
        {
            uint8_t cont = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 10; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    if (my_road[i].connected[j].width > 20 && abs(my_road[i].connected[j].right - rightEdge[rightJumpPos + 3]) < 15)
                    {
                        cont++;
                        if (rightPointX == MISS && rightPointY == MISS)
                        {
                            rightPointX = j;
                            rightPointY = i;
                        }
                        break;
                    }
                }
            }
            printf("right cont:%d\n", cont);
            if (cont >= 5)
            {
                rightIsValid = 1;
            }
        }
        if (leftIsValid == 0 && rightIsValid == 0)
        {
            if ((edgeLineEnum & 0x04) && (edgeLineEnum & 0x80))
            {
                uint8_t downPointLeft = MISS, downPointRight = MISS;
                for (uint8_t i = rightJumpPos + 12; i > rightJumpPos + 5; i--)
                {
                    if (rightEdge[i] != right_side[i])
                    {
                        downPointRight = i;
                        break;
                    }
                }
                downPointLeft = MISS;
                for (uint8_t i = leftJumpPos + 12; i > leftJumpPos + 5; i--)
                {
                    if (leftEdge[i] != left_side[i])
                    {
                        downPointLeft = i;
                        break;
                    }
                }
                if (downPointRight != MISS&& downPointLeft != MISS)
                {
                    if (rightJumpPos > 65)
                    {
                        image_LineRange(right_line[rightJumpPos + 5], rightJumpPos + 5, downPointRight - rightJumpPos, 1, right_line, right_line, up);
                    }
                    else
                    {
                        image_LineRange(right_line[rightJumpPos + 15], rightJumpPos + 15, downPointRight - rightJumpPos, 1, right_line, right_line, up);
                    }
                    if (leftJumpPos > 65)
                    {
                        image_LineRange(left_line[leftJumpPos + 5], leftJumpPos + 5, downPointLeft - leftJumpPos, 1, left_line, left_line, up);
                    }
                    else
                    {
                        image_LineRange(left_line[leftJumpPos + 15], leftJumpPos + 15, downPointLeft - leftJumpPos, 1, left_line, left_line, up);
                    }
                    get_mid_line();
                }
                else if (downPointLeft != MISS&& downPointRight==MISS)
                {
                    float k;
                    if (leftJumpPos > 65)
                    {
                        k = image_LineRange(left_line[leftJumpPos + 5], leftJumpPos + 5, downPointLeft - leftJumpPos, 1, left_line, left_line, up);
                    }
                    else
                    {
                        k = image_LineRange(left_line[leftJumpPos + 15], leftJumpPos + 15, downPointLeft - leftJumpPos, 1, left_line, left_line, up);
                    }
                    image_GetMidSgl(left_line, _left, 1, downPointLeft, abs(roadWidth / (sin(atan(1 / k)))));
                }
                else if (downPointLeft == MISS && downPointRight != MISS)
                {
                    float k;
                    if (rightJumpPos > 65)
                    {
                        k = image_LineRange(right_line[rightJumpPos + 5], rightJumpPos + 5, downPointRight - rightJumpPos, 1, right_line, right_line, up);
                    }
                    else
                    {
                        k = image_LineRange(right_line[rightJumpPos + 15], rightJumpPos + 15, downPointRight - rightJumpPos, 1, right_line, right_line, up);
                    }
                    image_GetMidSgl(right_line, _right, 1, downPointRight, abs(roadWidth / (sin(atan(1 / k)))));
                }
                else
                {
                    get_mid_line();
                }
            }
            else if ((edgeLineEnum & 0x04) && !(edgeLineEnum & 0x80))//right
            {
                uint8_t downPoint = MISS, point = MISS, breakPointFix = MISS;
                image_FindBreakPoint(right_line, 1, &point);
                if (point != 255)
                {
                    for (breakPointFix = point; breakPointFix < point + 20; breakPointFix++)
                    {
                        if (right_line[breakPointFix] < right_line[breakPointFix + 1] && right_line[breakPointFix + 1] - right_line[breakPointFix] >= 1)
                        {
                            //point = breakPointFix;
                            break;
                        }
                    }
                    breakPointFix = rightJumpPos > point ? rightJumpPos : point;
                }
                else
                {
                    breakPointFix = rightJumpPos;
                }
                if (breakPointFix > 100)
                {
                    for (breakPointFix = point; breakPointFix < point + 20; breakPointFix++)
                    {
                        if (right_line[breakPointFix] < right_line[breakPointFix + 1])
                        {
                            //point = breakPointFix;
                            break;
                        }
                    }
                    breakPointFix = rightJumpPos > point ? rightJumpPos : point;
                }
                for (uint8_t i = NEAR_LINE; i > breakPointFix + 5 && i <= NEAR_LINE; i--)
                {
                    if (rightEdge[i] != right_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS && downPoint < 106 && breakPointFix < 95)
                {
                    image_LineRange(right_line[breakPointFix+5], breakPointFix+5, downPoint - breakPointFix-5, 1, right_line, right_line, up);
                    image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                }
                else
                {
                    if (TiltFeatureMgr.cuspLine != MISS)
                    {
                        uint8_t cuspline = TiltFeatureMgr.cuspLine;
                        if (stateMgr.lastState == rightTiltEnterCross)
                        {
                            image_Line2Points(my_road[cuspline].connected[image_GetWIndex(_left, cuspline)].right, cuspline, right_line[breakPointFix], breakPointFix, right_line);
                            image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                        }
                        else if (stateMgr.lastState == leftTiltEnterCross)
                        {
                            image_Line2Points(my_road[cuspline].connected[image_GetWIndex(_right, cuspline)].right, cuspline, right_line[breakPointFix], breakPointFix, right_line);
                            image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                        }
                        else
                        {
                            image_Line2Points(my_road[cuspline].connected[image_GetWIndex(_mid, cuspline)].right, cuspline, right_line[breakPointFix], breakPointFix, right_line);
                            image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                        }
                    }
                    else
                    {
                        uint8_t pointLeft = MISS, pointRight = MISS;
                        image_FindBreakPoint(right_line, 1, &pointRight);
                        image_FindBreakPoint(left_line, 0, &pointLeft);
                        if (pointRight < pointLeft)
                        {
                            for (uint8_t i = point; i < 106; i++)
                            {
                                if (right_line[point + 5] - right_line[point] > 3)
                                {
                                    point = i;
                                    break;
                                }
                            }
                            image_LineRange(right_line[point + 10], point + 10, 100-point-10, 1, right_line, right_line, up);
                            image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                        }
                        else if (pointRight >= pointLeft && pointRight != MISS)
                        {
                            for (uint8_t i = point; i < 106; i++)
                            {
                                if (left_line[point] - left_line[point + 5] > 3)
                                {
                                    point = i;
                                    break;
                                }
                            }
                            image_LineRange(left_line[point + 10], point + 10, 100 - point - 10, 1, left_line, left_line, up);
                            image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                        }
                    }
                }
            }
            else if (!(edgeLineEnum & 0x04) && (edgeLineEnum & 0x80))//left
            {
                uint8_t downPoint = MISS, point = MISS, breakPointFix = MISS;
                image_FindBreakPoint(left_line, 0, &point);
                if (point != MISS)
                {
                    for (breakPointFix = point; breakPointFix < point + 20; breakPointFix++)
                    {
                        if (left_line[breakPointFix] > left_line[breakPointFix + 1] && left_line[breakPointFix] - left_line[breakPointFix + 1] >= 2)
                        {
                            //point = breakPointFix;
                            break;
                        }
                    }
                    breakPointFix = leftJumpPos > point ? leftJumpPos : point;
                }
                else
                {
                    breakPointFix = leftJumpPos;
                }
                if (breakPointFix > 100)
                {
                    for (breakPointFix = point; breakPointFix < point + 20; breakPointFix++)
                    {
                        if (left_line[breakPointFix] > left_line[breakPointFix + 1])
                        {
                            //point = breakPointFix;
                            break;
                        }
                    }
                    breakPointFix = leftJumpPos > point ? leftJumpPos : point;
                }
                for (uint8_t i = NEAR_LINE; i > breakPointFix + 5 && i <= NEAR_LINE; i--)
                {
                    if (left_line[i] != left_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS && downPoint < 106 && breakPointFix < 95)
                {
                    image_LineRange(left_line[breakPointFix+5], breakPointFix+5, downPoint - breakPointFix-5, 1, left_line, left_line, up);
                    image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                }
                else
                {
                    if (TiltFeatureMgr.cuspLine != MISS&& TiltFeatureMgr.cuspLine>5)
                    {
                        uint8_t cuspline = TiltFeatureMgr.cuspLine;
                        if (stateMgr.lastState == rightTiltEnterCross)
                        {
                            image_Line2Points(my_road[cuspline].connected[image_GetWIndex(_left, cuspline)].left, cuspline, left_line[breakPointFix], breakPointFix, left_line);
                            image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                        }
                        else if (stateMgr.lastState == leftTiltEnterCross)
                        {
                            image_Line2Points(my_road[cuspline].connected[image_GetWIndex(_right, cuspline)].left, cuspline, left_line[breakPointFix], breakPointFix, left_line);
                            image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                        }
                        else
                        {
                            image_Line2Points(my_road[cuspline].connected[image_GetWIndex(_mid, cuspline)].left, cuspline, left_line[breakPointFix], breakPointFix, left_line);
                            image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                        }
                    }
                    else
                    {
                        uint8_t pointLeft = MISS, pointRight = MISS;
                        image_FindBreakPoint(right_line, 1, &pointRight);
                        image_FindBreakPoint(left_line, 0, &pointLeft);
                        if (pointRight < pointLeft)
                        {
                            for (uint8_t i = point; i < 106; i++)
                            {
                                if (right_line[point + 5] - right_line[point] > 3)
                                {
                                    point = i;
                                    break;
                                }
                            }
                            image_LineRange(right_line[point+10], point+10, 100-point-10, 1, right_line, right_line, up);
                            image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                        }
                        else if (pointRight >= pointLeft)
                        {
                            for (uint8_t i = point; i < 106; i++)
                            {
                                if (left_line[point] - left_line[point + 5] > 3)
                                {
                                    point = i;
                                    break;
                                }
                            }
                            image_LineRange(left_line[point+10], point+10, 100-point-10, 1, left_line, left_line, up);
                            image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                        }
                    }
                }
            }
            else
            {
                get_mid_line();
            }
        }
        else if (leftIsValid == 1 && rightIsValid == 0)
        {
            image_Line2Points(my_road[leftPointY].connected[leftPointX].left, leftPointY, my_road[leftJumpPos + 3].connected[image_GetWIndex(_mid, leftJumpPos + 3)].left, leftJumpPos + 3, left_line);
            if (edgeLineEnum & 0x04)
            {
                uint8_t downPoint = MISS,rightPoint = MISS;
                for (uint8_t i = 106; i > rightJumpPos + 5; i--)
                {
                    if (rightEdge[i] != right_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                for (uint8_t i = rightJumpPos; i < rightJumpPos + 20; i++)
                {
                    if (right_line[i] <= right_line[i + 5])
                    {
                        rightPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS && rightPoint <= 85&& rightPoint< downPoint)
                {
                    image_LineRange(right_line[rightPoint], rightPoint, downPoint - rightPoint, 1, right_line, right_line, up);
                    get_mid_line();
                }
                else
                {
                    image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                }
            }
            else
            {
                image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
            }
        }
        else if (leftIsValid == 0 && rightIsValid == 1)
        {
            image_Line2Points(my_road[rightPointY].connected[rightPointX].right, rightPointY, my_road[rightJumpPos + 3].connected[image_GetWIndex(_mid, rightJumpPos + 3)].right, rightJumpPos + 3, right_line);
            if (edgeLineEnum & 0x80)
            {
                uint8_t downPoint = MISS, leftPoint = MISS;
                for (uint8_t i = 106; i > leftJumpPos + 5; i--)
                {
                    if (leftEdge[i] != left_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                for (uint8_t i = leftJumpPos; i < leftJumpPos + 20; i++)
                {
                    if (left_line[i] >= left_line[i + 5])
                    {
                        leftPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS && leftPoint <= 85 && leftPoint < downPoint)
                {
                    image_LineRange(left_line[leftPoint], leftPoint, downPoint - leftPoint, 1, left_line, left_line, up);
                    get_mid_line();
                }
                else
                {
                    image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                }
            }
            else
            {
                image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
            }
        }
        else if (leftIsValid == 1 && rightIsValid == 1)
        {
            image_Line2Points(my_road[leftPointY].connected[leftPointX].left, leftPointY, my_road[leftJumpPos + 3].connected[image_GetWIndex(_mid, leftJumpPos + 3)].left, leftJumpPos + 3, left_line);
            image_Line2Points(my_road[rightPointY].connected[rightPointX].right, rightPointY, my_road[rightJumpPos + 3].connected[image_GetWIndex(_mid, rightJumpPos + 3)].right, rightJumpPos + 3, right_line);
            get_mid_line();
        }
        image_MidLineCorrector(15);
        //get_mid_line();
        break;
    }
    case specialQuitCross:
    case quitCross:
    {
        uint8_t indxup = 0, indxdn = carForeheadCol;
        uint8_t cuspPoint = MISS, cusp2line = MISS;
        image_FindPatchPos(down, &indxup, 100, 60);
        image_FindPatchPos(up, &indxdn, 100, 60);
        for (uint8_t i = FAR_LINE; i < 80; i++)
        {
            //寻找上边的白条编号
            uint8_t jFir = 0, jSec = 0, jEnd = my_road[i].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width > 25)
                {
                    if (jFir == 0)
                    {
                        jFir = j;
                    }
                    else if (jSec == 0)
                    {
                        jSec = j;
                        break;
                    }
                }
            }
            //寻找下面的白条编号
            uint8_t jDown = 0;
            jEnd = my_road[i + 1].white_num;
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i + 1].connected[j].width > 25)
                {
                    jDown = j;
                    break;
                }
            }
            if (jFir && jSec && cusp2line == MISS)
            {
                cusp2line = i;
                printf("cusp2line:%d\n", cusp2line);
            }
            if (jFir && jSec && jDown)
            {
                if (my_road[i + 1].connected[jDown].right > my_road[i].connected[jSec].left && my_road[i + 1].connected[jDown].left < my_road[i].connected[jFir].right)
                {
                    //尖点最低第五行
                    if (i >= 5)
                    {
                        uint8_t lineCont = 0;
                        for (uint8_t k = i - 1; k > i - 5; k--)
                        {
                            if (image_TellRealWhiteNum(k) >= 2)
                            {
                                lineCont++;
                            }
                        }
                        if (lineCont >= 4)
                        {
                            cuspPoint = i;
                            printf("cuspPoint:%d\n", cuspPoint);
                            break;
                        }
                    }
                }
            }
        }
        uint8_t umidcont = 0;
        uint8_t twolinescont = 0;
        for (uint8_t i = indxup; i > FAR_LINE; i--)
        {
            if (my_road[i].connected[image_GetWIndex(_mid, i)].width > 80)
            {
                umidcont++;
            }
        }
        uint8_t leftUpMissCont = 0,leftUpDownPoint = MISS;
        uint8_t rightUpMissCont = 0,rightUpDownPoint = MISS;
        for (uint8_t i = FAR_LINE; i < 106; i++)
        {
            if (left_line[i] - left_side[i] < 5)
            {
                leftUpDownPoint = i;
                break;
            }
        }
        for (uint8_t i = FAR_LINE; i < 106; i++)
        {
            if (right_side[i] - right_line[i] < 5)
            {
                rightUpDownPoint = i;
                break;
            }
        }
        if (cuspPoint != MISS)
        {
            for (uint8_t i = cuspPoint; i > FAR_LINE; i--)
            {
                uint8_t jCont = my_road[i].white_num, temp = 0;
                for (uint8_t j = 1; j <= jCont; j++)
                {
                    if (my_road[i].connected[j].width > 30)
                    {
                        temp++;
                    }
                }
                if (temp >= 2)
                {
                    twolinescont++;
                }
            }
            if (leftUpDownPoint != MISS && rightUpDownPoint != MISS)
            {
                for (uint8_t i = leftUpDownPoint; i > FAR_LINE; i--)
                {
                    if (my_road[i].connected[image_GetWIndex(_left, i)].left - left_side[i] >= 10)
                    {
                        leftUpMissCont++;
                    }
                }
                for (uint8_t i = rightUpDownPoint; i > FAR_LINE; i--)
                {
                    if (right_side[i] - my_road[i].connected[image_GetWIndex(_right, i)].right >= 10)
                    {
                        rightUpMissCont++;
                    }
                }
            }
        }
        printf("leftUpMissCont:%d\n", leftUpMissCont);
        printf("rightUpMissCont:%d\n", rightUpMissCont);
        if (stateMgr.lastState == leftTiltEnterCross)
        {
            uint8_t missLineCont = 0;
            uint8_t leftWightCont = 0;
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        if (my_road[i].connected[j].left < 5)
                        {
                            missLineCont++;
                        }
                        break;
                    }
                }
            }
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)	//左上角是否有白条
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 15)
                    {
                        if (my_road[i].connected[j].right < 40)
                        {
                            leftWightCont++;
                        }
                        break;
                    }
                }
            }
            if (cuspPoint != MISS)
            {
                uint8_t patchPoint = cuspPoint - 5;
                for (; patchPoint > 1; patchPoint--)
                {
                    if (my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].width < 80)
                    {
                        break;
                    }
                }
                if (patchPoint == 0)patchPoint = 1;
                if (rightUpMissCont > leftUpMissCont && leftUpMissCont > 13)
                {
                    if (my_road[cuspPoint].connected[image_GetWIndex(_left, cuspPoint)].right < 74)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                    else if (my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left < 114)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                }
                else if (rightUpMissCont < leftUpMissCont && leftUpMissCont > 13)
                {
                    if (my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left > 114)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                    else if (my_road[cuspPoint].connected[image_GetWIndex(_left, cuspPoint)].right > 74)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                }
                if (cusp2line < 40&& umidcont>indxup/2)
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
                else if (twolinescont > indxup / 2)
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
            }
            else if (indxup > 10)
            {
                if (missLineCont > 5 || leftWightCont > 10)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
            }
            else
            {
                uint8_t leftPoint = MISS;
                uint8_t rightPoint = MISS;
                for (uint8_t i = indxup; i < 100; i++)
                {
                    if (leftPoint == MISS && left_line[i] > left_line[i + 5] && left_line[i] - left_line[i + 5] > 5)
                    {
                        leftPoint = i;
                    }
                    if (rightPoint == MISS && right_line[i] < right_line[i + 5] && right_line[i + 5] - right_line[i]>5)
                    {
                        rightPoint = i;
                    }
                    if (leftPoint != MISS && rightPoint != MISS)
                    {
                        break;
                    }
                }
                if (my_road[indxup].connected[image_GetWIndex(_mid, indxup)].width < 80)
                {
                    image_Line2Points(my_road[rightPoint].connected[image_GetWIndex(_mid, rightPoint)].right, rightPoint, carForefeadRight, carForeheadCol, right_line);
                    image_Line2Points(my_road[leftPoint].connected[image_GetWIndex(_mid, leftPoint)].left, leftPoint, carForeheadLeft, carForeheadCol, left_line);
                }
                else
                {
                    image_Line2Points(my_road[rightPoint].connected[image_GetWIndex(_mid, rightPoint)].right, rightPoint, carForefeadRight, carForeheadCol, right_line);
                    image_Line2Points(my_road[leftPoint].connected[image_GetWIndex(_mid, leftPoint)].left, leftPoint, carForeheadLeft, carForeheadCol, left_line);
                }
            }
        }
        else if (stateMgr.lastState == rightTiltEnterCross)
        {
            uint8_t missLineCont = 0;
            uint8_t rightWightCont = 0;
            for (uint8_t i = FAR_LINE + 5; i < FAR_LINE + 15; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    if (my_road[i].connected[j].width > 20)
                    {
                        if (187 - my_road[i].connected[j].right < 5)
                        {
                            missLineCont++;
                        }
                        break;
                    }
                }
            }
            for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)	//左上角是否有白条
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = jEnd; j >= 1; j--)
                {
                    if (my_road[i].connected[j].width > 15)
                    {
                        if (my_road[i].connected[j].left > 148)
                        {
                            rightWightCont++;
                        }
                        break;
                    }
                }
            }
            /*else
            {
                uint8_t patchPoint = cuspPoint - 5;
                for (; patchPoint > 1; patchPoint--)
                {
                    if (my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].width < 80)
                    {
                        break;
                    }
                }
                if (my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left >114)
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
            }*/
            if (cuspPoint != MISS)
            {
                uint8_t patchPoint = cuspPoint - 5;
                for (; patchPoint > 1; patchPoint--)
                {
                    if (my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].width < 80)
                    {
                        break;
                    }
                }
                if (patchPoint == 0)patchPoint = 1;
                if (rightUpMissCont > leftUpMissCont && rightUpMissCont > 13)
                {
                    if (my_road[cuspPoint].connected[image_GetWIndex(_left, cuspPoint)].right < 74)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                    else if (my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left < 114)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_right, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                }
                else if (rightUpMissCont < leftUpMissCont && rightUpMissCont > 13)
                {
                    if (my_road[cuspPoint].connected[image_GetWIndex(_right, cuspPoint)].left > 114)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                    else if (my_road[cuspPoint].connected[image_GetWIndex(_left, cuspPoint)].right > 74)
                    {
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                        image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                        get_mid_line();
                        image_MidLineCorrector(15);
                        break;
                    }
                }
                if (cusp2line < 5&&umidcont>cuspPoint /2)
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
                else if (twolinescont > cuspPoint / 2)
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_left, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].left, patchPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[patchPoint].connected[image_GetWIndex(_mid, patchPoint)].right, patchPoint, carForefeadRight, carForeheadCol, right_line);
                }
            }
            else if (indxup > 10)
            {
                if (missLineCont > 5 || rightWightCont > 10)
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
                }
            }
            else
            {
                uint8_t leftPoint = MISS;
                uint8_t rightPoint = MISS;
                for (uint8_t i = indxup; i < 100; i++)
                {
                    if (leftPoint == MISS && left_line[i] > left_line[i + 5] && left_line[i] - left_line[i + 5] > 5)
                    {
                        leftPoint = i;
                    }
                    if (rightPoint == MISS && right_line[i] < right_line[i + 5] && right_line[i + 5] - right_line[i]>5)
                    {
                        rightPoint = i;
                    }
                    if (leftPoint != MISS && rightPoint != MISS)
                    {
                        break;
                    }
                }
                if (my_road[indxup].connected[image_GetWIndex(_mid, indxup)].width < 80)
                {
                    image_Line2Points(my_road[leftPoint].connected[image_GetWIndex(_mid, leftPoint)].left, leftPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[rightPoint].connected[image_GetWIndex(_mid, rightPoint)].right, rightPoint, carForefeadRight, carForeheadCol, right_line);
                }
                else
                {
                    image_Line2Points(my_road[leftPoint].connected[image_GetWIndex(_mid, leftPoint)].left, leftPoint, carForeheadLeft, carForeheadCol, left_line);
                    image_Line2Points(my_road[rightPoint].connected[image_GetWIndex(_mid, rightPoint)].right, rightPoint, carForefeadRight, carForeheadCol, right_line);
                }
            }
        }
        else
        {
            uint8_t leftPoint = MISS;
            uint8_t rightPoint = MISS;
            if (indxup < 10)
            {
                for (uint8_t i = indxup; i < 100; i++)
                {
                    if (leftPoint == MISS && left_line[i] > left_line[i + 5] && left_line[i] - left_line[i + 5] > 5)
                    {
                        leftPoint = i;
                    }
                    if (rightPoint == MISS && right_line[i] < right_line[i + 5] && right_line[i + 5] - right_line[i]>5)
                    {
                        rightPoint = i;
                    }
                    if (leftPoint != MISS && rightPoint != MISS)
                    {
                        break;
                    }
                }
                image_Line2Points(my_road[leftPoint-5].connected[image_GetWIndex(_mid, leftPoint-5)].left, leftPoint-5, carForeheadLeft, carForeheadCol, left_line);
                image_Line2Points(my_road[rightPoint-5].connected[image_GetWIndex(_mid, rightPoint-5)].right, rightPoint-5, carForefeadRight, carForeheadCol, right_line);
            }
            else
            {
                image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
                image_Line2Points(my_road[indxup].connected[image_GetWIndex(_mid, indxup)].right, indxup, carForefeadRight, carForeheadCol, right_line);
            }
        }
        get_mid_line();
        image_MidLineCorrector(15);
        break;
    }
    case enterLeftRoundabout:
    {
        //if (right_line[90] == right_side[90])
        //{
        //	if (left_line[20] == left_side[20])
        //	{
        //		uint8_t indxup = 0, indxdn = carForeheadCol;
        //		image_FindPatchPos(down, &indxup,100,60);
        //		image_FindPatchPos(up, &indxdn,100,60);
        //		/*image_FindPatchPointEX(up, _left, &point, left_line);
        //		image_LineRange(left_line[point + 10], point + 10, 15, 5, left_line, left_line, up);*/
        //		image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
        //		image_Line2Points(my_road[indxup].connected[image_GetWIndex(_right, indxup)].left + 60, indxup, carForefeadRight, carForeheadCol, right_line);
        //		get_mid_line();
        //	}
        //	else
        //	{
        //		uint8_t breakPoint = MISS;
        //		/*image_LineRange(left_line[leftJumpPos + 10], leftJumpPos + 10, 5, 5, left_line, left_line, up);*/
        //		image_FindBreakPoint(leftEdge, 0, &breakPoint);
        //		printf("breakpoint:%d\n", breakPoint);
        //		if (breakPoint != MISS)
        //		{
        //			image_LineRange(left_line[breakPoint + 10], breakPoint + 10, 5, 5, left_line, left_line, up);
        //			image_GetMidSgl(left_line, _left, 5, carForeheadCol, 26);
        //		}
        //		else
        //		{
        //			image_GetMidSgl(right_line, _right, 5, carForeheadCol, 26);
        //		}
        //	}
        //}
        //else
        //{
        //	image_GetMidSgl(rightEdge, _right, 1, 100, 26);
        //}
        ///*image_FindPatchPointEX(up, _left, &point, right_line);
        //image_LineRange(right_line[point+5], point+5, 10, 5, right_line, right_line, up);*/
        uint8_t left_point = MISS;
        uint8_t iStart = MISS;
        for (uint8_t i = 106; i > 60; i--)
        {
            if (right_side[i] - right_line[i] > 2)
            {
                iStart = i;
                break;
            }
        }
        image_FindBreakPoint(left_line, 0, &left_point);
        if (left_point <= iStart && left_point != MISS && iStart != MISS)
        {
            float k = ((float)left_line[left_point] - left_line[106]) / ((float)left_point - 106);
            image_GetMidSgl(left_line, _left, left_point, 106, abs(roadWidth / (sin(atan(1 / k)))));
            image_GetMidSgl(right_line, _right, 1, left_point, abs(roadWidth / (sin(atan(1 / k)))));
        }
        else if (left_point > iStart && left_point != MISS && iStart != MISS)
        {
            float k = ((float)left_line[left_point] - left_line[106]) / ((float)left_point - 106);
            image_GetMidSgl(left_line, _left, left_point, 106, abs(roadWidth / (sin(atan(1 / k)))));
            image_GetMidSgl(right_line, _right, 1, iStart, abs(roadWidth / (sin(atan(1 / k)))));
            image_Line2Points(mid_line[iStart], iStart, mid_line[left_point], left_point, mid_line);
        }
        else if (left_point == MISS)
        {
            float k = ((float)right_line[60] - right_line[iStart]) / ((float)60 - iStart);
            image_GetMidSgl(right_line, _right, 1, iStart, abs(roadWidth / (sin(atan(1 / k)))));
            image_Line2Points(mid_line[iStart], iStart, 94, 106, mid_line);
        }
        else if (iStart == MISS)
        {
            float k = ((float)left_line[left_point] - left_line[106]) / ((float)left_point - 106);
            image_GetMidSgl(left_line, _left, left_point, 106, abs(roadWidth / (sin(atan(1 / k)))));
            image_LineRange(mid_line[left_point], left_point, 5, 1, mid_line, mid_line, up);
        }
        break;
    }
    case leftRoundaboutStage2:
    {
        image_GetMidSgl(right_line, _right, 1, 100, 26);
        /*image_FindPatchPointEX(up, _left, &point, right_line);
        image_LineRange(right_line[point+5], point+5, 10, 5, right_line, right_line, up);*/
        break;
    }
    case leftRoundaboutStage3:
    {
        uint8_t far_point = 0, near_point = carForeheadCol, patch_point = 53;
        uint8_t confCont = 0;
        for (uint8_t i = FAR_LINE; i < 106; i++)
        {
            if (left_line[i] > left_side[i] + 5)
            {
                confCont++;
            }
        }
        for (uint8_t i = 0; i < 60; i++)
        {
            if (left_line[i] <= left_side[i] + 10)
            {
                far_point = i;
            }
        }
        for (uint8_t i = 60; i < carForeheadCol; i++)
        {
            if (left_line[i] != left_side[i])
            {
                near_point = i;
            }
        }
        patch_point = (far_point + near_point) / 2;
        if (confCont > 20)
        {
            if (patch_point > 65)
            {
                if (TiltFeatureMgr.leftMissCount >= roadWidth)
                {
                    image_GetMidSgl(right_line, _right, patch_point, carForeheadCol, roadWidth);
                    image_GetMidSgl(left_line, _left, 1, patch_point, mid_line[patch_point + 1] - left_line[patch_point - 1]);
                }
                else
                {
                    image_GetMidSgl(right_line, _right, patch_point, carForeheadCol, roadWidth);
                    image_GetMidSgl(left_line, _left, 1, patch_point, 35);
                }
            }
            else
            {
                image_GetMidSgl(left_line, _left, 1, 106, 94 - left_side[106]);
            }
        }
        else
        {
            image_GetMidSgl(left_side, _left, 1, 106, 94 - left_side[106]);
        }
        image_MidLineFilter();
        break;
    }
    case leftRoundaboutStage4:
    {
        uint8_t indexup = 1;
        for (uint8_t i = 0; i < carForeheadCol; i++)
        {
            if (my_road[i + 1].connected[image_GetWIndex(_right, i + 1)].width - my_road[i].connected[image_GetWIndex(_right, i)].width > 25)
            {
                indexup = i;
                //break;
            }
        }
        if (indexup < 70 && indexup!=0)
        {
            if (my_road[indexup].connected[my_road[indexup].white_num].width > 15)
            {
                image_Line2Points(my_road[indexup].connected[my_road[indexup].white_num].left, indexup, carForefeadRight, carForeheadCol, right_line);
            }
            else
            {
                image_Line2Points(my_road[indexup].connected[image_GetWIndex(_right, indexup)].left, indexup, carForefeadRight, carForeheadCol, right_line);
            }
        }
        else if(indexup == 0)
        {
            image_Line2Points(my_road[indexup+1].connected[image_GetWIndex(_left, indexup+1)].right, indexup+1, carForefeadRight, carForeheadCol, right_line);
        }
        else
        {
            image_Line2Points(my_road[indexup].connected[image_GetWIndex(_left, indexup)].right, indexup, carForefeadRight, carForeheadCol, right_line);
        }
        get_mid_line();
        image_MidLineCorrector(15);
        break;
    }
    case leftRoundaboutStage5:
    {
        //重新初始化right_line
        uint8_t* ptrRightLine = &right_line[0], iStart = MISS;
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            *ptrRightLine = MISS;
            ptrRightLine++;
        }
        ptrRightLine = &right_line[0];
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            uint8_t jEnd = my_road[i].white_num, index = 0;
            //寻找偏左的赛道
            for (uint8_t j = 1; j <= jEnd; j++)
            {
                if (my_road[i].connected[j].width >= 15)
                {
                    if ((my_road[i].connected[j].right / 2 + my_road[i].connected[j].left / 2) <= 94)
                    {
                        index = j;
                        break;
                    }
                }
            }
            if (index > 0)
            {
                *ptrRightLine = my_road[i].connected[index].right;
                if (iStart == MISS)
                {
                    iStart = i;
                }
            }
            else
            {
                index = 1;
                *ptrRightLine = my_road[i].connected[index].right;

            }
            ptrRightLine++;
        }
        //看看是不是完全弯道
        uint8_t blackWhiteNum = 0;
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            if (jEnd == 0)
            {
                blackWhiteNum++;
            }
            else
            {
                uint8_t maxWhiteWidth = 0;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    uint8_t curWhiteWidth = my_road[i].connected[j].width;
                    if (curWhiteWidth > maxWhiteWidth)
                    {
                        maxWhiteWidth = curWhiteWidth;
                    }
                }
                if (maxWhiteWidth < 8)
                {
                    blackWhiteNum++;
                }
            }
        }
        //环岛弯道补线
        if (blackWhiteNum > 10)
        {
            image_CurveTranslation(right_line, iStart, 92, 1, 25);
        }
        else
        {
            roundPatchFlag = 1;
            get_mid_line();
        }
        //get_mid_line();
        //image_MidLineFilterEx();
        break;
    }
    case leftRoundaboutStage6:
    {
        get_mid_line();
        uint8_t point = 20;
        image_FindBreakPoint(right_line, 1, &point);
        /*uint8_t indxup = 0, indxdn = 106;
        image_FindPatchPos(down, &indxup);
        image_FindPatchPos(up, &indxdn);
        IMG[indxup][right_line[indxup]] = 2;
        image_LineRange(rightEdge[indxup], indxup, 5, 5, right_line, right_line, up);*/
        //if (point != MISS)
        //{
        //	if (point < 60)
        //	{
        //		image_LineRange(rightEdge[point + 15], point + 15, 20, 1, right_line, right_line, up);
        //		//image_CurveTranslation(right_line,100, point+15,1,20);
        //		image_GetMidSgl(right_line, _right, 1, point + 16, roadWidth);
        //	}
        //	else if (point > 60)
        //	{
        //		image_LineRange(rightEdge[point + 15], point + 15, 5, 1, right_line, right_line, up);
        //		//image_CurveTranslation(right_line,100, point+15,1,20);
        //		image_GetMidSgl(right_line, _right, 1, point + 16, roadWidth);
        //	}
        //}
        uint8_t leftConf = 0;
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            if (left_line[i] - left_side[i] > 5)
            {
                leftConf++;
            }
        }
for (uint8_t i = point; i < 106; i++)
{
    if (right_line[i] < right_line[i + 5] && right_line[i + 5] - right_line[i]>2)
    {
        point = i;
        break;
    }
}
if (point != MISS)
{
    if (leftConf > 60)
    {
        image_GetMidSgl(left_line, _left, point, 106, 30);
        image_LineRange(mid_line[point], point, 106 - point, 5, mid_line, mid_line, up);
    }
    else
    {
        float k = image_Line2Points(0, 1, right_line[point + 5], point + 5, right_line);
        if (abs(k) < 1e-3)k = 1e-3;
        image_GetMidSgl(right_line, _right, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
    }
}
//get_mid_line();
break;
    }
    case leftRoundaboutStage7:
    {
        get_mid_line();
        uint8_t downPoint = MISS;
        uint8_t rightInfo = 0;
        uint8_t longWightCont = 0;
        uint8_t leftConf = 0, leftConfBig = 0;
        for (uint8_t i = 106; i > 40; i--)
        {
            if (downPoint == MISS && right_line[i] != right_side[i])
            {
                downPoint = i;
                break;
            }
        }
        for (uint8_t i = 110; i > 40; i--)
        {
            if (right_line[i] != right_side[i])
            {
                rightInfo++;
            }
            /*if (leftInfo != 0 && left_line[i] == leftEdge[i])
            {
                break;
            }*/
        }
        for (uint8_t i = 95; i > 40; i--)
        {
            if (my_road[i].connected[image_GetWIndex(_default, i)].width > (right_side[i] - left_side[i]) * 0.7)
            {
                longWightCont++;
            }
        }
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            if (left_line[i] - left_side[i] > 5)
            {
                leftConf++;
            }
            if (left_line[i] - left_side[i] > 10)
            {
                leftConfBig++;
            }
        }
        printf("leftConf:%d\n", leftConf);
        if (leftConf > 60)
        {
            /*downPoint = MISS;
            for (uint8_t i = 106; i > 40; i--)
            {
                if (downPoint == MISS && left_line[i] != left_side[i])
                {
                    downPoint = i;
                    break;
                }
            }*/
            uint8_t point = 20;
            image_FindBreakPoint(right_line, 1, &point);
            for (uint8_t i = point; i < 106; i++)
            {
                if (right_line[i] < right_line[i + 5] && right_line[i + 5] - right_line[i]>2)
                {
                    point = i;
                    break;
                }
            }
            uint8_t missCont = 0;
            for (uint8_t i = 20; i < 106; i++)
            {
                if (my_road[i].white_num == 0)
                {
                    missCont++;
                }
            }
            if (leftConfBig > 40)
            {
                image_GetMidSgl(left_line, _left, 1, 106, 30);
                break;
}
            else if (missCont < 10&&point<100)
            {
                image_GetMidSgl(left_line, _left, point, 106, 30);
                image_LineRange(mid_line[point], point, 106 - point, 1, mid_line, mid_line, up);
                uint8_t errorCont = 0;
                for (uint8_t i = 25; i < 45; i++)
                {
                    if (mid_line[i] > 94)
                    {
                        errorCont++;
                    }
                }
                if (errorCont > 10)
                {
                    image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol] + 5);
                }
                break;
            }
            else
            {
                if (leftConf > 70)
                {
                    image_GetMidSgl(left_line, _left, 1, 106, 30);
                }
                else
                {
                    image_GetMidSgl(left_side, _left, 1, 106, 30);
                }
            }
            uint8_t errorCont = 0;
            for (uint8_t i = 25; i < 45; i++)
            {
                if (mid_line[i] > 84)
                {
                    errorCont++;
                }
            }
            if (errorCont > 7)
            {
                image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol] + 5);
            }
            break;
        }
        if (longWightCont > 20)
        {
            if (downPoint > 100 && rightInfo > 20)
            {
                uint8_t point = 20;
                image_FindBreakPoint(right_line, 1, &point);

                if (point != MISS&& point < 106)
                {
                    float k = image_Line2Points(0, 1, right_line[point + 5], point + 5, right_line);
                    if (abs(k) < 1e-3)k = 1e-3;
                    image_GetMidSgl(right_line, _right, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
                }
                else
                {
                    uint8_t pos = 105, uppos;
                    for (; pos > 60; pos--)
                    {
                        if (right_line[pos] != right_side[pos])
                        {
                            break;
                        }
                    }
                    for (uppos = pos - 60; right_side[uppos] >= right_side[pos]; uppos--);
                    float k = (float)((float)right_side[uppos] - (float)right_side[pos]) / (float)((float)uppos - (float)pos);
                    if (abs(k) < 1e-3)k = 1e-3;
                    image_GetMidSgl(right_line, _right, 0, pos, abs(roadWidth / (sin(atan(1 / k)))));
                }
                //image_GetMidSgl(right_side, _right, 5, carForeheadCol, right_side[carForeheadCol] - mid_line[carForeheadCol]);
            }
            else if (rightInfo < 20)
            {
                uint8_t pos = 105, uppos;
                for (; pos > 60; pos--)
                {
                    if (right_line[pos] != right_side[pos])
                    {
                        break;
                    }
                }
                for (uppos = pos - 60; right_side[uppos] >= right_side[pos]; uppos--);
                float k = (float)((float)right_side[uppos] - (float)right_side[pos]) / (float)((float)uppos - (float)pos);
                if (abs(k) < 1e-3)k = 1e-3;
                if (k < 0)
                {
                    image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol]+5);
                }
                else
                {
                    image_GetMidSgl(right_line, _right, 0, pos, abs(roadWidth / (sin(atan(1 / k)))));
                }
            }
            else //if(downPoint>=80 && TiltFeatureMgr.leftMissCount > 35&& TiltFeatureMgr.rightMissCount>35)
            {
                image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol]+5);
            }
        }
        else
        {
            uint8_t pos = 105, uppos;
            for (; pos > 60; pos--)
            {
                if (right_line[pos] != right_side[pos])
                {
                    break;
                }
            }
            for (uppos = pos - 60; right_side[uppos] >= right_side[pos]; uppos--);
            float k = (float)((float)right_side[uppos] - (float)right_side[pos]) / (float)((float)uppos - (float)pos);
            if (abs(k) < 1e-3)k = 1e-3;
            if (k > 0)
            {
                image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol]+5);
            }
            else
            {
                image_GetMidSgl(right_line, _right, 0, pos, abs(roadWidth / (sin(atan(1 / k)))));
                uint8_t left_point = MISS;
                for (uint8_t i = pos; i > pos - 60; i--)
                {
                    if (mid_line[i] < 54)
                    {
                        left_point = i;
                        break;
                    }
                }
                if (left_point != MISS)
                {
                    image_Line2Points(mid_line[left_point], left_point, 94, 106, mid_line);
                }
            }
        }
        uint8_t errorCont = 0;
        for (uint8_t i = 25; i < 45; i++)
        {
            if (mid_line[i] > 74)
            {
                errorCont++;
            }
        }
        if (errorCont > 5)
        {
            image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol]+5);
        }
        image_MidLineCorrector(50);
        //image_GetMidSgl(left_side, _left, 5, carForeheadCol, mid_line[carForeheadCol] - left_side[carForeheadCol]);

        /*else
        {
            image_GetMidSgl(left_line, _left, indxdn - 25, indxdn, mid_line[indxdn] - left_line[indxdn]);
            image_GetMidSgl(left_side, _left, 5, indxdn - 25, mid_line[indxdn - 25] - left_side[indxdn - 25]);
            image_LineRange(mid_line[44], 44, 10, 5, mid_line, mid_line, up);
        }*/
        break;
    }
    case leftRoundaboutStage8:
    {
        uint8_t pos = 105, uppos;
        for (; pos > 60; pos--)
        {
            if (right_line[pos] != right_side[pos])
            {
                break;
            }
        }
        for (uppos = pos - 60; right_line[uppos] >= right_line[pos] && uppos>1; uppos--);
        float k = (float)((float)right_line[uppos] - (float)right_line[pos]) / (float)((float)uppos - (float)pos);
        if (abs(k) < 1e-3)k = 1e-3;
        image_GetMidSgl(right_line, _right, 0, pos, abs(roadWidth / (sin(atan(1 / k)))));
        uint8_t left_point = MISS;
        for (uint8_t i = pos; i > pos - 60; i--)
        {
            if (mid_line[i] < 54)
            {
                left_point = i;
                break;
            }
        }
        if (left_point != MISS)
        {
            image_Line2Points(mid_line[left_point], left_point, 94, 106, mid_line);
        }
        break;
    }
    case leftRoundaboutStage9:
    {
        if (TiltFeatureMgr.cuspLine!= MISS && TiltFeatureMgr.cuspLine > 4)
        {
            image_GetMidSgl(right_line, _right, 0, 105, my_road[TiltFeatureMgr.cuspLine - 3].connected[image_GetWIndex(_right, TiltFeatureMgr.cuspLine - 3)].width / 2);
        }
        else if (leftJumpPos > 11 && leftJumpPos != MISS)
        {
            image_GetMidSgl(right_line, _right, 0, 105, my_road[leftJumpPos - 10].connected[image_GetWIndex(_default, leftJumpPos - 10)].width / 2);
        }
        else
        {
            image_GetMidSgl(right_line, _right, 0, 105, roadWidth);
        }
        image_MidLineCorrector(20);
        break;
    }
    case enterRightRoundabout:
    {
        //if (left_line[90] == left_side[90])
        //{
        //	if (right_line[20] == right_side[20])
        //	{
        //		uint8_t indxup = 0, indxdn = carForeheadCol;
        //		image_FindPatchPos(down, &indxup,100,60);
        //		image_FindPatchPos(up, &indxdn,100,60);
        //		/*image_FindPatchPointEX(up, _left, &point, left_line);
        //		image_LineRange(left_line[point + 10], point + 10, 15, 5, left_line, left_line, up);*/
        //		image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].left + 60, indxup, carForefeadRight, carForeheadCol, right_line);
        //		image_Line2Points(my_road[indxup].connected[image_GetWIndex(_left, indxup)].left, indxup, carForeheadLeft, carForeheadCol, left_line);
        //		get_mid_line();
        //	}
        //	else//直线部分丢线
        //	{
        //		uint8_t breakPoint = MISS;
        //		/*image_LineRange(left_line[leftJumpPos + 10], leftJumpPos + 10, 5, 5, left_line, left_line, up);*/
        //		image_FindBreakPoint(rightEdge, 1, &breakPoint);
        //		printf("breakpoint:%d\n", breakPoint);
        //		if (breakPoint != MISS)
        //		{
        //			image_LineRange(right_line[breakPoint + 10], breakPoint + 10, 5, 5, right_line, right_line, up);
        //			image_GetMidSgl(right_line, _right, 5, carForeheadCol, 26);
        //		}
        //		else
        //		{
        //			image_GetMidSgl(left_line, _left, 5, carForeheadCol, 26);
        //		}
        //	}
        //}
        //else
        //{
        //	image_GetMidSgl(leftEdge, _left, 1, 100, 26);
        //}
        /*image_FindPatchPointEX(up, _left, &point, right_line);
        image_LineRange(right_line[point+5], point+5, 10, 5, right_line, right_line, up);*/
        uint8_t right_point = MISS;
        uint8_t iStart = MISS;
        for (uint8_t i = 106; i > 60; i--)
        {
            if (left_line[i] - left_side[i] > 2)
            {
                iStart = i;
                break;
            }
        }
        image_FindBreakPoint(right_line, 1, &right_point);
        if (right_point <= iStart && right_point != MISS && iStart != MISS)
        {
            float k = ((float)right_line[right_point] - right_line[106]) / ((float)right_point - 106);
            image_GetMidSgl(right_line, _right, right_point, 106, abs(roadWidth / (sin(atan(1 / k)))));
            image_GetMidSgl(left_line, _left, 1, right_point, abs(roadWidth / (sin(atan(1 / k)))));
        }
        else if (right_point > iStart && right_point != MISS && iStart != MISS)
        {
            float k = ((float)right_line[right_point] - right_line[106]) / ((float)right_point - 106);
            image_GetMidSgl(right_line, _right, right_point, 106, abs(roadWidth / (sin(atan(1 / k)))));
            image_GetMidSgl(left_line, _left, 1, iStart, abs(roadWidth / (sin(atan(1 / k)))));
            image_Line2Points(mid_line[iStart], iStart, mid_line[right_point], right_point, mid_line);
        }
        else if (right_point == MISS)
        {
            float k = ((float)left_line[60] - left_line[iStart]) / ((float)60 - iStart);
            image_GetMidSgl(left_line, _left, 1, iStart, abs(roadWidth / (sin(atan(1 / k)))));
            image_Line2Points(mid_line[iStart], iStart, 94, 106, mid_line);
        }
        else if (iStart == MISS)
        {
            float k = ((float)right_line[right_point] - right_line[106]) / ((float)right_point - 106);
            image_GetMidSgl(right_line, _right, right_point, 106, abs(roadWidth / (sin(atan(1 / k)))));
            image_LineRange(mid_line[right_point], right_point, 5, 1, mid_line, mid_line, up);
        }
        break;
    }
    case rightRoundaboutStage2:
    {

        image_GetMidSgl(left_line, _left, 1, 100, 26);
        /*image_FindPatchPointEX(up, _left, &point, right_line);
        image_LineRange(right_line[point+5], point+5, 10, 5, right_line, right_line, up);*/
        break;
    }
    case rightRoundaboutStage3:
    {
        uint8_t far_point = 0, near_point = carForeheadCol, patch_point = 53;
        uint8_t confCont = 0;
        for (uint8_t i = FAR_LINE; i < 106; i++)
        {
            if (right_line[i] < right_side[i] - 5)
            {
                confCont++;
            }
        }
        for (uint8_t i = 0; i < 60; i++)
        {
            if (right_line[i] <= right_side[i] + 10)
            {
                far_point = i;
            }
        }
        for (uint8_t i = 60; i < carForeheadCol; i++)
        {
            if (right_line[i] != right_side[i])
            {
                near_point = i;
            }
        }
        patch_point = (far_point + near_point) / 2;
        if (confCont > 20)
        {
            if (patch_point > 65)
            {
                if (TiltFeatureMgr.rightMissCount >= roadWidth)
                {
                    image_GetMidSgl(left_line, _left, patch_point, carForeheadCol, roadWidth);
                    image_GetMidSgl(right_line, _right, 1, patch_point, right_line[patch_point + 1] - mid_line[patch_point + 1]);
                }
                else
                {
                    image_GetMidSgl(left_line, _left, patch_point, carForeheadCol, roadWidth);
                    image_GetMidSgl(right_line, _right, 1, patch_point, 35);
                }
            }
            else
            {
                image_GetMidSgl(right_line, _left, 1, 106, right_line[106]-94);
            }
        }
        else
        {
            image_GetMidSgl(right_line, _left, 1, 106, right_line[106] - 94);
        }
        image_MidLineFilter();
        break;
    }
    case rightRoundaboutStage4:
    {
        uint8_t indexup = MISS;
        for (uint8_t i = 1; i < carForeheadCol; i++)
        {
            if (my_road[i + 1].connected[image_GetWIndex(_left, i + 1)].width - my_road[i].connected[image_GetWIndex(_left, i)].width > 25)
            {
                indexup = i;
                //break;
            }
        }
        if (indexup < 70 && indexup!=0)
        {
            if (my_road[indexup].connected[1].width > 10)
            {
                image_Line2Points(my_road[indexup].connected[1].right, indexup, carForeheadLeft, carForeheadCol, left_line);
            }
            else
            {
                image_Line2Points(my_road[indexup].connected[image_GetWIndex(_left, indexup)].right, indexup, carForeheadLeft, carForeheadCol, left_line);
            }
        }
        else if(indexup == 0)
        {
            image_Line2Points(my_road[indexup+1].connected[image_GetWIndex(_right, indexup+1)].left, indexup+1, carForeheadLeft, carForeheadCol, left_line);
        }
        else
        {
            image_Line2Points(my_road[indexup].connected[image_GetWIndex(_right, indexup)].left, indexup, carForeheadLeft, carForeheadCol, left_line);
        }
        get_mid_line();
        image_MidLineCorrector(15);
        break;
    }
    case rightRoundaboutStage5:
    {
        //重新初始化left_line
        uint8_t* ptrLeftLine = &left_line[0], iStart = MISS;
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            *ptrLeftLine = MISS;
            ptrLeftLine++;
        }
        ptrLeftLine = &left_line[0];
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            uint8_t jEnd = my_road[i].white_num, index = 0;
            //寻找偏右的赛道
            for (uint8_t j = jEnd; j >= 1; j--)
            {
                if (my_road[i].connected[j].width >= 15)
                {
                    if ((my_road[i].connected[j].right / 2 + my_road[i].connected[j].left / 2) >= 94)
                    {
                        index = j;
                        break;
                    }
                }
            }
            if (index > 0)
            {
                *ptrLeftLine = my_road[i].connected[index].left;
                if (iStart == MISS)
                {
                    iStart = i;
                }
            }
            else
            {
                index = jEnd;
                *ptrLeftLine = my_road[i].connected[index].left;
            }
            ptrLeftLine++;
        }
        //看看是不是完全弯道
        uint8_t blackWhiteNum = 0;
        for (uint8_t i = FAR_LINE; i < FAR_LINE + 15; i++)
        {
            uint8_t jEnd = my_road[i].white_num;
            if (jEnd == 0)
            {
                blackWhiteNum++;
            }
            else
            {
                uint8_t maxWhiteWidth = 0;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    uint8_t curWhiteWidth = my_road[i].connected[j].width;
                    if (curWhiteWidth > maxWhiteWidth)
                    {
                        maxWhiteWidth = curWhiteWidth;
                    }
                }
                if (maxWhiteWidth < 8)
                {
                    blackWhiteNum++;
                }
            }
        }
        //环岛弯道补线
        if (blackWhiteNum > 10)
        {
            image_CurveTranslation(left_line, iStart, 92, 0, 20);
        }
        else
        {
            roundPatchFlag = 1;
            get_mid_line();
        }
        //get_mid_line();
        //image_MidLineFilterEx();
        break;
    }
    case rightRoundaboutStage6:
    {
        //uint8_t point = 20;
        //image_FindPatchPointEX(up, _left, &point, left_line);
        ///*uint8_t indxup = 0, indxdn = 106;
        //image_FindPatchPos(down, &indxup);
        //image_FindPatchPos(up, &indxdn);
        //IMG[indxup][right_line[indxup]] = 2;
        //image_LineRange(rightEdge[indxup], indxup, 5, 5, right_line, right_line, up);*/
        //image_LineRange(leftEdge[point + 20], point + 20, 5, 5, left_line, left_line, up);
        get_mid_line();
        uint8_t point = 20;
        image_FindBreakPoint(left_line, 0, &point);
        //if (point != MISS)
        //{
        //	image_LineRange(leftEdge[point + 10], point + 10, 10, 1, left_line, left_line, up);
        //	//image_CurveTranslation(right_line,100, point+15,1,20);
        //	image_GetMidSgl(left_line, _left, 1, point + 11, roadWidth);
        //}
        //else
        //{

        //}
        uint8_t rightConf = 0;
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            if (right_side[i] - right_line[i] > 5)
            {
                rightConf++;
            }
        }
        for (uint8_t i = point; i < 106; i++)
        {
            if (left_line[i] > left_line[i + 5] && left_line[i] - left_line[i + 5] > 2)
            {
                point = i;
                break;
            }
        }
        if (point != MISS)
        {
            if (rightConf > 60)
            {
                image_GetMidSgl(right_line, _right, point, 106, 30);
                image_LineRange(mid_line[point], point, 106 - point, 5, mid_line, mid_line, up);
            }
            else
            {
                float k = image_Line2Points(187, 1, left_line[point + 5], point + 5, left_line);
                if (abs(k) < 1e-3)k = 1e-3;
                image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
            }
        }
        break;
    }
    case rightRoundaboutStage7:
    {
        get_mid_line();
        /*uint8_t indxup = 0, indxdn = 106;
        image_FindPatchPos(down, &indxup, 113, 60);
        image_FindPatchPos(up, &indxdn, 113, 60);
        IMG[indxdn][rightEdge[indxdn]] = 2;*/
        //if (indxdn < 85 && indxdn>25)
        uint8_t downPoint = MISS;
        uint8_t leftInfo = 0;
        uint8_t longWightCont = 0;
        uint8_t rightConf = 0,rightConfBig = 0;
        for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
        {
            if (right_side[i] - right_line[i] > 5)
            {
                rightConf++;
            }
            if (right_side[i] - right_line[i] > 10)
            {
                rightConfBig++;
            }
        }
        for (uint8_t i = 106; i > 40; i--)
        {
            if (downPoint==MISS&&left_line[i] != left_side[i])
            {
                downPoint = i;
                break;
            }
        }
        for (uint8_t i = 110; i > 40; i--)
        {
            if (left_line[i] != left_side[i])
            {
                leftInfo++;
            }
            /*if (leftInfo != 0 && left_line[i] == leftEdge[i])
            {
                break;
            }*/
        }
        for (uint8_t i = 95; i > 40; i--)
        {
            if (my_road[i].connected[image_GetWIndex(_default, i)].width > (right_side[i] - left_side[i]) * 0.7)
            {
                longWightCont++;
            }
        }
        if (rightConf > 60)
        {
            /*downPoint = MISS;
            for (uint8_t i = 106; i > 40; i--)
            {
                if (downPoint == MISS && left_line[i] != left_side[i])
                {
                    downPoint = i;
                    break;
                }
            }*/
            uint8_t point = 20;
            image_FindBreakPoint(left_line, 0, &point);
            for (uint8_t i = point; i < 106; i++)
            {
                if (left_line[i] > left_line[i + 5] && left_line[i] - left_line[i + 5] > 2)
                {
                    point = i;
                    break;
                }
            }
            uint8_t missCont = 0;
            for (uint8_t i = 20; i < 106; i++)
            {
                if (my_road[i].white_num == 0)
                {
                    missCont++;
                }
            }
            if (rightConfBig > 40)
            {
                image_GetMidSgl(right_line, _right, 1, 106, 30);
                break;
            }
            else if (missCont < 10 && point < 100)
            {
                image_GetMidSgl(right_line, _right, point, 106, 30);
                image_LineRange(mid_line[point], point, 106 - point, 5, mid_line, mid_line, up);
                uint8_t errorCont = 0;
                for (uint8_t i = 25; i < 45; i++)
                {
                    if (mid_line[i] < 94)
                    {
                        errorCont++;
                    }
                }
                if (errorCont > 10)
                {
                    image_GetMidSgl(right_side, _right, 5, carForeheadCol, 20);
                }
                break;
            }
            else
            {
                if (rightConf > 70)
                {
                    image_GetMidSgl(right_line, _right, 1, 106, 30);
                }
                else
                {
                    image_GetMidSgl(right_side, _right, 1, 106, 30);
                }
            }
            uint8_t errorCont = 0;
            for (uint8_t i = 25; i < 45; i++)
            {
                if (mid_line[i] < 104)
                {
                    errorCont++;
                }
            }
            if (errorCont > 7)
            {
                image_GetMidSgl(right_side, _right, 5, carForeheadCol, 20);
            }
            break;
        }
        if (longWightCont > 20)
        {
            if (downPoint > 100 && leftInfo > 20)
            {
                uint8_t point = 20;
                image_FindBreakPoint(left_line, 0, &point);

                if (point != MISS && point <106)
                {
                    float k = image_Line2Points(187, 1, left_line[point + 5], point + 5, left_line);
                    if (abs(k) < 1e-3)k = 1e-3;
                    image_GetMidSgl(left_line, _left, 1, 106, abs(20 / (sin(atan(1 / k)))));
                }
                else
                {
                    uint8_t pos = 105, uppos;
                    for (; pos > 60; pos--)
                    {
                        if (left_line[pos] != left_side[pos])
                        {
                            break;
                        }
                    }
                    for (uppos = pos - 60; left_side[uppos] <= left_side[pos]; uppos--);
                    float k = (float)((float)left_side[uppos] - (float)left_side[pos]) / (float)((float)uppos - (float)pos);
                    if (abs(k) < 1e-3)k = 1e-3;
                    image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
                }
                //image_GetMidSgl(right_side, _right, 5, carForeheadCol, right_side[carForeheadCol] - mid_line[carForeheadCol]);
            }
            else if (leftInfo < 20)
            {
                uint8_t pos = 105, uppos;
                for (; pos > 60; pos--)
                {
                    if (left_line[pos] != left_side[pos])
                    {
                        break;
                    }
                }
                for (uppos = pos - 60; left_side[uppos] <= left_side[pos]; uppos--);
                float k = (float)((float)left_side[uppos] - (float)left_side[pos]) / (float)((float)uppos - (float)pos);
                if (abs(k) < 1e-3)k = 1e-3;
                if (k > 0)
                {
                    image_GetMidSgl(right_side, _right, 5, carForeheadCol, 20);
                }
                else
                {
                    image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
                }
            }
            else //if(downPoint>=80 && TiltFeatureMgr.leftMissCount > 35&& TiltFeatureMgr.rightMissCount>35)
            {
                image_GetMidSgl(right_side, _right, 5, carForeheadCol, 20);
            }
        }
        else
        {
            uint8_t pos = 105, uppos;
            for (; pos > 60; pos--)
            {
                if (left_line[pos] != left_side[pos])
                {
                    break;
                }
            }
            for (uppos = pos - 60; left_side[uppos] <= left_side[pos]; uppos--);
            float k = (float)((float)left_side[uppos] - (float)left_side[pos]) / (float)((float)uppos - (float)pos);
            if (abs(k) < 1e-3)k = 1e-3;
            if (k < 0)
            {
                image_GetMidSgl(right_side, _right, 5, carForeheadCol, 20);
            }
            else
            {
                image_GetMidSgl(left_line, _left, 1, 106, abs(roadWidth / (sin(atan(1 / k)))));
                uint8_t patchPoint = MISS;
                for (uint8_t i = 106; i > 60; i--)
                {
                    if (mid_line[i] > 134)
                    {
                        patchPoint = i;
                        break;
                    }
                }
                if (patchPoint != MISS)
                {
                    image_Line2Points(mid_line[patchPoint], patchPoint, 94, 106, mid_line);
                }
            }
        }
        uint8_t errorCont = 0;
        for (uint8_t i = 25; i < 45; i++)
        {
            if (mid_line[i] < 114)
            {
                errorCont++;
            }
        }
        if (errorCont > 5)
        {
            image_GetMidSgl(right_side, _right, 5, carForeheadCol, 20);
        }
        image_MidLineCorrector(50);
        /*else
        {
            image_GetMidSgl(right_line, _right, indxdn - 25, indxdn, right_line[indxdn] - mid_line[indxdn]);
            image_GetMidSgl(right_side, _right, 5, indxdn - 25, right_side[indxdn - 25] - mid_line[indxdn - 25]);
            image_LineRange(mid_line[44], 44, 10, 5, mid_line, mid_line, up);
        }*/
        break;
    }
    case rightRoundaboutStage8:
    {
        uint8_t pos = 105, uppos;
        for (; pos > 60; pos--)
        {
            if (left_line[pos] != left_side[pos])
            {
                break;
            }
        }
        for (uppos = pos - 60; left_line[uppos] <= left_line[pos] && uppos>1; uppos--);
        float k = (float)((float)left_side[uppos] - (float)left_side[pos]) / (float)((float)uppos - (float)pos);
        if (abs(k) < 1e-3)k = 1e-3;
        image_GetMidSgl(left_line, _left, 0, pos, abs(roadWidth / (sin(atan(1 / k)))));
        uint8_t right_point = MISS;
        for (uint8_t i = pos; i > pos - 60; i--)
        {
            if (mid_line[i] > 134)
            {
                right_point = i;
                break;
            }
        }
        if (right_point != MISS)
        {
            image_Line2Points(mid_line[right_point], right_point, 94, 106, mid_line);
        }
        image_MidLineCorrector(50);
        break;
    }
    case rightRoundaboutStage9:
    {
        if (TiltFeatureMgr.cuspLine != MISS && TiltFeatureMgr.cuspLine > 4)
        {
            image_GetMidSgl(left_line, _left, 0, 98, my_road[TiltFeatureMgr.cuspLine - 3].connected[image_GetWIndex(_left, TiltFeatureMgr.cuspLine - 3)].width / 2);
        }
        else if (rightJumpPos > 11 && rightJumpPos != MISS)
        {
            image_GetMidSgl(left_line, _left, 0, 98, my_road[rightJumpPos - 10].connected[image_GetWIndex(_default, rightJumpPos - 10)].width / 2);
        }
        else
        {
            image_GetMidSgl(left_line, _left, 0, 98, 26);
        }
        image_MidLineCorrector(20);
        break;
    }
    case stop:break;
    case enterZebra:
    {
        //平移补线
        if (ctrl_cirDir == 1)//左车库
        {
            uint8_t* ptrRightEdge = rightEdge;
            uint8_t* ptrRightLine = right_line;
            for (uint8_t i = FAR_LINE; i <= NEAR_LINE; i++)
            {
                *ptrRightLine = *ptrRightEdge;
                ptrRightLine++;
                ptrRightEdge++;
            }
            static uint8_t transDistance = MISS;
            if (edgeLineEnum & 0x80)
            {
                uint8_t iStart = MISS;
                if (leftJumpPos < 40)
                {
                    iStart = leftJumpPos + 30;
                }
                else
                {
                    iStart = leftJumpPos + 8;
                }
                for (uint8_t i = iStart; i >= leftJumpPos; i--)
                {
                    if (my_road[i].white_num == 1 && my_road[i].connected[1].width < 90)
                    {
                        transDistance = my_road[i].connected[1].width;
                        break;
                    }
                }
            }
            else if (edgeLineEnum & 0x40)
            {
                for (uint8_t i = leftJumpPos - 8; i <= leftJumpPos; i++)
                {
                    if (my_road[i].white_num == 1 && my_road[i].connected[1].width < 90)
                    {
                        transDistance = my_road[i].connected[1].width;
                        break;
                    }
                }
            }
            if (transDistance == MISS)
            {
                transDistance = 52;
            }
            if (transDistance != MISS)
            {
                for (uint8_t i = FAR_LINE; i <= NEAR_LINE; i++)
                {
                    if (right_line[i] > transDistance)
                    {
                        left_line[i] = right_line[i] - transDistance;
                    }
                    else
                    {
                        left_line[i] = 0;
                    }
                    IMG[i][left_line[i]] = red;
                }
            }
            get_mid_line();
        }
        else if (ctrl_cirDir == -1)//右车库
        {
            uint8_t* ptrLeftEdge = leftEdge;
            uint8_t* ptrLeftLine = left_line;
            for (uint8_t i = FAR_LINE; i <= NEAR_LINE; i++)
            {
                *ptrLeftLine = *ptrLeftEdge;
                ptrLeftLine++;
                ptrLeftEdge++;
            }
            static uint8_t transDistance = MISS;
            if (edgeLineEnum & 0x04)//看到下边的跳变
            {
                uint8_t iStart = MISS;
                if (rightJumpPos < 40)
                {
                    iStart = rightJumpPos + 30;
                }
                else
                {
                    iStart = rightJumpPos + 8;
                }
                for (uint8_t i = iStart; i >= rightJumpPos; i--)
                {
                    if (my_road[i].white_num == 1 && my_road[i].connected[1].width < 90)
                    {
                        transDistance = my_road[i].connected[1].width;
                        break;
                    }
                }
            }
            else if (edgeLineEnum & 0x08)//看到上边的跳变
            {
                for (uint8_t i = rightJumpPos - 8; i <= rightJumpPos; i++)
                {
                    if (my_road[i].white_num == 1 && my_road[i].connected[1].width < 90)
                    {
                        transDistance = my_road[i].connected[1].width;
                        break;
                    }
                }
            }
            if (transDistance == MISS)
            {
                transDistance = 52;
            }
            if (transDistance != MISS)
            {
                for (uint8_t i = FAR_LINE; i <= NEAR_LINE; i++)
                {
                    if (187 - left_line[i] > transDistance)
                    {
                        right_line[i] = left_line[i] + transDistance;
                    }
                    else
                    {
                        right_line[i] = 187;
                    }
                    IMG[i][right_line[i]] = red;
                }
            }
            get_mid_line();
        }
        break;
    }
    case quitZebra:break;
    case enterGarage:break;
    case others:
    {
        get_mid_line();
        if (image_remedyFlag == 0)//左边
        {
            uint8_t point = carForeheadCol;
            uint8_t point_up = 0;
            float k = 1e25;
            if (~edgeLineEnum & 0x40)
            {
                uint8_t pointCont = MISS;
                image_FindBreakPoint(left_line, 0, &point);
                for (uint8_t i = 106; i > 80; i--)
                {
                    if (leftEdge[i] != left_side[i])
                    {
                        pointCont = i;
                        break;
                    }
                }
                for (uint8_t i = point; i < NEAR_LINE - 5; i++)
                {
                    if (leftEdge[i] > leftEdge[i + 4] && leftEdge[i] - leftEdge[i + 4] > 2)
                    {
                        point = i;
                        break;
                    }
                }
                if (pointCont != MISS&&point!=MISS)
                {
                    image_GetMidSgl(left_line, _left, point, pointCont, roadWidth);
                    image_LineRange(mid_line[point], point, pointCont - point, 1, mid_line, mid_line, up);
                }
                else
                {
                    ;
                }
                /*if (point != MISS && point < 80 && point>20)
                {
                    if (pointCont == MISS)
                    {
                        k = image_LineRange(left_line[point + 20], point + 20, 10, 5, left_line, left_line, up);
                    }
                    else
                    {
                        k = image_LineRange(left_line[point + 20], point + 20, pointCont-point-20, 5, left_line, left_line, up);
                    }
                }
                else if (point != MISS && point >= 80 && point < 100)
                {
                    k = image_LineRange(left_line[point + 5], point + 5, 10, 5, left_line, left_line, up);
                }
                else if (point != MISS && point <= 20)
                {
                    k = image_LineRange(left_line[50], 50, 5, 5, left_line, left_line, up);
                }
                if (pointCont != MISS)
                {
                    if (abs(k) > 1e-3 && k < 1e190)
                    {
                        image_GetMidSgl(left_line, _left, 1, pointCont, abs(roadWidth / (sin(atan(1 / k)))));
                    }
                    else
                    {
                        image_GetMidSgl(left_line, _left, 1, pointCont, roadWidth);
                    }
                }
                else
                {
                    image_GetMidSgl(left_line, _left, 1, 106, roadWidth);
                }*/
                //get_mid_line();
            }
        }
        else if (image_remedyFlag == 1)//右边
        {
            uint8_t point = carForeheadCol;
            uint8_t point_up = 0;
            float k = 1e25;
            if (~edgeLineEnum & 0x08)//没有右边线左延申
            {
                uint8_t pointCont = MISS;
                image_FindBreakPoint(right_line, 1, &point);
                for (uint8_t i = 106; i > 80; i--)
                {
                    if (rightEdge[i] != right_side[i])
                    {
                        pointCont = i;
                        break;
                    }
                }
                for (uint8_t i = point; i < NEAR_LINE - 5; i++)
                {
                    if (rightEdge[i] < rightEdge[i + 4] && rightEdge[i + 4] - rightEdge[i] > 2)
                    {
                        point = i;
                        break;
                    }
                }
                if (pointCont != MISS&&point!=MISS)
                {
                    image_GetMidSgl(right_line, _right, point, pointCont, roadWidth);
                    image_LineRange(mid_line[point], point, pointCont - point, 1, mid_line, mid_line, up);
                }
                else
                {
                    ;
                }
                /*if (point != MISS && point < 80 && point>20)
                {
                    k = image_LineRange(right_line[point + 20], point + 20, 10, 5, right_line, right_line, up);
                }
                else if (point != MISS && point < 100 && point >= 80)
                {
                    k = image_LineRange(right_line[point + 5], point + 5, 10, 5, right_line, right_line, up);
                }
                else if (point != MISS && point <= 20)
                {
                    k = image_LineRange(right_line[50], 50, 5, 5, right_line, right_line, up);
                }
                if (pointCont != MISS)
                {
                    if (abs(k) > 1e-3 && k < 1e190)
                    {
                        image_GetMidSgl(right_line, _right, 1, pointCont, abs(roadWidth / (sin(atan(1 / k)))));
                    }
                    else
                    {
                        image_GetMidSgl(right_line, _right, 1, pointCont, roadWidth);
                    }
                }
                else
                {
                    image_GetMidSgl(right_line, _right, 1, 106, roadWidth);
                }*/
                //get_mid_line();
            }
        }
        else if (image_remedyFlag == 2 && TiltFeatureMgr.cuspLine != 255)//左边车前点
        {
            //image_Line2Points(my_road[cuspLine].connected[image_GetWIndex(_right, cuspLine)].left, cuspLine, 65, 106,left_line);
            uint8_t pos = 0;
            for (uint8_t i = my_road[TiltFeatureMgr.cuspLine].white_num; i >= 1; i--)
            {
                if (my_road[TiltFeatureMgr.cuspLine].connected[i].width > 5)
                {
                    pos = i;
                    break;
                }
            }
            if (pos)
            {
                float k = image_Line2Points(my_road[TiltFeatureMgr.cuspLine].connected[pos].left, TiltFeatureMgr.cuspLine, carForeheadLeft, carForeheadCol, left_line);
                uint8_t transWidth = abs((roadWidth / (sin(atan(k)))));
                image_GetMidSgl(left_line, _left, 1, 106, transWidth);
            }
            else
            {
                get_mid_line();
            }
        }
        else if (image_remedyFlag == 3 && TiltFeatureMgr.cuspLine != 255)//右边车前点
        {
            //image_Line2Points(my_road[cuspLine].connected[image_GetWIndex(_right, cuspLine)].left, cuspLine, 65, 106,left_line);
            uint8_t pos = 0;
            for (uint8_t i = 1; i <= my_road[TiltFeatureMgr.cuspLine].white_num; i++)
            {
                if (my_road[TiltFeatureMgr.cuspLine].connected[i].width > 5)
                {
                    pos = i;
                    break;
                }
            }
            if (pos)
            {
                float k = image_Line2Points(my_road[TiltFeatureMgr.cuspLine].connected[pos].right, TiltFeatureMgr.cuspLine, carForefeadRight, carForeheadCol, right_line);
                uint8_t transWidth = abs((roadWidth / (sin(atan(k)))));
                image_GetMidSgl(right_line, _right, 1, 106, transWidth);
            }
            else
            {
                get_mid_line();
            }
        }
        else if (image_remedyFlag == 4)//只有右边线
        {
            uint8_t iStart = MISS, iEnd = MISS;
            for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 15)
                    {
                        iStart = i;
                        break;
                    }
                }
                if (iStart != MISS)
                {
                    break;
                }
            }
            for (uint8_t i = NEAR_LINE - 1; i > FAR_LINE; i--)
            {
                if (right_side[i] - right_line[i] > 3)
                {
                    iEnd = i;
                    break;
                }
            }
            printf("iStart:%d\n", iStart);
            image_CurveTranslation(right_line, iStart + 10, iEnd, 1, roadWidth);
        }
        else if (image_remedyFlag == 5)
        {
            uint8_t iStart = MISS, iEnd = MISS;
            for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
            {
                uint8_t jEnd = my_road[i].white_num;
                for (uint8_t j = 1; j <= jEnd; j++)
                {
                    if (my_road[i].connected[j].width > 15)
                    {
                        iStart = i;
                        break;
                    }
                }
                if (iStart != MISS)
                {
                    break;
                }
            }
            for (uint8_t i = NEAR_LINE - 1; i > FAR_LINE; i--)
            {
                if (left_line[i] - left_side[i] > 3)
                {
                    iEnd = i;
                    break;
                }
            }
            printf("iStart:%d\n", iStart);
            image_CurveTranslation(left_line, iStart + 10, iEnd, 0, roadWidth);
        }
        else if (image_remedyFlag == 6)
        {
            uint8_t point_right = 0, point_left = 0, breakPointFix = 255;
            //image_FindPatchPointEX(up, _right, &point, right_line);
            image_FindBreakPoint(right_line, 1, &point_right);
            if (point_right != 255)
            {
                for (breakPointFix = point_right; breakPointFix < point_right + 20; breakPointFix++)
                {
                    if (right_line[breakPointFix] < right_line[breakPointFix + 1] && right_line[breakPointFix + 1] - right_line[breakPointFix] >= 1)
                    {
                        point_right = breakPointFix;
                        break;
                    }
                }
            }
            /*if (point < 90)
            {
                uint8_t downPoint = MISS;
                for (uint8_t i = point + 10; i > point + 5; i--)
                {
                    if (right_line[i] != right_side[i])
                    {
                        downPoint = i;
                        break;
                    }
                }
                if (downPoint != MISS)
                {
                    image_LineRange(right_line[point], point, downPoint - point, 1, right_line, right_line, up);
                }
            }*/
            //image_FindPatchPointEX(up, _left, &point, left_line);
            image_FindBreakPoint(left_line, 0, &point_left);
            if (point_left != 255)
            {
                for (breakPointFix = point_left; breakPointFix < point_left + 20; breakPointFix++)
                {
                    if (left_line[breakPointFix] > left_line[breakPointFix + 1] && left_line[breakPointFix] - left_line[breakPointFix + 1] >= 1)
                    {
                        point_left = breakPointFix;
                        break;
                    }
                }
            }
            if (point_right < 90 && point_left < 90)
            {
                uint8_t point = point_right > point_left ? point_right : point_left;
                uint8_t downPoint_left = MISS, downPoint_right = MISS;
                for (uint8_t i = point + 10; i > point + 5; i--)
                {
                    if (left_line[i] != left_side[i])
                    {
                        downPoint_left = i;
                        break;
                    }
                }
                for (uint8_t i = point + 10; i > point + 5; i--)
                {
                    if (right_line[i] != right_side[i])
                    {
                        downPoint_right = i;
                        break;
                    }
                }
                if (downPoint_left != MISS && downPoint_right != MISS)
                {
                    image_LineRange(left_line[point + 5], point + 5, downPoint_left - point - 5, 1, left_line, left_line, up);
                    image_LineRange(right_line[point + 5], point + 5, downPoint_right - point, 1, right_line, right_line, up);
                    get_mid_line();
                }
                else if (downPoint_left == MISS && downPoint_right != MISS)
                {
                    get_mid_line();
                    float k = image_LineRange(right_line[point + 5], point + 5, downPoint_right - point - 5, 1, right_line, right_line, up);
                    if (abs(k) < 1e-5)	k = 1e-5;
                    image_GetMidSgl(right_line, _right, 1, downPoint_right, abs(roadWidth / (sin(atan(1 / k)))));
                }
                else if (downPoint_left != MISS && downPoint_right == MISS)
                {
                    get_mid_line();
                    float k = image_LineRange(left_line[point + 5], point + 5, downPoint_left - point - 5, 1, left_line, left_line, up);
                    if (abs(k) < 1e-5)	k = 1e-5;
                    image_GetMidSgl(left_line, _left, 1, downPoint_left, abs(roadWidth / (sin(atan(1 / k)))));
                }
                else
                {
                    my_memset(mid_line, 94, 120);
                }
            }
        }
        /*else if (image_remedyFlag == 7)
        {
        image_PerfectCurvePatch();
        }*/
        else
        {
            if (edgeLineEnum & 0x10)//左线未丢失信息
            {
                uint8_t leftiStart = 0;
                for (uint8_t i = NEAR_LINE; i > 30; i--)
                {
                    if (leftEdge[i] - left_side[i] > 3)
                    {
                        leftiStart = i;
                        break;
                    }
                }
                printf("leftiStart:%d\n", leftiStart);
                if (leftiStart <= 95 && leftiStart > 45)//检查另一边线的信息
                {
                    uint8_t validRightNum = 0;
                    for (uint8_t i = leftiStart - 10; i < NEAR_LINE; i++)
                    {
                        if (right_side[i] - rightEdge[i] > 3)
                        {
                            validRightNum++;
                        }
                    }
                    printf("validRightNum:%d\n", validRightNum);
                    if (validRightNum > 25)
                    {
                        uint8_t transWidth = MISS, jEnd = my_road[leftiStart].white_num;
                        for (uint8_t j = 1; j <= jEnd; j++)
                        {
                            if (my_road[leftiStart].connected[j].width > 10)
                            {
                                transWidth = my_road[leftiStart].connected[j].width / 2;
                                break;
                            }
                        }
                        if (transWidth != MISS)
                        {
                            for (uint8_t i = leftiStart; i < NEAR_LINE; i++)
                            {
                                mid_line[i] = right_line[i] - transWidth;
                            }
                        }
                    }
                }
            }
            if (edgeLineEnum & 0x01)
            {
                uint8_t rightiStart = 0;
                for (uint8_t i = NEAR_LINE; i > 30; i--)
                {
                    if (right_side[i] - rightEdge[i] > 3)
                    {
                        rightiStart = i;
                        break;
                    }
                }
                printf("rightiStart:%d\n", rightiStart);
                if (rightiStart <= 95 && rightiStart > 45)
                {
                    uint8_t validLeftNum = 0;
                    for (uint8_t i = rightiStart - 10; i < NEAR_LINE; i++)
                    {
                        if (leftEdge[i] - left_side[i] > 3)
                        {
                            validLeftNum++;
                        }
                    }
                    printf("validLeftNum:%d\n", validLeftNum);
                    if (validLeftNum > 25)
                    {
                        uint8_t transWidth = MISS, jEnd = my_road[rightiStart].white_num;
                        for (uint8_t j = 1; j <= jEnd; j++)
                        {
                            if (my_road[rightiStart].connected[j].width > 10)
                            {
                                transWidth = my_road[rightiStart].connected[j].width / 2;
                                break;
                            }
                        }
                        if (transWidth != MISS)
                        {
                            for (uint8_t i = rightiStart; i < NEAR_LINE; i++)
                            {
                                mid_line[i] = left_line[i] + transWidth;
                            }
                        }
                    }
                }
            }
            if (~edgeLineEnum & 0x01 && edgeLineEnum & 0x10 && leftVaric < 10)//右线丢失，左线笔直，平移
            {
                int transWidth = MISS;
                float kLeft = ((float)FAR_LINE + 5 - 80) / ((float)leftEdge[FAR_LINE + 5] - leftEdge[80]);
                transWidth = 28 / abs(sin(atan(kLeft)));
                if (transWidth > 55)
                {
                    transWidth = 55;
                }
                if (transWidth != MISS)
                {
                    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
                    {
                        mid_line[i] = leftEdge[i] + transWidth;
                    }
                }
            }
            if (~edgeLineEnum & 0x10 && edgeLineEnum & 0x01 && rightVaric < 10)
            {
                int transWidth = MISS;
                float kRight = ((float)FAR_LINE + 5 - 80) / ((float)rightEdge[FAR_LINE + 5] - rightEdge[80]);
                transWidth = 28 / abs(sin(atan(kRight)));
                if (transWidth > 55)
                {
                    transWidth = 55;
                }
                if (transWidth != MISS)
                {
                    for (uint8_t i = FAR_LINE; i < NEAR_LINE; i++)
                    {
                        mid_line[i] = rightEdge[i] - transWidth;
                    }
                }
            }
            image_MidLineFilterEx();
        }
        break;
    }
    default:break;
    }
    //image_MidLineFilter();
    //image_MidLineCorrector();
    //KalmanFilter();
}
////////////////////////////////////////////
//功能：寻找开始补线的起点行
//输入：巡点方向(up/down)，补线起点
//输出：
//备注：
///////////////////////////////////////////

void image_FindPatchPos(uint8_t direct, uint8_t* pos, uint8_t near, uint8_t far)
{
    *pos = carForeheadCol;
    if (!direct)
    {
        for (int i = near; i > far; i--)
        {
            uint8_t w_curindex = image_GetWIndex(_default, i);
            uint8_t w_nexindex = image_GetWIndex(_default, i - 3);
            uint8_t w_furindex = image_GetWIndex(_default, i - 6);
            w_curindex = my_road[i].connected[w_curindex].width;
            w_nexindex = my_road[i - 3].connected[w_nexindex].width;
            w_furindex = my_road[i - 6].connected[w_furindex].width;
            if (abs(w_nexindex - w_curindex) <= 3 && abs(w_furindex - w_curindex) > 3
                /*&& ((my_road[i].connected[w_curindex].left > my_road[i - 6].connected[w_furindex].left && my_road[i].connected[w_curindex].left < my_road[i - 6].connected[w_furindex].right)
                    || my_road[i].connected[w_curindex].right > my_road[i - 6].connected[w_furindex].left && my_road[i].connected[w_curindex].right < my_road[i - 6].connected[w_furindex].right)*/)
            {
                *pos = i;
                return;
            }
        }
        *pos = carForeheadCol;
    }
    else if (direct)
    {
        for (int i = 1; i < far; i++)
        {
            uint8_t w_curindex = image_GetWIndex(_default, i);
            uint8_t w_nexindex = image_GetWIndex(_default, i + 3);
            uint8_t w_furindex = image_GetWIndex(_default, i + 6);
            w_curindex = my_road[i].connected[w_curindex].width;
            w_nexindex = my_road[i + 3].connected[w_nexindex].width;
            w_furindex = my_road[i + 6].connected[w_furindex].width;
            if (abs(w_nexindex - w_curindex) <= 3 && abs(w_furindex - w_curindex) > 3
                /*&& ((my_road[i].connected[w_curindex].left> my_road[i + 6].connected[w_furindex].left&& my_road[i].connected[w_curindex].left < my_road[i + 6].connected[w_furindex].right)
                || my_road[i].connected[w_curindex].right > my_road[i + 6].connected[w_furindex].left && my_road[i].connected[w_curindex].right < my_road[i + 6].connected[w_furindex].right)*/)
            {
                *pos = i;
                return;
            }
        }
        *pos = 45;
    }
}
////////////////////////////////////////////
//功能：寻找开始补线的起点(向外)
//输入：巡点方向(up/down)，边线方向，补线起点 ,边线矩阵
//输出：
//备注：
///////////////////////////////////////////
void image_FindPatchPointEX(uint8_t direct, uint8_t d_line, uint8_t* point, uint8_t* line)
{
    float k_curr, k_pre;
    if (direct == up)
    {
        k_pre = (line[110 - 1] - line[110 + 1]) / 3.0;
        for (uint8_t i = 110; i > 10; i--)
        {
            k_curr = (line[i - 1] - line[i + 1]) / 3.0;
            if (d_line == _right)
            {
                if (k_pre - k_curr < -1)
                {
                    if (i < 90)
                    {
                        *point = i;
                        break;
                    }
                }
            }
            else
            {
                if (k_pre - k_curr > 1)
                {
                    if (i < 90)
                    {
                        *point = i;
                        break;
                    }
                }
            }
            k_pre = k_curr;
        }
    }
    else if (direct == down)
    {
        k_pre = (line[10 - 2] - line[10 + 2]) / 3.0;
        for (uint8_t i = 10; i < 110; i++)
        {
            k_curr = (line[i - 2] - line[i + 2]) / 3.0;
            if (d_line == _right)
            {
                if (k_pre - k_curr < -1)
                {
                    if (i > 15)
                    {
                        *point = i;
                        break;
                    }
                }
            }
            else
            {
                if (k_pre - k_curr > 1)
                {
                    if (i > 15)
                    {
                        *point = i;
                        break;
                    }
                }
            }
            k_pre = k_curr;
        }
    }
}

////////////////////////////////////////////
//功能：确定折点位置
//输入：
//输出：
//备注：direct：0为左线，1为右线
///////////////////////////////////////////

void image_FindBreakPoint(uint8_t* line, uint8_t direct, uint8_t* ptrBreakPoint)
{
    //找左线折点
    if (direct == 0)
    {
        uint8_t* ptrLeftSide = &left_side[NEAR_LINE - 1], * ptrLeftLine = &line[NEAR_LINE - 1];
        uint8_t iStart = MISS;
        for (uint8_t i = NEAR_LINE - 1; i >= 60; i--)
        {
            if (*ptrLeftLine != MISS)
            {
                if (*ptrLeftLine - *ptrLeftSide > 3)
                {
                    iStart = i;
                    break;
                }
            }
            ptrLeftLine--, ptrLeftSide--;
        }
        if (iStart < 85)
        {
            *ptrBreakPoint = MISS;
            return;
        }
        if (iStart != MISS)
        {
            uint8_t ifGetBreakPoint = 0;//没找到返回MISS
            ptrLeftLine = &line[iStart];
            for (uint8_t i = iStart; i >= FAR_LINE + 5; i--)
            {
                if (*ptrLeftLine - left_side[i] > 3 && *ptrLeftLine > *(ptrLeftLine - 3) && *ptrLeftLine - *(ptrLeftLine - 3) >= 3)
                {
                    *ptrBreakPoint = i;
                    ifGetBreakPoint = 1;
                    break;
                }
                ptrLeftLine--;
            }
            if (ifGetBreakPoint == 0)
            {
                *ptrBreakPoint = MISS;
            }
        }
        else
        {
            *ptrBreakPoint = MISS;
        }
    }
    else//找右线折点
    {
        uint8_t* ptrRightSide = &right_side[NEAR_LINE - 1], * ptrRightLine = &line[NEAR_LINE - 1];
        uint8_t iStart = MISS;
        for (uint8_t i = NEAR_LINE - 1; i >= 60; i--)
        {
            if (*ptrRightLine != MISS)
            {
                if (*ptrRightSide - *ptrRightLine > 3)
                {
                    iStart = i;
                    break;
                }
            }
            ptrRightLine--, ptrRightSide--;
        }
        if (iStart < 85)
        {
            *ptrBreakPoint = MISS;
            return;
        }
        if (iStart != MISS)
        {
            uint8_t ifGetBreakPoint = 0;
            ptrRightLine = &line[iStart];
            for (uint8_t i = iStart; i >= FAR_LINE + 5; i--)
            {
                if (right_side[i] - *ptrRightLine > 3 && *ptrRightLine < *(ptrRightLine - 3) && *(ptrRightLine - 3) - *ptrRightLine >= 3)
                {
                    *ptrBreakPoint = i;
                    ifGetBreakPoint = 1;
                    break;
                }
                ptrRightLine--;
            }
            if (ifGetBreakPoint == 0)
            {
                *ptrBreakPoint = MISS;
            }
        }
        else
        {
            *ptrBreakPoint = MISS;
        }
    }
}

////////////////////////////////////////////
//功能：寻找白条编号
//输入：
//输出：
//备注：没找到输出0
///////////////////////////////////////////
uint8_t image_GetWhiteIndex(uint8_t direct, uint8_t pos)
{
    uint8_t jResult = 0;
    if (direct == _left)
    {
        uint8_t jEnd = my_road[pos].white_num;
        for (uint8_t j = 1; j <= jEnd; j++)
        {
            if (my_road[pos].connected[j].width > 25)
            {
                jResult = j;
                break;
            }
        }
    }
    if (direct == _right)
    {
        uint8_t jEnd = my_road[pos].white_num;
        for (uint8_t j = jEnd; j >= 1; j--)
        {
            if (my_road[pos].connected[j].width > 25)
            {
                jResult = j;
                break;
            }
        }
    }
    return jResult;

}

////////////////////////////////////////////
//功能：确定白条编号
//输入：期望白条位置,行数
//输出：白条编号
//备注：如果偏左/右边未找到就返回中间白条编号
///////////////////////////////////////////
uint8_t image_GetWIndex(uint8_t direct, uint8_t pos)
{
    if (direct == _left)
    {
        for (uint8_t i = 1; i <= my_road[pos].white_num; i++)
        {
            if (my_road[pos].connected[i].width >= roadWidth)
            {
                if ((my_road[pos].connected[i].right / 2 + my_road[pos].connected[i].left / 2) < 94)
                {
                    return i;
                }
            }
        }
        uint8_t widthMaxIndex = 0, widthMax = 0;
        for (uint8_t i = 1; i <= my_road[pos].white_num; i++)
        {
            if (my_road[pos].connected[i].width >= roadWidth && my_road[pos].connected[i].width > widthMax)
            {
                widthMaxIndex = i;
                widthMax = my_road[pos].connected[i].width;
            }
        }
        return widthMaxIndex;
    }
    if (direct == _right)
    {
        for (uint8_t i = my_road[pos].white_num; i >= 1; i--)
        {
            if (my_road[pos].connected[i].width >= roadWidth)
            {
                if ((my_road[pos].connected[i].right / 2 + my_road[pos].connected[i].left / 2) > 94)
                {
                    return i;
                }
            }
        }
        uint8_t widthMaxIndex = 0, widthMax = 0;
        for (uint8_t i = 1; i <= my_road[pos].white_num; i++)
        {
            if (my_road[pos].connected[i].width >= roadWidth && my_road[pos].connected[i].width > widthMax)
            {
                widthMaxIndex = i;
                widthMax = my_road[pos].connected[i].width;
            }
        }
        return widthMaxIndex;
    }
    if (direct == _mid)
    {
        for (uint8_t i = 1; i <= my_road[pos].white_num; i++)
        {
            if (my_road[pos].connected[i].width >= roadWidth)
            {
                if (my_road[pos].connected[i].left < 94 && my_road[pos].connected[i].right>94)
                {
                    return i;
                }
            }
        }
        uint8_t widthMaxIndex = 0, widthMax = 0;
        for (uint8_t i = 1; i <= my_road[pos].white_num; i++)
        {
            if (my_road[pos].connected[i].width >= roadWidth && my_road[pos].connected[i].width > widthMax)
            {
                widthMaxIndex = i;
                widthMax = my_road[pos].connected[i].width;
            }
        }
        return widthMaxIndex;
    }
    if (direct == _default)
    {
        uint8_t widthMaxIndex = 0, widthMax = 0;
        for (uint8_t i = 1; i <= my_road[pos].white_num; i++)
        {
            if (my_road[pos].connected[i].width >= roadWidth && my_road[pos].connected[i].width > widthMax)
            {
                widthMaxIndex = i;
                widthMax = my_road[pos].connected[i].width;
            }
        }
        return widthMaxIndex;
    }
    return 1;
}
////////////////////////////////////////////
//功能：两点画线
//输入：两点坐标（上边点，下边点）
//输出：
//备注：
///////////////////////////////////////////
float image_Line2Points(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t* line)
{
    float x = x1;
    for (int i = y1; i < y2; i++)
    {
        float k = (float)(x2 - x) / (float)(y2 - i);
        x = x + k;
        IMG[i][(int)x] = 3;
        line[i] = x;
    }
    if (x1 != x2)
    {
        return (float)((float)y1 - (float)y2) / ((float)x1 - (float)x2);
    }
    else
    {
        return (float)1e100;
    }
}
////////////////////////////////////////////
//功能：根据已知拟线
//输入：起点坐标，斜率计算范围，终点行，参考矩阵，画线矩阵，画线方向
//输出：
//备注：
///////////////////////////////////////////
float image_LineRange(uint8_t x, uint8_t y, uint8_t range, uint8_t end, uint8_t* s_line, uint8_t* d_line, uint8_t direct)
{
    float k = 0, b = 0;
    /*for (uint8_t i = 0; i < range; i++)
    {
        k += (float)(s_line[y + i] - s_line[y]) / (float)range;
    }
    k /= range;*/
    if (1 == image_LeastSquare(&k, &b, y, y + range, s_line))
    {
        k = 1 / k;
    }
    else
    {
        k = 0;
    }
    if (direct == up)
    {
        //k = (float)(s_line[y + range] - s_line[y]) / (float)range;
        for (uint8_t i = y; i > end; i--)
        {
            int16_t t = (float)x + k * (i - y);
            if (t > 187)
            {
                for (; i > end; i--)
                {
                    d_line[i] = 187;
                    IMG[i][d_line[i]] = 3;
                }
                break;
            }
            else if (t < 0)
            {
                for (; i > end; i--)
                {
                    d_line[i] = 0;
                    IMG[i][d_line[i]] = 3;
                }
                break;
            }
            d_line[i] = t;
            IMG[i][(int)t] = 3;
        }
    }
    else
    {
        //k = (float)(s_line[y - range] - s_line[y]) / (float)range;
        for (uint8_t i = y; i < end; i++)
        {
            int16_t t = (float)x + k * (i - y);
            if (t > 187)
            {
                for (; i < end; i++)
                {
                    d_line[i] = 187;
                    IMG[i][d_line[i]] = 3;
                }
                break;
            }
            else if (t < 0)
            {
                for (; i < end; i++)
                {
                    d_line[i] = 0;
                    IMG[i][d_line[i]] = 3;
                }
                break;
            }
            d_line[i] = t;
            IMG[i][(int)t] = 3;
        }
    }
    return k;
}
////////////////////////////////////////////
//功能：寻单线
//输入：参考矩阵，参考边线, 补线范围，中线偏置
//输出：
//备注：
///////////////////////////////////////////
void image_GetMidSgl(uint8_t* line, uint8_t direct, uint8_t farline, uint8_t nearline, uint8_t width)
{
    if (direct == _left)
    {
        for (uint8_t i = farline; i < nearline; i++)
        {
            int temp = line[i] + width;
            if (temp > 187)
            {
                mid_line[i] = 187;
            }
            else
            {
                mid_line[i] = line[i] + width;
            }
        }
    }
    if (direct == _right)
    {
        for (uint8_t i = farline; i < nearline; i++)
        {
            int temp = line[i] - width;
            if (temp < 0)
            {
                mid_line[i] = 0;
            }
            else
            {
                mid_line[i] = line[i] - width;
            }
        }
    }
}

////////////////////////////////////////////
//功能：弯道平移寻单线
//输入：参考边线，计算范围，哪一根线，0为左，1为右，道路宽度
//输出：
//备注：
///////////////////////////////////////////
uint8_t image_CurveTranslation(uint8_t* ptrLine, uint8_t iStart, uint8_t iEnd, uint8_t direct, uint8_t roadWidth)
{
    int16_t averTranWidth = 0;
    uint8_t counter = 0;
    if (direct == 1)
    {
        //计算范围内平移
        for (uint8_t i = iEnd; i >= iStart + 8; i -= 8)
        {
            if (right_line[i] > right_line[i - 8] && right_line[i] - right_line[i - 8] >= 4&& right_line[i] - right_line[i - 8]<=12)
            {
                float k = (8) / ((float)right_line[i] - right_line[i - 8]);
                printf("k:%f\n", k);
                counter++;
                averTranWidth += (roadWidth / abs(sin(atan(k))));
            }
        }
        if (counter > 0)
        {
            averTranWidth /= counter;
        }
        printf("averTranWidth:%d\n", averTranWidth);
        if (averTranWidth < 35)
        {
            averTranWidth = 35;
        }
        if (averTranWidth > 60)
        {
            averTranWidth = 60;
        }
        for (uint8_t i = iEnd; i >= iStart; i--)
        {
            midLine[i] = (int16_t)right_line[i] - averTranWidth;
            //IMG[i][midLine[i]] = green;
            //printf("midLine[%d]:%d\n", i, midLine[i]);
        }
        //向上补线
        float m = ((double)midLine[iStart + 10] - (double)midLine[iStart]) / 10.0;
        float n = midLine[iStart] - m * iStart;
        for (uint8_t i = iStart; i > 20; i--)
        {
            midLine[i] = m * i + n;
            //IMG[i][midLine[i]] = green;
            //printf("midLine[%d]:%d\n", i, midLine[i]);
        }

    }
    else if (direct == 0)
    {
        //计算范围内平移
        for (uint8_t i = iEnd; i >= iStart + 8; i -= 8)
        {
            if (left_line[i] < left_line[i - 8] && left_line[i - 8] - left_line[i] >= 4&& left_line[i - 8] - left_line[i]<=12)
            {
                float k = (8) / ((float)left_line[i] - left_line[i - 8]);
                printf("k:%f\n", k);
                counter++;
                averTranWidth += (roadWidth / abs(sin(atan(k))));
            }
        }
        if (counter > 0)
        {
            averTranWidth /= counter;
        }
        printf("averTranWidth:%d\n", averTranWidth);
        if (averTranWidth < 40)
        {
            averTranWidth = 40;
        }
        if (averTranWidth > 70)
        {
            averTranWidth = 70;
        }
        for (uint8_t i = iEnd; i >= iStart; i--)
        {
            midLine[i] = (int16_t)left_line[i] + averTranWidth;
            //printf("midLine[%d]:%d\n", i, midLine[i]);
        }
        //向上补线
        float m = ((double)midLine[iStart + 10] - (double)midLine[iStart]) / 10.0;
        float n = midLine[iStart] - m * iStart;
        for (uint8_t i = iStart; i > 20; i--)
        {
            midLine[i] = m * i + n;
            //printf("midLine[%d]:%d\n", i, midLine[i]);
        }
    }
    return 1;
}
////////////////////////////////////////////
//功能：弯道完美曲线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_PerfectCurvePatch(void)
{
    //寻找左右线起末
    uint8_t iLeftStart = MISS, iLeftEnd = MISS, iRightEnd = MISS, iRightStart = MISS;
    for (uint8_t i = NEAR_LINE - 5; i > NEAR_LINE - 30; i--)
    {
        if (iLeftStart == MISS && leftEdge[i] - left_side[i] > 2)
        {
            iLeftStart = i;
        }
        if (iRightStart == MISS && right_side[i] - rightEdge[i] > 2)
        {
            iRightStart = i;
        }
        if (iLeftStart != MISS && iRightStart != MISS)
        {
            break;
        }
    }
    for (uint8_t i = FAR_LINE; i < FAR_LINE + 50; i++)
    {
        if (leftEdge[i] != MISS)
        {
            iLeftEnd = i;
            break;
        }
    }
    if (iRightStart != MISS)
    {
        for (uint8_t i = iRightStart; i > FAR_LINE; i--)
        {
            if (right_side[i] - rightEdge[i] < 2)
            {
                iRightEnd = i;
                break;
            }
        }
    }
    if (iLeftStart != MISS && iLeftEnd != MISS && iRightStart != MISS && iRightEnd != MISS)
    {
        float leftFirX = leftEdge[iLeftStart], leftSecX = leftEdge[iLeftStart - 5];
        float rightFirX = rightEdge[iRightStart], rightSecX = rightEdge[iRightStart - 5];
        int leftFirY = iLeftStart, leftSecY = iLeftStart - 5, rightFirY = iRightStart, rightSecY = iRightStart - 5;
        while (leftSecY > iLeftEnd)
        {
            //确定左右点
            float stdDis = image_GetDistance(rightSecX, leftFirX, rightSecY, leftFirY),kRight = (rightFirY-rightSecY)/(rightFirX-rightSecX);
            float minDis = MISS;
            uint8_t realLeftY = leftSecY;
            for (uint8_t i = leftSecY; i > iLeftEnd; i--)
            {
                float curDis = image_GetDistance(rightFirX, leftEdge[i], rightFirY, i);
                float curK = MISS;
                if (leftFirX != leftEdge[i])
                {
                    curK = (leftFirY - i) / (leftFirX-leftEdge[i]);
                }
                if (abs(curDis - stdDis) < 1.5)
                {
                    //printf("Find dis %d\n", i);
                    if (curK != MISS && abs(atan(curK) - atan(kRight)) < 0.15)
                    {
                        printf("Find k %d\n", i);
                        realLeftY = i;
                        break;
                    }
                }

            }
            leftSecX = leftEdge[realLeftY];
            //算中线点
            float k1, b1, k2, b2,c1 = MISS,c2=MISS;
            if (leftSecX == rightFirX)
            {
                c1 = leftSecX;
            }
            else
            {
                k1 = ((float)realLeftY - rightFirY) / (leftSecX-rightFirX);
                b1 = realLeftY - k1 * leftSecX;
                /*for (uint8_t i = rightFirY; i > realLeftY; i--)
                {
                    uint8_t x = (i - b1) / k1;
                    IMG[i][x] = blue;
                }*/
            }
            if (leftFirX == rightSecX)
            {
                c2 = leftFirX;
            }
            else
            {
                k2 = (leftFirY - rightSecY) / (leftFirX - rightSecX);
                b2 = leftFirY - k2 * leftFirX;
                uint8_t iStart = leftFirY > rightSecY ? leftFirY : rightSecY, iEnd = leftFirY < rightSecY ? leftFirY : rightSecY;
                /*for (uint8_t i = iStart; i > iEnd; i--)
                {
                    uint8_t x = (i - b2) / k2;
                    IMG[i][x] = red;
                }*/
            }
            if (c1 == MISS && c2 == MISS)
            {
                float x = (b2 - b1) / (k1 - k2);
                int	y = k1*x+b1;
                IMG[y][(int)x] = green;

            }
            //更迭xy值
            if (rightSecY - 3 > iRightEnd)
            {
                rightFirX = rightSecX;
                rightFirY = rightSecY;
                rightSecY -= 3;
                rightSecX = rightEdge[rightSecY];
            }
            leftFirX = leftEdge[realLeftY];
            leftFirY = leftSecY;
            if (leftSecY - 6 < iLeftEnd)
            {
                break;
            }
            else
            {
                leftSecY -= 6;
                leftSecX = leftEdge[leftSecY];
            }
        }
    }
}

float image_GetDistance(float x1, float x2, float y1, float y2)
{
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

////////////////////////////////////////////
//功能：中线平均滑动滤波
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_MidLineFilter(void)
{
    mid_line[110] = mid_line[109] = mid_line[108] = 94;
    for (uint8_t i = 107; i > 3; i--)
    {
        if (abs(mid_line[i] - mid_line[i + 1]) > 20)
        {
            mid_line[i] = mid_line[i + 1];
        }
        else
        {
            mid_line[i] = (mid_line[i - 2] + mid_line[i - 1] + mid_line[i] + mid_line[i + 1] + mid_line[i + 2]) / 5;
        }
    }
    mid_line[0] = mid_line[1] = mid_line[2] = mid_line[3];
}
////////////////////////////////////////////
//功能：中线平均滑动滤波(更大卷积核)
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_MidLineFilterEx(void)
{
    mid_line[110] = mid_line[109] = mid_line[108] = 94;
    for (uint8_t i = 80; i > 4; i--)
    {
        if (abs(mid_line[i] - mid_line[i + 1]) > 20)
        {
            mid_line[i] = mid_line[i + 1];
        }
        else
        {
            mid_line[i] = (mid_line[i - 3] + mid_line[i - 2] + mid_line[i - 1] + mid_line[i] + mid_line[i + 1] + mid_line[i + 2] + mid_line[i + 3]) / 7;
        }
    }
    mid_line[0] = mid_line[1] = mid_line[2] = mid_line[3];
}
////////////////////////////////////////////
//功能：中线卡尔曼滤波
//输入：
//输出：
//备注：
///////////////////////////////////////////
void KalmanFilter(void)
{
    for (uint8_t i = 10; i < 114; i++)
    {
        mid_line[i] = (uint8_t)KalmanFilterKernal(mid_line[i], 0.01, 20);
    }
}
////////////////////////////////////////////
//功能：中线异常补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_MidLineCorrector(uint8_t threshold)
{
    uint8_t error = 10;
    for (uint8_t i = 90; i > 10; i--)
    {
        if (abs(mid_line[i] - mid_line[i - 1]) > threshold)
        {
            error = i;
            break;
        }
    }
    image_LineRange(mid_line[error + 15], error + 15, 5, 1, mid_line, mid_line, up);
}
////////////////////////////////////////////
//功能：卡尔曼滤波循环体
//输入：
//输出：
//备注：
///////////////////////////////////////////
static double KalmanFilterKernal(const double ResrcData, double ProcessNiose_Q, double MeasureNoise_R)
{
    double R = MeasureNoise_R;
    double Q = ProcessNiose_Q;
    static double x_last = 94;
    double x_mid = x_last;
    double x_now;
    static double p_last = 94;
    double p_mid;
    double p_now;
    double kg;
    x_mid = x_last;                       //x_last=x(k-1|k-1),x_mid=x(k|k-1)
    p_mid = p_last + Q;                     //p_mid=p(k|k-1),p_last=p(k-1|k-1),Q=噪声
    /*
     *  卡尔曼滤波的五个重要公式
     */
    kg = p_mid / (p_mid + R);                 //kg为kalman filter，R 为噪声
    x_now = x_mid + kg * (ResrcData - x_mid);   //估计出的最优值
    p_now = (1 - kg) * p_mid;                 //最优值对应的covariance
    p_last = p_now;                     //更新covariance 值
    x_last = x_now;                     //更新系统状态值
    return x_now;
}

float image_angle;
int centreX = 94, centreY = 119,elliA = 80;
float elliK = 1;
void image_getDeviation(void)
{
    int i, l1, l2;
    //image_rushFlag = 0;
    int iMidLineVaric = 0, midLineVaric = 0;
    uint8_t rushCounter = 0;
    for (i = centreY; i >= centreY - elliA * elliK; i--)
    {
        uint8_t x1 = centreX + sqrt(elliA * elliA - (i - centreY) * (i - centreY) / (elliK * elliK));
        uint8_t x2 = centreX - sqrt(elliA * elliA - (i - centreY) * (i - centreY) / (elliK * elliK));
        IMG[i][x1] = green;
        IMG[i][x2] = green;
    }
    switch (stateMgr.curtState)
    {
    case enterTrident:
    case TridentStage2:
    case leftTiltEnterTrident:
    case rightTiltEnterTrident:
    case rightRoundaboutStage2:
    case leftRoundaboutStage2:
        image_rushFlag = 0;
        for (i = 100; i > 10; i--)
        {
            l1 = (i - centreY) * (i - centreY) / (elliA * elliA * elliK * elliK) + ((float)mid_line[i] - centreX) * ((float)mid_line[i] - centreX) / (elliA * elliA);
            if (l1 >= 1 || i == 11)
            {
                image_angle = atan((float)(mid_line[i] - centreX) / (centreY - i));          //弧度制
                IMG[i][mid_line[i]] = purple;
                printf("angle:%f\n", image_angle);
                return;
            }

        }
        break;
    case leftRoundaboutStage5:
    case rightRoundaboutStage5:
        image_rushFlag = 0;
        if (roundPatchFlag == 1)
        {
            for (i = 100; i > 10; i--)
            {
                l1 = (i - centreY) * (i - centreY) / (elliA * elliA * elliK * elliK) + ((float)mid_line[i] - centreX) * ((float)mid_line[i] - centreX) / (elliA * elliA);
                if (l1 >= 1 || i == 11)
                {
                    image_angle = atan((float)(mid_line[i] - centreX) / (centreY - i));          //弧度制
                    IMG[i][mid_line[i]] = purple;
                    printf("angle:%f\n", image_angle);
                    return;
                }

            }
        }
        for (i = 92; i > 10; i--)
        {
            l1 = (i - centreY) * (i - centreY) / (elliA * elliA * elliK * elliK) + ((float)midLine[i] - centreX) * ((float)midLine[i] - centreX) / (elliA * elliA);
            if (l1 >= 1 || i == 11)
            {
                image_angle = atan((float)(midLine[i] - centreX) / (centreY - i));          //弧度制
                //IMG[i][midLine[i]] = purple;
                printf("angle:%f\n", image_angle);
                return;
            }
        }
        break;
    case others:
        if (image_rampCanUp == 1)
        {
            if (image_rushFlag == 0)
            {
                for (uint8_t i = FAR_LINE + 35; i > FAR_LINE + 10; i--)
                {
                    if (abs(mid_line[i] - 94) < 8)
                    {
                        rushCounter++;
                    }
                }
                printf("rushCounter:%d\n", rushCounter);
                if (rushCounter > 20)
                {
                    image_rushFlag = 1;
                    printf("rush B!!!\n");
                }
            }
            else if (image_rushFlag == 1)
            {
                for (uint8_t i = FAR_LINE + 35; i > FAR_LINE + 7; i--)
                {
                    if (abs(mid_line[i] - 94) > 20)
                    {
                        rushCounter += 2;
                    }
                    else if (abs(mid_line[i] - 94) > 12)
                    {
                        rushCounter++;
                    }
                }
                printf("anti rushCounter:%d\n", rushCounter);
                if (rushCounter > 15)
                {
                    image_rushFlag = 0;
                }
                if (image_rushFlag == 1)
                {
                    printf("rush B!!!\n");
                }
            }
        }
        if (image_remedyFlag == 4 || image_remedyFlag == 5)
        {
            for (i = 100; i > 10; i--)
            {
                l1 = (i - centreY) * (i - centreY) / (elliA * elliA * elliK * elliK) + ((float)midLine[i] - centreX) * ((float)midLine[i] - centreX) / (elliA * elliA);
                if (l1 >= 1||i==11)
                {
                    image_angle = atan((float)(midLine[i] - centreX) / (centreY - i));          //弧度制
                    //IMG[i][midLine[i]] = purple;
                    printf("angle:%f\n", image_angle);
                    return;
                }
            }
        }
        for (i = 100; i > 10; i--)
        {
            l1 = (i - centreY) * (i - centreY) / (elliA * elliA * elliK * elliK) + ((float)mid_line[i] - centreX) * ((float)mid_line[i] - centreX) / (elliA * elliA);
            if (l1 >= 1||i==11)
            {
                image_angle = atan((float)(mid_line[i] - centreX) / (centreY - i));          //弧度制
                IMG[i][mid_line[i]] = purple;
                printf("angle:%f\n", image_angle);
                return;
            }

        }
        if (abs(image_angle) > 0.30)
        {
            image_rushFlag = 0;
        }
        break;
    default:
        /*for (uint8_t i = 120 - image_foresee; i > 120 - image_foresee - 25; i--)
        {
            iMidLineVaric = (int)mid_line[i] - 94;
            midLineVaric += (iMidLineVaric * iMidLineVaric);
        }
        midLineVaric /= 25;
        printf("midLineVaric:%d\n", midLineVaric);
        if (midLineVaric <= 10)
        {
            image_rushFlag = 1;
        }*/
        if (image_rushFlag == 0)
        {
            for (uint8_t i = FAR_LINE + 35; i > FAR_LINE + 7; i--)
            {
                if (abs(mid_line[i] - 94) < 8)
                {
                    rushCounter++;
                }
            }
            printf("rushCounter:%d\n", rushCounter);
            if (rushCounter > 20)
            {
                image_rushFlag = 1;
                printf("rush B!!!\n");
            }
        }
        else if (image_rushFlag == 1)
        {
            for (uint8_t i = FAR_LINE + 35; i > FAR_LINE + 10; i--)
            {
                if (abs(mid_line[i] - 94) > 20)
                {
                    rushCounter+=2;
                }
                else if (abs(mid_line[i] - 94) > 12)
                {
                    rushCounter ++;
                }
            }
            printf("anti rushCounter:%d\n", rushCounter);
            if (rushCounter > 15)
            {
                image_rushFlag = 0;
            }
            if (image_rushFlag == 1)
            {
                printf("rush B!!!\n");
            }
        }
        for (i = 100; i > 10; i--)
        {
            l1 = (i - centreY) * (i - centreY) / (elliA * elliA * elliK * elliK) + ((float)mid_line[i] - centreX) * ((float)mid_line[i] - centreX) / (elliA * elliA);
            if (l1 >= 1 || i == 11)
            {
                image_angle = atan((float)(mid_line[i] - centreX) / (centreY - i));          //弧度制
                IMG[i][mid_line[i]] = purple;
                printf("angle:%f\n", image_angle);
                return;
            }

        }
        break;
    }
}

